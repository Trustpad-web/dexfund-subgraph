{
  "language": "Solidity",
  "sources": {
    "contracts/mocks/adapters/MockGenericAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../release/extensions/integration-manager/integrations/utils/AdapterBase.sol\";\r\n\r\n/// @title IMockGenericIntegratee Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IMockGenericIntegratee {\r\n    function swap(\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        address[] calldata,\r\n        uint256[] calldata\r\n    ) external payable;\r\n\r\n    function swapOnBehalf(\r\n        address payable,\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        address[] calldata,\r\n        uint256[] calldata\r\n    ) external payable;\r\n}\r\n\r\n/// @title MockGenericAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Provides a generic adapter that:\r\n/// 1. Provides swapping functions that use various `SpendAssetsTransferType` values\r\n/// 2. Directly parses the _actual_ values to swap from provided call data (e.g., `actualIncomingAssetAmounts`)\r\n/// 3. Directly parses values needed by the IntegrationManager from provided call data (e.g., `minIncomingAssetAmounts`)\r\ncontract MockGenericAdapter is AdapterBase {\r\n    address public immutable INTEGRATEE;\r\n\r\n    // No need to specify the IntegrationManager\r\n    constructor(address _integratee) public AdapterBase(address(0)) {\r\n        INTEGRATEE = _integratee;\r\n    }\r\n\r\n    function identifier() external pure override returns (string memory) {\r\n        return \"MOCK_GENERIC\";\r\n    }\r\n\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _callArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory maxSpendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            spendAssets_,\r\n            maxSpendAssetAmounts_,\r\n            ,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_,\r\n\r\n        ) = __decodeCallArgs(_callArgs);\r\n\r\n        return (\r\n            __getSpendAssetsHandleTypeForSelector(_selector),\r\n            spendAssets_,\r\n            maxSpendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Assumes SpendAssetsHandleType.Transfer unless otherwise specified\r\n    function __getSpendAssetsHandleTypeForSelector(bytes4 _selector)\r\n        private\r\n        pure\r\n        returns (IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_)\r\n    {\r\n        if (_selector == bytes4(keccak256(\"removeOnly(address,bytes,bytes)\"))) {\r\n            return IIntegrationManager.SpendAssetsHandleType.Remove;\r\n        }\r\n        if (_selector == bytes4(keccak256(\"swapDirectFromVault(address,bytes,bytes)\"))) {\r\n            return IIntegrationManager.SpendAssetsHandleType.None;\r\n        }\r\n        if (_selector == bytes4(keccak256(\"swapViaApproval(address,bytes,bytes)\"))) {\r\n            return IIntegrationManager.SpendAssetsHandleType.Approve;\r\n        }\r\n        return IIntegrationManager.SpendAssetsHandleType.Transfer;\r\n    }\r\n\r\n    function removeOnly(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external {}\r\n\r\n    function swapA(\r\n        address _vaultProxy,\r\n        bytes calldata _callArgs,\r\n        bytes calldata _assetTransferArgs\r\n    ) external fundAssetsTransferHandler(_vaultProxy, _assetTransferArgs) {\r\n        __decodeCallArgsAndSwap(_callArgs);\r\n    }\r\n\r\n    function swapB(\r\n        address _vaultProxy,\r\n        bytes calldata _callArgs,\r\n        bytes calldata _assetTransferArgs\r\n    ) external fundAssetsTransferHandler(_vaultProxy, _assetTransferArgs) {\r\n        __decodeCallArgsAndSwap(_callArgs);\r\n    }\r\n\r\n    function swapDirectFromVault(\r\n        address _vaultProxy,\r\n        bytes calldata _callArgs,\r\n        bytes calldata\r\n    ) external {\r\n        (\r\n            address[] memory spendAssets,\r\n            ,\r\n            uint256[] memory actualSpendAssetAmounts,\r\n            address[] memory incomingAssets,\r\n            ,\r\n            uint256[] memory actualIncomingAssetAmounts\r\n        ) = __decodeCallArgs(_callArgs);\r\n\r\n        IMockGenericIntegratee(INTEGRATEE).swapOnBehalf(\r\n            payable(_vaultProxy),\r\n            spendAssets,\r\n            actualSpendAssetAmounts,\r\n            incomingAssets,\r\n            actualIncomingAssetAmounts\r\n        );\r\n    }\r\n\r\n    function swapViaApproval(\r\n        address _vaultProxy,\r\n        bytes calldata _callArgs,\r\n        bytes calldata _assetTransferArgs\r\n    ) external fundAssetsTransferHandler(_vaultProxy, _assetTransferArgs) {\r\n        __decodeCallArgsAndSwap(_callArgs);\r\n    }\r\n\r\n    function __decodeCallArgs(bytes memory _callArgs)\r\n        internal\r\n        pure\r\n        returns (\r\n            address[] memory spendAssets_,\r\n            uint256[] memory maxSpendAssetAmounts_,\r\n            uint256[] memory actualSpendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_,\r\n            uint256[] memory actualIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return\r\n            abi.decode(\r\n                _callArgs,\r\n                (address[], uint256[], uint256[], address[], uint256[], uint256[])\r\n            );\r\n    }\r\n\r\n    function __decodeCallArgsAndSwap(bytes memory _callArgs) internal {\r\n        (\r\n            address[] memory spendAssets,\r\n            ,\r\n            uint256[] memory actualSpendAssetAmounts,\r\n            address[] memory incomingAssets,\r\n            ,\r\n            uint256[] memory actualIncomingAssetAmounts\r\n        ) = __decodeCallArgs(_callArgs);\r\n\r\n        for (uint256 i; i < spendAssets.length; i++) {\r\n            ERC20(spendAssets[i]).approve(INTEGRATEE, actualSpendAssetAmounts[i]);\r\n        }\r\n        IMockGenericIntegratee(INTEGRATEE).swap(\r\n            spendAssets,\r\n            actualSpendAssetAmounts,\r\n            incomingAssets,\r\n            actualIncomingAssetAmounts\r\n        );\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/AdapterBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../IIntegrationAdapter.sol\";\r\nimport \"./IntegrationSelectors.sol\";\r\n\r\n/// @title AdapterBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A base contract for integration adapters\r\nabstract contract AdapterBase is IIntegrationAdapter, IntegrationSelectors {\r\n    using SafeERC20 for ERC20;\r\n\r\n    address internal immutable INTEGRATION_MANAGER;\r\n\r\n    /// @dev Provides a standard implementation for transferring assets between\r\n    /// the fund's VaultProxy and the adapter, by wrapping the adapter action.\r\n    /// This modifier should be implemented in almost all adapter actions, unless they\r\n    /// do not move assets or can spend and receive assets directly with the VaultProxy\r\n    modifier fundAssetsTransferHandler(\r\n        address _vaultProxy,\r\n        bytes memory _encodedAssetTransferArgs\r\n    ) {\r\n        (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        // Take custody of spend assets (if necessary)\r\n        if (spendAssetsHandleType == IIntegrationManager.SpendAssetsHandleType.Approve) {\r\n            for (uint256 i = 0; i < spendAssets.length; i++) {\r\n                ERC20(spendAssets[i]).safeTransferFrom(\r\n                    _vaultProxy,\r\n                    address(this),\r\n                    spendAssetAmounts[i]\r\n                );\r\n            }\r\n        }\r\n\r\n        // Execute call\r\n        _;\r\n\r\n        // Transfer remaining assets back to the fund's VaultProxy\r\n        __transferContractAssetBalancesToFund(_vaultProxy, incomingAssets);\r\n        __transferContractAssetBalancesToFund(_vaultProxy, spendAssets);\r\n    }\r\n\r\n    modifier onlyIntegrationManager() {\r\n        require(\r\n            msg.sender == INTEGRATION_MANAGER,\r\n            \"Only the IntegrationManager can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _integrationManager) public {\r\n        INTEGRATION_MANAGER = _integrationManager;\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Helper for adapters to approve their integratees with the max amount of an asset.\r\n    /// Since everything is done atomically, and only the balances to-be-used are sent to adapters,\r\n    /// there is no need to approve exact amounts on every call.\r\n    function __approveMaxAsNeeded(\r\n        address _asset,\r\n        address _target,\r\n        uint256 _neededAmount\r\n    ) internal {\r\n        if (ERC20(_asset).allowance(address(this), _target) < _neededAmount) {\r\n            ERC20(_asset).safeApprove(_target, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to decode the _encodedAssetTransferArgs param passed to adapter call\r\n    function __decodeEncodedAssetTransferArgs(bytes memory _encodedAssetTransferArgs)\r\n        internal\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_\r\n        )\r\n    {\r\n        return\r\n            abi.decode(\r\n                _encodedAssetTransferArgs,\r\n                (IIntegrationManager.SpendAssetsHandleType, address[], uint256[], address[])\r\n            );\r\n    }\r\n\r\n    /// @dev Helper to transfer full contract balances of assets to the specified VaultProxy\r\n    function __transferContractAssetBalancesToFund(address _vaultProxy, address[] memory _assets)\r\n        private\r\n    {\r\n        for (uint256 i = 0; i < _assets.length; i++) {\r\n            uint256 postCallAmount = ERC20(_assets[i]).balanceOf(address(this));\r\n            if (postCallAmount > 0) {\r\n                ERC20(_assets[i]).safeTransfer(_vaultProxy, postCallAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `INTEGRATION_MANAGER` variable\r\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\r\n    function getIntegrationManager() external view returns (address integrationManager_) {\r\n        return INTEGRATION_MANAGER;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/IIntegrationAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../IIntegrationManager.sol\";\r\n\r\n/// @title Integration Adapter interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for all integration adapters\r\ninterface IIntegrationAdapter {\r\n    function identifier() external pure returns (string memory identifier_);\r\n\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        );\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/IntegrationSelectors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IntegrationSelectors Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Selectors for integration actions\r\n/// @dev Selectors are created from their signatures rather than hardcoded for easy verification\r\nabstract contract IntegrationSelectors {\r\n    // Tracked assets\r\n    bytes4 public constant ADD_TRACKED_ASSETS_SELECTOR = bytes4(\r\n        keccak256(\"addTrackedAssets(address,bytes,bytes)\")\r\n    );\r\n    bytes4 public constant REMOVE_TRACKED_ASSETS_SELECTOR = bytes4(\r\n        keccak256(\"removeTrackedAssets(address,bytes,bytes)\")\r\n    );\r\n\r\n    // Asset approval\r\n    bytes4 public constant APPROVE_ASSETS_SELECTOR = bytes4(\r\n        keccak256(\"approveAssets(address,bytes,bytes)\")\r\n    );\r\n\r\n    // Trading\r\n    bytes4 public constant TAKE_ORDER_SELECTOR = bytes4(\r\n        keccak256(\"takeOrder(address,bytes,bytes)\")\r\n    );\r\n\r\n    // Lending\r\n    bytes4 public constant LEND_SELECTOR = bytes4(keccak256(\"lend(address,bytes,bytes)\"));\r\n    bytes4 public constant REDEEM_SELECTOR = bytes4(keccak256(\"redeem(address,bytes,bytes)\"));\r\n\r\n    // Staking\r\n    bytes4 public constant STAKE_SELECTOR = bytes4(keccak256(\"stake(address,bytes,bytes)\"));\r\n    bytes4 public constant UNSTAKE_SELECTOR = bytes4(keccak256(\"unstake(address,bytes,bytes)\"));\r\n\r\n    // Rewards\r\n    bytes4 public constant CLAIM_REWARDS_SELECTOR = bytes4(\r\n        keccak256(\"claimRewards(address,bytes,bytes)\")\r\n    );\r\n\r\n    // Combined\r\n    bytes4 public constant CLAIM_REWARDS_AND_REINVEST_SELECTOR = bytes4(\r\n        keccak256(\"claimRewardsAndReinvest(address,bytes,bytes)\")\r\n    );\r\n    bytes4 public constant CLAIM_REWARDS_AND_SWAP_SELECTOR = bytes4(\r\n        keccak256(\"claimRewardsAndSwap(address,bytes,bytes)\")\r\n    );\r\n    bytes4 public constant LEND_AND_STAKE_SELECTOR = bytes4(\r\n        keccak256(\"lendAndStake(address,bytes,bytes)\")\r\n    );\r\n    bytes4 public constant UNSTAKE_AND_REDEEM_SELECTOR = bytes4(\r\n        keccak256(\"unstakeAndRedeem(address,bytes,bytes)\")\r\n    );\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/IIntegrationManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IIntegrationManager interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for the IntegrationManager\r\ninterface IIntegrationManager {\r\n    enum SpendAssetsHandleType {None, Approve, Transfer, Remove}\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/ZeroExV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../interfaces/IZeroExV2.sol\";\r\nimport \"../../../../utils/MathHelpers.sol\";\r\nimport \"../../../../utils/AddressArrayLib.sol\";\r\nimport \"../../../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title ZeroExV2Adapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter to 0xV2 Exchange Contract\r\ncontract ZeroExV2Adapter is AdapterBase, FundDeployerOwnerMixin, MathHelpers {\r\n    using AddressArrayLib for address[];\r\n    using SafeMath for uint256;\r\n\r\n    event AllowedMakerAdded(address indexed account);\r\n\r\n    event AllowedMakerRemoved(address indexed account);\r\n\r\n    address private immutable EXCHANGE;\r\n    mapping(address => bool) private makerToIsAllowed;\r\n\r\n    // Gas could be optimized for the end-user by also storing an immutable ZRX_ASSET_DATA,\r\n    // for example, but in the narrow OTC use-case of this adapter, taker fees are unlikely.\r\n    constructor(\r\n        address _integrationManager,\r\n        address _exchange,\r\n        address _fundDeployer,\r\n        address[] memory _allowedMakers\r\n    ) public AdapterBase(_integrationManager) FundDeployerOwnerMixin(_fundDeployer) {\r\n        EXCHANGE = _exchange;\r\n        if (_allowedMakers.length > 0) {\r\n            __addAllowedMakers(_allowedMakers);\r\n        }\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ZERO_EX_V2\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n\r\n        (\r\n            bytes memory encodedZeroExOrderArgs,\r\n            uint256 takerAssetFillAmount\r\n        ) = __decodeTakeOrderCallArgs(_encodedCallArgs);\r\n        IZeroExV2.Order memory order = __constructOrderStruct(encodedZeroExOrderArgs);\r\n\r\n        require(\r\n            isAllowedMaker(order.makerAddress),\r\n            \"parseAssetsForMethod: Order maker is not allowed\"\r\n        );\r\n        require(\r\n            takerAssetFillAmount <= order.takerAssetAmount,\r\n            \"parseAssetsForMethod: Taker asset fill amount greater than available\"\r\n        );\r\n\r\n        address makerAsset = __getAssetAddress(order.makerAssetData);\r\n        address takerAsset = __getAssetAddress(order.takerAssetData);\r\n\r\n        // Format incoming assets\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = makerAsset;\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = __calcRelativeQuantity(\r\n            order.takerAssetAmount,\r\n            order.makerAssetAmount,\r\n            takerAssetFillAmount\r\n        );\r\n\r\n        if (order.takerFee > 0) {\r\n            address takerFeeAsset = __getAssetAddress(IZeroExV2(EXCHANGE).ZRX_ASSET_DATA());\r\n            uint256 takerFeeFillAmount = __calcRelativeQuantity(\r\n                order.takerAssetAmount,\r\n                order.takerFee,\r\n                takerAssetFillAmount\r\n            ); // fee calculated relative to taker fill amount\r\n\r\n            if (takerFeeAsset == makerAsset) {\r\n                require(\r\n                    order.takerFee < order.makerAssetAmount,\r\n                    \"parseAssetsForMethod: Fee greater than makerAssetAmount\"\r\n                );\r\n\r\n                spendAssets_ = new address[](1);\r\n                spendAssets_[0] = takerAsset;\r\n\r\n                spendAssetAmounts_ = new uint256[](1);\r\n                spendAssetAmounts_[0] = takerAssetFillAmount;\r\n\r\n                minIncomingAssetAmounts_[0] = minIncomingAssetAmounts_[0].sub(takerFeeFillAmount);\r\n            } else if (takerFeeAsset == takerAsset) {\r\n                spendAssets_ = new address[](1);\r\n                spendAssets_[0] = takerAsset;\r\n\r\n                spendAssetAmounts_ = new uint256[](1);\r\n                spendAssetAmounts_[0] = takerAssetFillAmount.add(takerFeeFillAmount);\r\n            } else {\r\n                spendAssets_ = new address[](2);\r\n                spendAssets_[0] = takerAsset;\r\n                spendAssets_[1] = takerFeeAsset;\r\n\r\n                spendAssetAmounts_ = new uint256[](2);\r\n                spendAssetAmounts_[0] = takerAssetFillAmount;\r\n                spendAssetAmounts_[1] = takerFeeFillAmount;\r\n            }\r\n        } else {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = takerAsset;\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = takerAssetFillAmount;\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Take an order on 0x\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            bytes memory encodedZeroExOrderArgs,\r\n            uint256 takerAssetFillAmount\r\n        ) = __decodeTakeOrderCallArgs(_encodedCallArgs);\r\n        IZeroExV2.Order memory order = __constructOrderStruct(encodedZeroExOrderArgs);\r\n\r\n        // Approve spend assets as needed\r\n        __approveMaxAsNeeded(\r\n            __getAssetAddress(order.takerAssetData),\r\n            __getAssetProxy(order.takerAssetData),\r\n            takerAssetFillAmount\r\n        );\r\n        // Ignores whether makerAsset or takerAsset overlap with the takerFee asset for simplicity\r\n        if (order.takerFee > 0) {\r\n            bytes memory zrxData = IZeroExV2(EXCHANGE).ZRX_ASSET_DATA();\r\n            __approveMaxAsNeeded(\r\n                __getAssetAddress(zrxData),\r\n                __getAssetProxy(zrxData),\r\n                __calcRelativeQuantity(\r\n                    order.takerAssetAmount,\r\n                    order.takerFee,\r\n                    takerAssetFillAmount\r\n                ) // fee calculated relative to taker fill amount\r\n            );\r\n        }\r\n\r\n        // Execute order\r\n        (, , , bytes memory signature) = __decodeZeroExOrderArgs(encodedZeroExOrderArgs);\r\n        IZeroExV2(EXCHANGE).fillOrder(order, takerAssetFillAmount, signature);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Parses user inputs into a ZeroExV2.Order format\r\n    function __constructOrderStruct(bytes memory _encodedOrderArgs)\r\n        private\r\n        pure\r\n        returns (IZeroExV2.Order memory order_)\r\n    {\r\n        (\r\n            address[4] memory orderAddresses,\r\n            uint256[6] memory orderValues,\r\n            bytes[2] memory orderData,\r\n\r\n        ) = __decodeZeroExOrderArgs(_encodedOrderArgs);\r\n\r\n        return\r\n            IZeroExV2.Order({\r\n                makerAddress: orderAddresses[0],\r\n                takerAddress: orderAddresses[1],\r\n                feeRecipientAddress: orderAddresses[2],\r\n                senderAddress: orderAddresses[3],\r\n                makerAssetAmount: orderValues[0],\r\n                takerAssetAmount: orderValues[1],\r\n                makerFee: orderValues[2],\r\n                takerFee: orderValues[3],\r\n                expirationTimeSeconds: orderValues[4],\r\n                salt: orderValues[5],\r\n                makerAssetData: orderData[0],\r\n                takerAssetData: orderData[1]\r\n            });\r\n    }\r\n\r\n    /// @dev Decode the parameters of a takeOrder call\r\n    /// @param _encodedCallArgs Encoded parameters passed from client side\r\n    /// @return encodedZeroExOrderArgs_ Encoded args of the 0x order\r\n    /// @return takerAssetFillAmount_ Amount of taker asset to fill\r\n    function __decodeTakeOrderCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (bytes memory encodedZeroExOrderArgs_, uint256 takerAssetFillAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bytes, uint256));\r\n    }\r\n\r\n    /// @dev Decode the parameters of a 0x order\r\n    /// @param _encodedZeroExOrderArgs Encoded parameters of the 0x order\r\n    /// @return orderAddresses_ Addresses used in the order\r\n    /// - [0] 0x Order param: makerAddress\r\n    /// - [1] 0x Order param: takerAddress\r\n    /// - [2] 0x Order param: feeRecipientAddress\r\n    /// - [3] 0x Order param: senderAddress\r\n    /// @return orderValues_ Values used in the order\r\n    /// - [0] 0x Order param: makerAssetAmount\r\n    /// - [1] 0x Order param: takerAssetAmount\r\n    /// - [2] 0x Order param: makerFee\r\n    /// - [3] 0x Order param: takerFee\r\n    /// - [4] 0x Order param: expirationTimeSeconds\r\n    /// - [5] 0x Order param: salt\r\n    /// @return orderData_ Bytes data used in the order\r\n    /// - [0] 0x Order param: makerAssetData\r\n    /// - [1] 0x Order param: takerAssetData\r\n    /// @return signature_ Signature of the order\r\n    function __decodeZeroExOrderArgs(bytes memory _encodedZeroExOrderArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address[4] memory orderAddresses_,\r\n            uint256[6] memory orderValues_,\r\n            bytes[2] memory orderData_,\r\n            bytes memory signature_\r\n        )\r\n    {\r\n        return abi.decode(_encodedZeroExOrderArgs, (address[4], uint256[6], bytes[2], bytes));\r\n    }\r\n\r\n    /// @dev Parses the asset address from 0x assetData\r\n    function __getAssetAddress(bytes memory _assetData)\r\n        private\r\n        pure\r\n        returns (address assetAddress_)\r\n    {\r\n        assembly {\r\n            assetAddress_ := mload(add(_assetData, 36))\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the 0x assetProxy address for an ERC20 token\r\n    function __getAssetProxy(bytes memory _assetData) private view returns (address assetProxy_) {\r\n        bytes4 assetProxyId;\r\n\r\n        assembly {\r\n            assetProxyId := and(\r\n                mload(add(_assetData, 32)),\r\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n            )\r\n        }\r\n        assetProxy_ = IZeroExV2(EXCHANGE).getAssetProxy(assetProxyId);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // ALLOWED MAKERS REGISTRY //\r\n    /////////////////////////////\r\n\r\n    /// @notice Adds accounts to the list of allowed 0x order makers\r\n    /// @param _accountsToAdd Accounts to add\r\n    function addAllowedMakers(address[] calldata _accountsToAdd) external onlyFundDeployerOwner {\r\n        __addAllowedMakers(_accountsToAdd);\r\n    }\r\n\r\n    /// @notice Removes accounts from the list of allowed 0x order makers\r\n    /// @param _accountsToRemove Accounts to remove\r\n    function removeAllowedMakers(address[] calldata _accountsToRemove)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(_accountsToRemove.length > 0, \"removeAllowedMakers: Empty _accountsToRemove\");\r\n\r\n        for (uint256 i; i < _accountsToRemove.length; i++) {\r\n            require(\r\n                isAllowedMaker(_accountsToRemove[i]),\r\n                \"removeAllowedMakers: Account is not an allowed maker\"\r\n            );\r\n\r\n            makerToIsAllowed[_accountsToRemove[i]] = false;\r\n\r\n            emit AllowedMakerRemoved(_accountsToRemove[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to add accounts to the list of allowed makers\r\n    function __addAllowedMakers(address[] memory _accountsToAdd) private {\r\n        require(_accountsToAdd.length > 0, \"__addAllowedMakers: Empty _accountsToAdd\");\r\n\r\n        for (uint256 i; i < _accountsToAdd.length; i++) {\r\n            require(!isAllowedMaker(_accountsToAdd[i]), \"__addAllowedMakers: Value already set\");\r\n\r\n            makerToIsAllowed[_accountsToAdd[i]] = true;\r\n\r\n            emit AllowedMakerAdded(_accountsToAdd[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `EXCHANGE` variable value\r\n    /// @return exchange_ The `EXCHANGE` variable value\r\n    function getExchange() external view returns (address exchange_) {\r\n        return EXCHANGE;\r\n    }\r\n\r\n    /// @notice Checks whether an account is an allowed maker of 0x orders\r\n    /// @param _who The account to check\r\n    /// @return isAllowedMaker_ True if _who is an allowed maker\r\n    function isAllowedMaker(address _who) public view returns (bool isAllowedMaker_) {\r\n        return makerToIsAllowed[_who];\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IZeroExV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\r\ninterface IZeroExV2 {\r\n    struct Order {\r\n        address makerAddress;\r\n        address takerAddress;\r\n        address feeRecipientAddress;\r\n        address senderAddress;\r\n        uint256 makerAssetAmount;\r\n        uint256 takerAssetAmount;\r\n        uint256 makerFee;\r\n        uint256 takerFee;\r\n        uint256 expirationTimeSeconds;\r\n        uint256 salt;\r\n        bytes makerAssetData;\r\n        bytes takerAssetData;\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint8 orderStatus;\r\n        bytes32 orderHash;\r\n        uint256 orderTakerAssetFilledAmount;\r\n    }\r\n\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;\r\n        uint256 takerAssetFilledAmount;\r\n        uint256 makerFeePaid;\r\n        uint256 takerFeePaid;\r\n    }\r\n\r\n    function ZRX_ASSET_DATA() external view returns (bytes memory);\r\n\r\n    function filled(bytes32) external view returns (uint256);\r\n\r\n    function cancelled(bytes32) external view returns (bool);\r\n\r\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\r\n\r\n    function getAssetProxy(bytes4) external view returns (address);\r\n\r\n    function isValidSignature(\r\n        bytes32,\r\n        address,\r\n        bytes calldata\r\n    ) external view returns (bool);\r\n\r\n    function preSign(\r\n        bytes32,\r\n        address,\r\n        bytes calldata\r\n    ) external;\r\n\r\n    function cancelOrder(Order calldata) external;\r\n\r\n    function fillOrder(\r\n        Order calldata,\r\n        uint256,\r\n        bytes calldata\r\n    ) external returns (FillResults memory);\r\n}\r\n"
    },
    "contracts/release/utils/MathHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n/// @title MathHelpers Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Helper functions for common math operations\r\nabstract contract MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Calculates a proportional value relative to a known ratio\r\n    function __calcRelativeQuantity(\r\n        uint256 _quantity1,\r\n        uint256 _quantity2,\r\n        uint256 _relativeQuantity1\r\n    ) internal pure returns (uint256 relativeQuantity2_) {\r\n        return _relativeQuantity1.mul(_quantity2).div(_quantity1);\r\n    }\r\n\r\n    /// @dev Calculates a rate normalized to 10^18 precision,\r\n    /// for given base and quote asset decimals and amounts\r\n    function __calcNormalizedRate(\r\n        uint256 _baseAssetDecimals,\r\n        uint256 _baseAssetAmount,\r\n        uint256 _quoteAssetDecimals,\r\n        uint256 _quoteAssetAmount\r\n    ) internal pure returns (uint256 normalizedRate_) {\r\n        return\r\n            _quoteAssetAmount.mul(10**_baseAssetDecimals.add(18)).div(\r\n                _baseAssetAmount.mul(10**_quoteAssetDecimals)\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/release/utils/AddressArrayLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title AddressArray Library\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A library to extend the address array data type\r\nlibrary AddressArrayLib {\r\n    /// @dev Helper to add an item to an array. Does not assert uniqueness of the new item.\r\n    function addItem(address[] memory _self, address _itemToAdd)\r\n        internal\r\n        pure\r\n        returns (address[] memory nextArray_)\r\n    {\r\n        nextArray_ = new address[](_self.length + 1);\r\n        for (uint256 i; i < _self.length; i++) {\r\n            nextArray_[i] = _self[i];\r\n        }\r\n        nextArray_[_self.length] = _itemToAdd;\r\n\r\n        return nextArray_;\r\n    }\r\n\r\n    /// @dev Helper to add an item to an array, only if it is not already in the array.\r\n    function addUniqueItem(address[] memory _self, address _itemToAdd)\r\n        internal\r\n        pure\r\n        returns (address[] memory nextArray_)\r\n    {\r\n        if (contains(_self, _itemToAdd)) {\r\n            return _self;\r\n        }\r\n\r\n        return addItem(_self, _itemToAdd);\r\n    }\r\n\r\n    /// @dev Helper to verify if an array contains a particular value\r\n    function contains(address[] memory _self, address _target)\r\n        internal\r\n        pure\r\n        returns (bool doesContain_)\r\n    {\r\n        for (uint256 i; i < _self.length; i++) {\r\n            if (_target == _self[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Helper to reassign all items in an array with a specified value\r\n    function fill(address[] memory _self, address _value)\r\n        internal\r\n        pure\r\n        returns (address[] memory nextArray_)\r\n    {\r\n        nextArray_ = new address[](_self.length);\r\n        for (uint256 i; i < nextArray_.length; i++) {\r\n            nextArray_[i] = _value;\r\n        }\r\n\r\n        return nextArray_;\r\n    }\r\n\r\n    /// @dev Helper to verify if array is a set of unique values.\r\n    /// Does not assert length > 0.\r\n    function isUniqueSet(address[] memory _self) internal pure returns (bool isUnique_) {\r\n        if (_self.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        uint256 arrayLength = _self.length;\r\n        for (uint256 i; i < arrayLength; i++) {\r\n            for (uint256 j = i + 1; j < arrayLength; j++) {\r\n                if (_self[i] == _self[j]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Helper to remove items from an array. Removes all matching occurrences of each item.\r\n    /// Does not assert uniqueness of either array.\r\n    function removeItems(address[] memory _self, address[] memory _itemsToRemove)\r\n        internal\r\n        pure\r\n        returns (address[] memory nextArray_)\r\n    {\r\n        if (_itemsToRemove.length == 0) {\r\n            return _self;\r\n        }\r\n\r\n        bool[] memory indexesToRemove = new bool[](_self.length);\r\n        uint256 remainingItemsCount = _self.length;\r\n        for (uint256 i; i < _self.length; i++) {\r\n            if (contains(_itemsToRemove, _self[i])) {\r\n                indexesToRemove[i] = true;\r\n                remainingItemsCount--;\r\n            }\r\n        }\r\n\r\n        if (remainingItemsCount == _self.length) {\r\n            nextArray_ = _self;\r\n        } else if (remainingItemsCount > 0) {\r\n            nextArray_ = new address[](remainingItemsCount);\r\n            uint256 nextArrayIndex;\r\n            for (uint256 i; i < _self.length; i++) {\r\n                if (!indexesToRemove[i]) {\r\n                    nextArray_[nextArrayIndex] = _self[i];\r\n                    nextArrayIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return nextArray_;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/utils/FundDeployerOwnerMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../core/fund-deployer/IFundDeployer.sol\";\r\n\r\n/// @title FundDeployerOwnerMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\r\nabstract contract FundDeployerOwnerMixin {\r\n    address internal immutable FUND_DEPLOYER;\r\n\r\n    modifier onlyFundDeployerOwner() {\r\n        require(\r\n            msg.sender == getOwner(),\r\n            \"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _fundDeployer) public {\r\n        FUND_DEPLOYER = _fundDeployer;\r\n    }\r\n\r\n    /// @notice Gets the owner of this contract\r\n    /// @return owner_ The owner\r\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\r\n    function getOwner() public view returns (address owner_) {\r\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `FUND_DEPLOYER` variable\r\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\r\n    function getFundDeployer() external view returns (address fundDeployer_) {\r\n        return FUND_DEPLOYER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/core/fund-deployer/IFundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IFundDeployer Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IFundDeployer {\r\n    enum ReleaseStatus {PreLaunch, Live, Paused}\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function getReleaseStatus() external view returns (ReleaseStatus);\r\n\r\n    function isRegisteredVaultCall(address, bytes4) external view returns (bool);\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/primitives/ChainlinkPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../extensions/utils/FundDeployerOwnerMixin.sol\";\nimport \"../../../interfaces/IChainlinkAggregator.sol\";\nimport \"./IPrimitivePriceFeed.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title ChainlinkPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A price feed that uses Chainlink oracles as price sources\ncontract ChainlinkPriceFeed is IPrimitivePriceFeed, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event EthUsdAggregatorSet(address prevEthUsdAggregator, address nextEthUsdAggregator);\n\n    event PrimitiveAdded(\n        address indexed primitive,\n        address aggregator,\n        RateAsset rateAsset,\n        uint256 unit\n    );\n\n    event PrimitiveRemoved(address indexed primitive);\n\n    event PrimitiveUpdated(\n        address indexed primitive,\n        address prevAggregator,\n        address nextAggregator\n    );\n\n    event StalePrimitiveRemoved(address indexed primitive);\n\n    event StaleRateThresholdSet(uint256 prevStaleRateThreshold, uint256 nextStaleRateThreshold);\n\n    enum RateAsset {\n        ETH,\n        USD\n    }\n\n    struct AggregatorInfo {\n        address aggregator;\n        RateAsset rateAsset;\n    }\n\n    uint256 private constant ETH_UNIT = 10**18;\n    address private immutable WETH_TOKEN;\n\n    address private ethUsdAggregator;\n    uint256 private staleRateThreshold;\n    mapping(address => AggregatorInfo) private primitiveToAggregatorInfo;\n    mapping(address => uint256) private primitiveToUnit;\n\n    constructor(\n        address _fundDeployer,\n        address _wethToken,\n        address _ethUsdAggregator,\n        address[] memory _primitives,\n        address[] memory _aggregators,\n        RateAsset[] memory _rateAssets\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        WETH_TOKEN = _wethToken;\n        staleRateThreshold = 25 hours; // 24 hour heartbeat + 1hr buffer\n        __setEthUsdAggregator(_ethUsdAggregator);\n        if (_primitives.length > 0) {\n            __addPrimitives(_primitives, _aggregators, _rateAssets);\n        }\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the value of a base asset in terms of a quote asset (using a canonical rate)\n    /// @param _baseAsset The base asset\n    /// @param _baseAssetAmount The base asset amount to convert\n    /// @param _quoteAsset The quote asset\n    /// @return quoteAssetAmount_ The equivalent quote asset amount\n    /// @return isValid_ True if the rates used in calculations are deemed valid\n    function calcCanonicalValue(\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        address _quoteAsset\n    ) public view override returns (uint256 quoteAssetAmount_, bool isValid_) {\n        // Case where _baseAsset == _quoteAsset is handled by ValueInterpreter\n\n        int256 baseAssetRate = __getLatestRateData(_baseAsset);\n        if (baseAssetRate <= 0) {\n            return (0, false);\n        }\n\n        int256 quoteAssetRate = __getLatestRateData(_quoteAsset);\n        if (quoteAssetRate <= 0) {\n            return (0, false);\n        }\n\n        (quoteAssetAmount_, isValid_) = __calcConversionAmount(\n            _baseAsset,\n            _baseAssetAmount,\n            uint256(baseAssetRate),\n            _quoteAsset,\n            uint256(quoteAssetRate)\n        );\n\n        return (quoteAssetAmount_, isValid_);\n    }\n\n    /// @notice Calculates the value of a base asset in terms of a quote asset (using a live rate)\n    /// @param _baseAsset The base asset\n    /// @param _baseAssetAmount The base asset amount to convert\n    /// @param _quoteAsset The quote asset\n    /// @return quoteAssetAmount_ The equivalent quote asset amount\n    /// @return isValid_ True if the rates used in calculations are deemed valid\n    /// @dev Live and canonical values are the same for Chainlink\n    function calcLiveValue(\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        address _quoteAsset\n    ) external view override returns (uint256 quoteAssetAmount_, bool isValid_) {\n        return calcCanonicalValue(_baseAsset, _baseAssetAmount, _quoteAsset);\n    }\n\n    /// @notice Checks whether an asset is a supported primitive of the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported primitive\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\n        return _asset == WETH_TOKEN || primitiveToAggregatorInfo[_asset].aggregator != address(0);\n    }\n\n    /// @notice Sets the `ehUsdAggregator` variable value\n    /// @param _nextEthUsdAggregator The `ehUsdAggregator` value to set\n    function setEthUsdAggregator(address _nextEthUsdAggregator) external onlyFundDeployerOwner {\n        __setEthUsdAggregator(_nextEthUsdAggregator);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to convert an amount from a _baseAsset to a _quoteAsset\n    function __calcConversionAmount(\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetRate,\n        address _quoteAsset,\n        uint256 _quoteAssetRate\n    ) private view returns (uint256 quoteAssetAmount_, bool isValid_) {\n        RateAsset baseAssetRateAsset = getRateAssetForPrimitive(_baseAsset);\n        RateAsset quoteAssetRateAsset = getRateAssetForPrimitive(_quoteAsset);\n        uint256 baseAssetUnit = getUnitForPrimitive(_baseAsset);\n        uint256 quoteAssetUnit = getUnitForPrimitive(_quoteAsset);\n\n        // If rates are both in ETH or both in USD\n        if (baseAssetRateAsset == quoteAssetRateAsset) {\n            return (\n                __calcConversionAmountSameRateAsset(\n                    _baseAssetAmount,\n                    baseAssetUnit,\n                    _baseAssetRate,\n                    quoteAssetUnit,\n                    _quoteAssetRate\n                ),\n                true\n            );\n        }\n\n        int256 ethPerUsdRate = IChainlinkAggregator(ethUsdAggregator).latestAnswer();\n        if (ethPerUsdRate <= 0) {\n            return (0, false);\n        }\n\n        // If _baseAsset's rate is in ETH and _quoteAsset's rate is in USD\n        if (baseAssetRateAsset == RateAsset.ETH) {\n            return (\n                __calcConversionAmountEthRateAssetToUsdRateAsset(\n                    _baseAssetAmount,\n                    baseAssetUnit,\n                    _baseAssetRate,\n                    quoteAssetUnit,\n                    _quoteAssetRate,\n                    uint256(ethPerUsdRate)\n                ),\n                true\n            );\n        }\n\n        // If _baseAsset's rate is in USD and _quoteAsset's rate is in ETH\n        return (\n            __calcConversionAmountUsdRateAssetToEthRateAsset(\n                _baseAssetAmount,\n                baseAssetUnit,\n                _baseAssetRate,\n                quoteAssetUnit,\n                _quoteAssetRate,\n                uint256(ethPerUsdRate)\n            ),\n            true\n        );\n    }\n\n    /// @dev Helper to convert amounts where the base asset has an ETH rate and the quote asset has a USD rate\n    function __calcConversionAmountEthRateAssetToUsdRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate,\n        uint256 _ethPerUsdRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow.\n        // Intermediate step needed to resolve stack-too-deep error.\n        uint256 intermediateStep = _baseAssetAmount.mul(_baseAssetRate).mul(_ethPerUsdRate).div(\n            ETH_UNIT\n        );\n\n        return intermediateStep.mul(_quoteAssetUnit).div(_baseAssetUnit).div(_quoteAssetRate);\n    }\n\n    /// @dev Helper to convert amounts where base and quote assets both have ETH rates or both have USD rates\n    function __calcConversionAmountSameRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow\n        return\n            _baseAssetAmount.mul(_baseAssetRate).mul(_quoteAssetUnit).div(\n                _baseAssetUnit.mul(_quoteAssetRate)\n            );\n    }\n\n    /// @dev Helper to convert amounts where the base asset has a USD rate and the quote asset has an ETH rate\n    function __calcConversionAmountUsdRateAssetToEthRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate,\n        uint256 _ethPerUsdRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow\n        // Intermediate step needed to resolve stack-too-deep error.\n        uint256 intermediateStep = _baseAssetAmount.mul(_baseAssetRate).mul(_quoteAssetUnit).div(\n            _ethPerUsdRate\n        );\n\n        return intermediateStep.mul(ETH_UNIT).div(_baseAssetUnit).div(_quoteAssetRate);\n    }\n\n    /// @dev Helper to get the latest rate for a given primitive\n    function __getLatestRateData(address _primitive) private view returns (int256 rate_) {\n        if (_primitive == WETH_TOKEN) {\n            return int256(ETH_UNIT);\n        }\n\n        address aggregator = primitiveToAggregatorInfo[_primitive].aggregator;\n        require(aggregator != address(0), \"__getLatestRateData: Primitive does not exist\");\n\n        return IChainlinkAggregator(aggregator).latestAnswer();\n    }\n\n    /// @dev Helper to set the `ethUsdAggregator` value\n    function __setEthUsdAggregator(address _nextEthUsdAggregator) private {\n        address prevEthUsdAggregator = ethUsdAggregator;\n        require(\n            _nextEthUsdAggregator != prevEthUsdAggregator,\n            \"__setEthUsdAggregator: Value already set\"\n        );\n\n        __validateAggregator(_nextEthUsdAggregator);\n\n        ethUsdAggregator = _nextEthUsdAggregator;\n\n        emit EthUsdAggregatorSet(prevEthUsdAggregator, _nextEthUsdAggregator);\n    }\n\n    /////////////////////////\n    // PRIMITIVES REGISTRY //\n    /////////////////////////\n\n    /// @notice Adds a list of primitives with the given aggregator and rateAsset values\n    /// @param _primitives The primitives to add\n    /// @param _aggregators The ordered aggregators corresponding to the list of _primitives\n    /// @param _rateAssets The ordered rate assets corresponding to the list of _primitives\n    function addPrimitives(\n        address[] calldata _primitives,\n        address[] calldata _aggregators,\n        RateAsset[] calldata _rateAssets\n    ) external onlyFundDeployerOwner {\n        require(_primitives.length > 0, \"addPrimitives: _primitives cannot be empty\");\n\n        __addPrimitives(_primitives, _aggregators, _rateAssets);\n    }\n\n    /// @notice Removes a list of primitives from the feed\n    /// @param _primitives The primitives to remove\n    function removePrimitives(address[] calldata _primitives) external onlyFundDeployerOwner {\n        require(_primitives.length > 0, \"removePrimitives: _primitives cannot be empty\");\n\n        for (uint256 i; i < _primitives.length; i++) {\n            require(\n                primitiveToAggregatorInfo[_primitives[i]].aggregator != address(0),\n                \"removePrimitives: Primitive not yet added\"\n            );\n\n            delete primitiveToAggregatorInfo[_primitives[i]];\n            delete primitiveToUnit[_primitives[i]];\n\n            emit PrimitiveRemoved(_primitives[i]);\n        }\n    }\n\n    /// @notice Removes stale primitives from the feed\n    /// @param _primitives The stale primitives to remove\n    /// @dev Callable by anybody\n    function removeStalePrimitives(address[] calldata _primitives) external {\n        require(_primitives.length > 0, \"removeStalePrimitives: _primitives cannot be empty\");\n\n        for (uint256 i; i < _primitives.length; i++) {\n            address aggregatorAddress = primitiveToAggregatorInfo[_primitives[i]].aggregator;\n            require(aggregatorAddress != address(0), \"removeStalePrimitives: Invalid primitive\");\n            require(rateIsStale(aggregatorAddress), \"removeStalePrimitives: Rate is not stale\");\n\n            delete primitiveToAggregatorInfo[_primitives[i]];\n            delete primitiveToUnit[_primitives[i]];\n\n            emit StalePrimitiveRemoved(_primitives[i]);\n        }\n    }\n\n    /// @notice Sets the `staleRateThreshold` variable\n    /// @param _nextStaleRateThreshold The next `staleRateThreshold` value\n    function setStaleRateThreshold(uint256 _nextStaleRateThreshold)\n        external\n        onlyFundDeployerOwner\n    {\n        uint256 prevStaleRateThreshold = staleRateThreshold;\n        require(\n            _nextStaleRateThreshold != prevStaleRateThreshold,\n            \"__setStaleRateThreshold: Value already set\"\n        );\n\n        staleRateThreshold = _nextStaleRateThreshold;\n\n        emit StaleRateThresholdSet(prevStaleRateThreshold, _nextStaleRateThreshold);\n    }\n\n    /// @notice Updates the aggregators for given primitives\n    /// @param _primitives The primitives to update\n    /// @param _aggregators The ordered aggregators corresponding to the list of _primitives\n    function updatePrimitives(address[] calldata _primitives, address[] calldata _aggregators)\n        external\n        onlyFundDeployerOwner\n    {\n        require(_primitives.length > 0, \"updatePrimitives: _primitives cannot be empty\");\n        require(\n            _primitives.length == _aggregators.length,\n            \"updatePrimitives: Unequal _primitives and _aggregators array lengths\"\n        );\n\n        for (uint256 i; i < _primitives.length; i++) {\n            address prevAggregator = primitiveToAggregatorInfo[_primitives[i]].aggregator;\n            require(prevAggregator != address(0), \"updatePrimitives: Primitive not yet added\");\n            require(_aggregators[i] != prevAggregator, \"updatePrimitives: Value already set\");\n\n            __validateAggregator(_aggregators[i]);\n\n            primitiveToAggregatorInfo[_primitives[i]].aggregator = _aggregators[i];\n\n            emit PrimitiveUpdated(_primitives[i], prevAggregator, _aggregators[i]);\n        }\n    }\n\n    /// @notice Checks whether the current rate is considered stale for the specified aggregator\n    /// @param _aggregator The Chainlink aggregator of which to check staleness\n    /// @return rateIsStale_ True if the rate is considered stale\n    function rateIsStale(address _aggregator) public view returns (bool rateIsStale_) {\n        return\n            IChainlinkAggregator(_aggregator).latestTimestamp() <\n            block.timestamp.sub(staleRateThreshold);\n    }\n\n    /// @dev Helper to add primitives to the feed\n    function __addPrimitives(\n        address[] memory _primitives,\n        address[] memory _aggregators,\n        RateAsset[] memory _rateAssets\n    ) private {\n        require(\n            _primitives.length == _aggregators.length,\n            \"__addPrimitives: Unequal _primitives and _aggregators array lengths\"\n        );\n        require(\n            _primitives.length == _rateAssets.length,\n            \"__addPrimitives: Unequal _primitives and _rateAssets array lengths\"\n        );\n\n        for (uint256 i = 0; i < _primitives.length; i++) {\n            require(\n                primitiveToAggregatorInfo[_primitives[i]].aggregator == address(0),\n                \"__addPrimitives: Value already set\"\n            );\n\n            __validateAggregator(_aggregators[i]);\n\n            primitiveToAggregatorInfo[_primitives[i]] = AggregatorInfo({\n                aggregator: _aggregators[i],\n                rateAsset: _rateAssets[i]\n            });\n\n            console.log(\"primitives: \", _primitives[i]);\n            // Store the amount that makes up 1 unit given the asset's decimals\n            uint256 unit = 10**uint256(ERC20(_primitives[i]).decimals());\n            primitiveToUnit[_primitives[i]] = unit;\n\n            emit PrimitiveAdded(_primitives[i], _aggregators[i], _rateAssets[i], unit);\n        }\n    }\n\n    /// @dev Helper to validate an aggregator by checking its return values for the expected interface\n    function __validateAggregator(address _aggregator) private view {\n        require(_aggregator != address(0), \"__validateAggregator: Empty _aggregator\");\n\n        require(\n            IChainlinkAggregator(_aggregator).latestAnswer() > 0,\n            \"__validateAggregator: No rate detected\"\n        );\n        require(!rateIsStale(_aggregator), \"__validateAggregator: Stale rate detected\");\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the aggregatorInfo variable value for a primitive\n    /// @param _primitive The primitive asset for which to get the aggregatorInfo value\n    /// @return aggregatorInfo_ The aggregatorInfo value\n    function getAggregatorInfoForPrimitive(address _primitive)\n        external\n        view\n        returns (AggregatorInfo memory aggregatorInfo_)\n    {\n        return primitiveToAggregatorInfo[_primitive];\n    }\n\n    /// @notice Gets the `ethUsdAggregator` variable value\n    /// @return ethUsdAggregator_ The `ethUsdAggregator` variable value\n    function getEthUsdAggregator() external view returns (address ethUsdAggregator_) {\n        return ethUsdAggregator;\n    }\n\n    /// @notice Gets the `staleRateThreshold` variable value\n    /// @return staleRateThreshold_ The `staleRateThreshold` variable value\n    function getStaleRateThreshold() external view returns (uint256 staleRateThreshold_) {\n        return staleRateThreshold;\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable value\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() external view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n\n    /// @notice Gets the rateAsset variable value for a primitive\n    /// @return rateAsset_ The rateAsset variable value\n    /// @dev This isn't strictly necessary as WETH_TOKEN will be undefined and thus\n    /// the RateAsset will be the 0-position of the enum (i.e. ETH), but it makes the\n    /// behavior more explicit\n    function getRateAssetForPrimitive(address _primitive)\n        public\n        view\n        returns (RateAsset rateAsset_)\n    {\n        if (_primitive == WETH_TOKEN) {\n            return RateAsset.ETH;\n        }\n\n        return primitiveToAggregatorInfo[_primitive].rateAsset;\n    }\n\n    /// @notice Gets the unit variable value for a primitive\n    /// @return unit_ The unit variable value\n    function getUnitForPrimitive(address _primitive) public view returns (uint256 unit_) {\n        if (_primitive == WETH_TOKEN) {\n            return ETH_UNIT;\n        }\n\n        return primitiveToUnit[_primitive];\n    }\n}\n"
    },
    "contracts/release/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IChainlinkAggregator Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IChainlinkAggregator {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IPrimitivePriceFeed Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for primitive price feeds\r\ninterface IPrimitivePriceFeed {\r\n    function calcCanonicalValue(\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external view returns (uint256, bool);\r\n\r\n    function calcLiveValue(\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external view returns (uint256, bool);\r\n\r\n    function isSupportedAsset(address) external view returns (bool);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/UniswapV2PoolPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../../../../interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../../../utils/MathHelpers.sol\";\r\nimport \"../../../value-interpreter/ValueInterpreter.sol\";\r\nimport \"../../primitives/IPrimitivePriceFeed.sol\";\r\nimport \"../../utils/UniswapV2PoolTokenValueCalculator.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title UniswapV2PoolPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price feed for Uniswap lending pool tokens\r\ncontract UniswapV2PoolPriceFeed is\r\n    IDerivativePriceFeed,\r\n    FundDeployerOwnerMixin,\r\n    MathHelpers,\r\n    UniswapV2PoolTokenValueCalculator\r\n{\r\n    event PoolTokenAdded(address indexed poolToken, address token0, address token1);\r\n\r\n    struct PoolTokenInfo {\r\n        address token0;\r\n        address token1;\r\n        uint8 token0Decimals;\r\n        uint8 token1Decimals;\r\n    }\r\n\r\n    uint256 private constant POOL_TOKEN_UNIT = 10**18;\r\n    address private immutable DERIVATIVE_PRICE_FEED;\r\n    address private immutable FACTORY;\r\n    address private immutable PRIMITIVE_PRICE_FEED;\r\n    address private immutable VALUE_INTERPRETER;\r\n\r\n    mapping(address => PoolTokenInfo) private poolTokenToInfo;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address _derivativePriceFeed,\r\n        address _primitivePriceFeed,\r\n        address _valueInterpreter,\r\n        address _factory,\r\n        address[] memory _poolTokens\r\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\r\n        DERIVATIVE_PRICE_FEED = _derivativePriceFeed;\r\n        FACTORY = _factory;\r\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\r\n        VALUE_INTERPRETER = _valueInterpreter;\r\n\r\n        __addPoolTokens(_poolTokens, _derivativePriceFeed, _primitivePriceFeed);\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        PoolTokenInfo memory poolTokenInfo = poolTokenToInfo[_derivative];\r\n\r\n        underlyings_ = new address[](2);\r\n        underlyings_[0] = poolTokenInfo.token0;\r\n        underlyings_[1] = poolTokenInfo.token1;\r\n\r\n        // Calculate the amounts underlying one unit of a pool token,\r\n        // taking into account the known, trusted rate between the two underlyings\r\n        (uint256 token0TrustedRateAmount, uint256 token1TrustedRateAmount) = __calcTrustedRate(\r\n            poolTokenInfo.token0,\r\n            poolTokenInfo.token1,\r\n            poolTokenInfo.token0Decimals,\r\n            poolTokenInfo.token1Decimals\r\n        );\r\n\r\n        (\r\n            uint256 token0DenormalizedRate,\r\n            uint256 token1DenormalizedRate\r\n        ) = __calcTrustedPoolTokenValue(\r\n            FACTORY,\r\n            _derivative,\r\n            token0TrustedRateAmount,\r\n            token1TrustedRateAmount\r\n        );\r\n\r\n        // Define normalized rates for each underlying\r\n        underlyingAmounts_ = new uint256[](2);\r\n        underlyingAmounts_[0] = _derivativeAmount.mul(token0DenormalizedRate).div(POOL_TOKEN_UNIT);\r\n        underlyingAmounts_[1] = _derivativeAmount.mul(token1DenormalizedRate).div(POOL_TOKEN_UNIT);\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return poolTokenToInfo[_asset].token0 != address(0);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Calculates the trusted rate of two assets based on our price feeds.\r\n    /// Uses the decimals-derived unit for whichever asset is used as the quote asset.\r\n    function __calcTrustedRate(\r\n        address _token0,\r\n        address _token1,\r\n        uint256 _token0Decimals,\r\n        uint256 _token1Decimals\r\n    ) private returns (uint256 token0RateAmount_, uint256 token1RateAmount_) {\r\n        bool rateIsValid;\r\n        // The quote asset of the value lookup must be a supported primitive asset,\r\n        // so we cycle through the tokens until reaching a primitive.\r\n        // If neither is a primitive, will revert at the ValueInterpreter\r\n        if (IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_token0)) {\r\n            token1RateAmount_ = 10**_token1Decimals;\r\n            (token0RateAmount_, rateIsValid) = ValueInterpreter(VALUE_INTERPRETER)\r\n                .calcCanonicalAssetValue(_token1, token1RateAmount_, _token0);\r\n        } else {\r\n            token0RateAmount_ = 10**_token0Decimals;\r\n            (token1RateAmount_, rateIsValid) = ValueInterpreter(VALUE_INTERPRETER)\r\n                .calcCanonicalAssetValue(_token0, token0RateAmount_, _token1);\r\n        }\r\n\r\n        require(rateIsValid, \"__calcTrustedRate: Invalid rate\");\r\n\r\n        return (token0RateAmount_, token1RateAmount_);\r\n    }\r\n\r\n    //////////////////////////\r\n    // POOL TOKENS REGISTRY //\r\n    //////////////////////////\r\n\r\n    /// @notice Adds Uniswap pool tokens to the price feed\r\n    /// @param _poolTokens Uniswap pool tokens to add\r\n    function addPoolTokens(address[] calldata _poolTokens) external onlyFundDeployerOwner {\r\n        require(_poolTokens.length > 0, \"addPoolTokens: Empty _poolTokens\");\r\n\r\n        __addPoolTokens(_poolTokens, DERIVATIVE_PRICE_FEED, PRIMITIVE_PRICE_FEED);\r\n    }\r\n\r\n    /// @dev Helper to add Uniswap pool tokens\r\n    function __addPoolTokens(\r\n        address[] memory _poolTokens,\r\n        address _derivativePriceFeed,\r\n        address _primitivePriceFeed\r\n    ) private {\r\n        for (uint256 i; i < _poolTokens.length; i++) {\r\n            require(_poolTokens[i] != address(0), \"__addPoolTokens: Empty poolToken\");\r\n            require(\r\n                poolTokenToInfo[_poolTokens[i]].token0 == address(0),\r\n                \"__addPoolTokens: Value already set\"\r\n            );\r\n\r\n            IUniswapV2Pair uniswapV2Pair = IUniswapV2Pair(_poolTokens[i]);\r\n            address token0 = uniswapV2Pair.token0();\r\n            address token1 = uniswapV2Pair.token1();\r\n\r\n            require(\r\n                __poolTokenIsSupportable(\r\n                    _derivativePriceFeed,\r\n                    _primitivePriceFeed,\r\n                    token0,\r\n                    token1\r\n                ),\r\n                \"__addPoolTokens: Unsupported pool token\"\r\n            );\r\n\r\n            poolTokenToInfo[_poolTokens[i]] = PoolTokenInfo({\r\n                token0: token0,\r\n                token1: token1,\r\n                token0Decimals: ERC20(token0).decimals(),\r\n                token1Decimals: ERC20(token1).decimals()\r\n            });\r\n\r\n            emit PoolTokenAdded(_poolTokens[i], token0, token1);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to determine if a pool token is supportable, based on whether price feeds are\r\n    /// available for its underlying feeds. At least one of the underlying tokens must be\r\n    /// a supported primitive asset, and the other must be a primitive or derivative.\r\n    function __poolTokenIsSupportable(\r\n        address _derivativePriceFeed,\r\n        address _primitivePriceFeed,\r\n        address _token0,\r\n        address _token1\r\n    ) private view returns (bool isSupportable_) {\r\n        IDerivativePriceFeed derivativePriceFeedContract = IDerivativePriceFeed(\r\n            _derivativePriceFeed\r\n        );\r\n        IPrimitivePriceFeed primitivePriceFeedContract = IPrimitivePriceFeed(_primitivePriceFeed);\r\n\r\n        if (primitivePriceFeedContract.isSupportedAsset(_token0)) {\r\n            if (\r\n                primitivePriceFeedContract.isSupportedAsset(_token1) ||\r\n                derivativePriceFeedContract.isSupportedAsset(_token1)\r\n            ) {\r\n                return true;\r\n            }\r\n        } else if (\r\n            derivativePriceFeedContract.isSupportedAsset(_token0) &&\r\n            primitivePriceFeedContract.isSupportedAsset(_token1)\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `DERIVATIVE_PRICE_FEED` variable value\r\n    /// @return derivativePriceFeed_ The `DERIVATIVE_PRICE_FEED` variable value\r\n    function getDerivativePriceFeed() external view returns (address derivativePriceFeed_) {\r\n        return DERIVATIVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `FACTORY` variable value\r\n    /// @return factory_ The `FACTORY` variable value\r\n    function getFactory() external view returns (address factory_) {\r\n        return FACTORY;\r\n    }\r\n\r\n    /// @notice Gets the `PoolTokenInfo` for a given pool token\r\n    /// @param _poolToken The pool token for which to get the `PoolTokenInfo`\r\n    /// @return poolTokenInfo_ The `PoolTokenInfo` value\r\n    function getPoolTokenInfo(address _poolToken)\r\n        external\r\n        view\r\n        returns (PoolTokenInfo memory poolTokenInfo_)\r\n    {\r\n        return poolTokenToInfo[_poolToken];\r\n    }\r\n\r\n    /// @notice Gets the underlyings for a given pool token\r\n    /// @param _poolToken The pool token for which to get its underlyings\r\n    /// @return token0_ The UniswapV2Pair.token0 value\r\n    /// @return token1_ The UniswapV2Pair.token1 value\r\n    function getPoolTokenUnderlyings(address _poolToken)\r\n        external\r\n        view\r\n        returns (address token0_, address token1_)\r\n    {\r\n        return (poolTokenToInfo[_poolToken].token0, poolTokenToInfo[_poolToken].token1);\r\n    }\r\n\r\n    /// @notice Gets the `PRIMITIVE_PRICE_FEED` variable value\r\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\r\n    function getPrimitivePriceFeed() external view returns (address primitivePriceFeed_) {\r\n        return PRIMITIVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `VALUE_INTERPRETER` variable value\r\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\r\n    function getValueInterpreter() external view returns (address valueInterpreter_) {\r\n        return VALUE_INTERPRETER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IUniswapV2Pair Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for our interactions with the Uniswap V2's Pair contract\r\ninterface IUniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        );\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/release/infrastructure/value-interpreter/ValueInterpreter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol\";\r\nimport \"../price-feeds/derivatives/IDerivativePriceFeed.sol\";\r\nimport \"../price-feeds/primitives/IPrimitivePriceFeed.sol\";\r\nimport \"./IValueInterpreter.sol\";\r\n\r\n/// @title ValueInterpreter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interprets price feeds to provide covert value between asset pairs\r\n/// @dev This contract contains several \"live\" value calculations, which for this release are simply\r\n/// aliases to their \"canonical\" value counterparts since the only primitive price feed (Chainlink)\r\n/// is immutable in this contract and only has one type of value. Including the \"live\" versions of\r\n/// functions only serves as a placeholder for infrastructural components and plugins (e.g., policies)\r\n/// to explicitly define the types of values that they should (and will) be using in a future release.\r\ncontract ValueInterpreter is IValueInterpreter {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable AGGREGATED_DERIVATIVE_PRICE_FEED;\r\n    address private immutable PRIMITIVE_PRICE_FEED;\r\n\r\n    constructor(address _primitivePriceFeed, address _aggregatedDerivativePriceFeed) public {\r\n        AGGREGATED_DERIVATIVE_PRICE_FEED = _aggregatedDerivativePriceFeed;\r\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice An alias of calcCanonicalAssetsTotalValue\r\n    function calcLiveAssetsTotalValue(\r\n        address[] calldata _baseAssets,\r\n        uint256[] calldata _amounts,\r\n        address _quoteAsset\r\n    ) external override returns (uint256 value_, bool isValid_) {\r\n        return calcCanonicalAssetsTotalValue(_baseAssets, _amounts, _quoteAsset);\r\n    }\r\n\r\n    /// @notice An alias of calcCanonicalAssetValue\r\n    function calcLiveAssetValue(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) external override returns (uint256 value_, bool isValid_) {\r\n        return calcCanonicalAssetValue(_baseAsset, _amount, _quoteAsset);\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Calculates the total value of given amounts of assets in a single quote asset\r\n    /// @param _baseAssets The assets to convert\r\n    /// @param _amounts The amounts of the _baseAssets to convert\r\n    /// @param _quoteAsset The asset to which to convert\r\n    /// @return value_ The sum value of _baseAssets, denominated in the _quoteAsset\r\n    /// @return isValid_ True if the price feed rates used to derive value are all valid\r\n    /// @dev Does not alter protocol state,\r\n    /// but not a view because calls to price feeds can potentially update third party state\r\n    function calcCanonicalAssetsTotalValue(\r\n        address[] memory _baseAssets,\r\n        uint256[] memory _amounts,\r\n        address _quoteAsset\r\n    ) public override returns (uint256 value_, bool isValid_) {\r\n        require(\r\n            _baseAssets.length == _amounts.length,\r\n            \"calcCanonicalAssetsTotalValue: Arrays unequal lengths\"\r\n        );\r\n        require(\r\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\r\n            \"calcCanonicalAssetsTotalValue: Unsupported _quoteAsset\"\r\n        );\r\n\r\n        isValid_ = true;\r\n        for (uint256 i; i < _baseAssets.length; i++) {\r\n            (uint256 assetValue, bool assetValueIsValid) = __calcAssetValue(\r\n                _baseAssets[i],\r\n                _amounts[i],\r\n                _quoteAsset\r\n            );\r\n            value_ = value_.add(assetValue);\r\n            if (!assetValueIsValid) {\r\n                isValid_ = false;\r\n            }\r\n        }\r\n\r\n        return (value_, isValid_);\r\n    }\r\n\r\n    /// @notice Calculates the value of a given amount of one asset in terms of another asset\r\n    /// @param _baseAsset The asset from which to convert\r\n    /// @param _amount The amount of the _baseAsset to convert\r\n    /// @param _quoteAsset The asset to which to convert\r\n    /// @return value_ The equivalent quantity in the _quoteAsset\r\n    /// @return isValid_ True if the price feed rates used to derive value are all valid\r\n    /// @dev Does not alter protocol state,\r\n    /// but not a view because calls to price feeds can potentially update third party state\r\n    function calcCanonicalAssetValue(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) public override returns (uint256 value_, bool isValid_) {\r\n        if (_baseAsset == _quoteAsset || _amount == 0) {\r\n            return (_amount, true);\r\n        }\r\n\r\n        require(\r\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\r\n            \"calcCanonicalAssetValue: Unsupported _quoteAsset\"\r\n        );\r\n\r\n        return __calcAssetValue(_baseAsset, _amount, _quoteAsset);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to differentially calculate an asset value\r\n    /// based on if it is a primitive or derivative asset.\r\n    function __calcAssetValue(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) private returns (uint256 value_, bool isValid_) {\r\n        if (_baseAsset == _quoteAsset || _amount == 0) {\r\n            return (_amount, true);\r\n        }\r\n\r\n        // Handle case that asset is a primitive\r\n        if (IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_baseAsset)) {\r\n            return\r\n                IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).calcCanonicalValue(\r\n                    _baseAsset,\r\n                    _amount,\r\n                    _quoteAsset\r\n                );\r\n        }\r\n\r\n        // Handle case that asset is a derivative\r\n        address derivativePriceFeed = IAggregatedDerivativePriceFeed(\r\n            AGGREGATED_DERIVATIVE_PRICE_FEED\r\n        )\r\n            .getPriceFeedForDerivative(_baseAsset);\r\n        if (derivativePriceFeed != address(0)) {\r\n            return __calcDerivativeValue(derivativePriceFeed, _baseAsset, _amount, _quoteAsset);\r\n        }\r\n\r\n        revert(\"__calcAssetValue: Unsupported _baseAsset\");\r\n    }\r\n\r\n    /// @dev Helper to calculate the value of a derivative in an arbitrary asset.\r\n    /// Handles multiple underlying assets (e.g., Uniswap and Balancer pool tokens).\r\n    /// Handles underlying assets that are also derivatives (e.g., a cDAI-ETH LP)\r\n    function __calcDerivativeValue(\r\n        address _derivativePriceFeed,\r\n        address _derivative,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) private returns (uint256 value_, bool isValid_) {\r\n        (address[] memory underlyings, uint256[] memory underlyingAmounts) = IDerivativePriceFeed(\r\n            _derivativePriceFeed\r\n        )\r\n            .calcUnderlyingValues(_derivative, _amount);\r\n\r\n        require(underlyings.length > 0, \"__calcDerivativeValue: No underlyings\");\r\n        require(\r\n            underlyings.length == underlyingAmounts.length,\r\n            \"__calcDerivativeValue: Arrays unequal lengths\"\r\n        );\r\n\r\n        // Let validity be negated if any of the underlying value calculations are invalid\r\n        isValid_ = true;\r\n        for (uint256 i = 0; i < underlyings.length; i++) {\r\n            (uint256 underlyingValue, bool underlyingValueIsValid) = __calcAssetValue(\r\n                underlyings[i],\r\n                underlyingAmounts[i],\r\n                _quoteAsset\r\n            );\r\n\r\n            if (!underlyingValueIsValid) {\r\n                isValid_ = false;\r\n            }\r\n            value_ = value_.add(underlyingValue);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `AGGREGATED_DERIVATIVE_PRICE_FEED` variable\r\n    /// @return aggregatedDerivativePriceFeed_ The `AGGREGATED_DERIVATIVE_PRICE_FEED` variable value\r\n    function getAggregatedDerivativePriceFeed()\r\n        external\r\n        view\r\n        returns (address aggregatedDerivativePriceFeed_)\r\n    {\r\n        return AGGREGATED_DERIVATIVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `PRIMITIVE_PRICE_FEED` variable\r\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\r\n    function getPrimitivePriceFeed() external view returns (address primitivePriceFeed_) {\r\n        return PRIMITIVE_PRICE_FEED;\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/utils/UniswapV2PoolTokenValueCalculator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../interfaces/IUniswapV2Factory.sol\";\r\nimport \"../../../interfaces/IUniswapV2Pair.sol\";\r\n\r\n/// @title UniswapV2PoolTokenValueCalculator Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Abstract contract for computing the value of Uniswap liquidity pool tokens\r\n/// @dev Unless otherwise noted, these functions are adapted to our needs and style guide from\r\n/// an un-merged Uniswap branch:\r\n/// https://github.com/Uniswap/uniswap-v2-periphery/blob/267ba44471f3357071a2fe2573fe4da42d5ad969/contracts/libraries/UniswapV2LiquidityMathLibrary.sol\r\nabstract contract UniswapV2PoolTokenValueCalculator {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant POOL_TOKEN_UNIT = 10**18;\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Given a Uniswap pool with token0 and token1 and their trusted rate,\r\n    /// returns the value of one pool token unit in terms of token0 and token1.\r\n    /// This is the only function used outside of this contract.\r\n    function __calcTrustedPoolTokenValue(\r\n        address _factory,\r\n        address _pair,\r\n        uint256 _token0TrustedRateAmount,\r\n        uint256 _token1TrustedRateAmount\r\n    ) internal view returns (uint256 token0Amount_, uint256 token1Amount_) {\r\n        (uint256 reserve0, uint256 reserve1) = __calcReservesAfterArbitrage(\r\n            _pair,\r\n            _token0TrustedRateAmount,\r\n            _token1TrustedRateAmount\r\n        );\r\n\r\n        return __calcPoolTokenValue(_factory, _pair, reserve0, reserve1);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Computes liquidity value given all the parameters of the pair\r\n    function __calcPoolTokenValue(\r\n        address _factory,\r\n        address _pair,\r\n        uint256 _reserve0,\r\n        uint256 _reserve1\r\n    ) private view returns (uint256 token0Amount_, uint256 token1Amount_) {\r\n        IUniswapV2Pair pairContract = IUniswapV2Pair(_pair);\r\n        uint256 totalSupply = pairContract.totalSupply();\r\n\r\n        if (IUniswapV2Factory(_factory).feeTo() != address(0)) {\r\n            uint256 kLast = pairContract.kLast();\r\n            if (kLast > 0) {\r\n                uint256 rootK = __uniswapSqrt(_reserve0.mul(_reserve1));\r\n                uint256 rootKLast = __uniswapSqrt(kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\r\n                    uint256 feeLiquidity = numerator.div(denominator);\r\n                    totalSupply = totalSupply.add(feeLiquidity);\r\n                }\r\n            }\r\n        }\r\n        return (\r\n            _reserve0.mul(POOL_TOKEN_UNIT).div(totalSupply),\r\n            _reserve1.mul(POOL_TOKEN_UNIT).div(totalSupply)\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates the direction and magnitude of the profit-maximizing trade\r\n    function __calcProfitMaximizingTrade(\r\n        uint256 _token0TrustedRateAmount,\r\n        uint256 _token1TrustedRateAmount,\r\n        uint256 _reserve0,\r\n        uint256 _reserve1\r\n    ) private pure returns (bool token0ToToken1_, uint256 amountIn_) {\r\n        token0ToToken1_ =\r\n            _reserve0.mul(_token1TrustedRateAmount).div(_reserve1) < _token0TrustedRateAmount;\r\n\r\n        uint256 leftSide;\r\n        uint256 rightSide;\r\n        if (token0ToToken1_) {\r\n            leftSide = __uniswapSqrt(\r\n                _reserve0.mul(_reserve1).mul(_token0TrustedRateAmount).mul(1000).div(\r\n                    _token1TrustedRateAmount.mul(997)\r\n                )\r\n            );\r\n            rightSide = _reserve0.mul(1000).div(997);\r\n        } else {\r\n            leftSide = __uniswapSqrt(\r\n                _reserve0.mul(_reserve1).mul(_token1TrustedRateAmount).mul(1000).div(\r\n                    _token0TrustedRateAmount.mul(997)\r\n                )\r\n            );\r\n            rightSide = _reserve1.mul(1000).div(997);\r\n        }\r\n\r\n        if (leftSide < rightSide) {\r\n            return (false, 0);\r\n        }\r\n\r\n        // Calculate the amount that must be sent to move the price to the profit-maximizing price\r\n        amountIn_ = leftSide.sub(rightSide);\r\n\r\n        return (token0ToToken1_, amountIn_);\r\n    }\r\n\r\n    /// @dev Calculates the pool reserves after an arbitrage moves the price to\r\n    /// the profit-maximizing rate, given an externally-observed trusted rate\r\n    /// between the two pooled assets\r\n    function __calcReservesAfterArbitrage(\r\n        address _pair,\r\n        uint256 _token0TrustedRateAmount,\r\n        uint256 _token1TrustedRateAmount\r\n    ) private view returns (uint256 reserve0_, uint256 reserve1_) {\r\n        (reserve0_, reserve1_, ) = IUniswapV2Pair(_pair).getReserves();\r\n\r\n        // Skip checking whether the reserve is 0, as this is extremely unlikely given how\r\n        // initial pool liquidity is locked, and since we maintain a list of registered pool tokens\r\n\r\n        // Calculate how much to swap to arb to the trusted price\r\n        (bool token0ToToken1, uint256 amountIn) = __calcProfitMaximizingTrade(\r\n            _token0TrustedRateAmount,\r\n            _token1TrustedRateAmount,\r\n            reserve0_,\r\n            reserve1_\r\n        );\r\n        if (amountIn == 0) {\r\n            return (reserve0_, reserve1_);\r\n        }\r\n\r\n        // Adjust the reserves to account for the arb trade to the trusted price\r\n        if (token0ToToken1) {\r\n            uint256 amountOut = __uniswapV2GetAmountOut(amountIn, reserve0_, reserve1_);\r\n            reserve0_ = reserve0_.add(amountIn);\r\n            reserve1_ = reserve1_.sub(amountOut);\r\n        } else {\r\n            uint256 amountOut = __uniswapV2GetAmountOut(amountIn, reserve1_, reserve0_);\r\n            reserve1_ = reserve1_.add(amountIn);\r\n            reserve0_ = reserve0_.sub(amountOut);\r\n        }\r\n\r\n        return (reserve0_, reserve1_);\r\n    }\r\n\r\n    /// @dev Uniswap square root function. See:\r\n    /// https://github.com/Uniswap/uniswap-lib/blob/6ddfedd5716ba85b905bf34d7f1f3c659101a1bc/contracts/libraries/Babylonian.sol\r\n    function __uniswapSqrt(uint256 _y) private pure returns (uint256 z_) {\r\n        if (_y > 3) {\r\n            z_ = _y;\r\n            uint256 x = _y / 2 + 1;\r\n            while (x < z_) {\r\n                z_ = x;\r\n                x = (_y / x + x) / 2;\r\n            }\r\n        } else if (_y != 0) {\r\n            z_ = 1;\r\n        }\r\n        // else z_ = 0\r\n\r\n        return z_;\r\n    }\r\n\r\n    /// @dev Simplified version of UniswapV2Library's getAmountOut() function. See:\r\n    /// https://github.com/Uniswap/uniswap-v2-periphery/blob/87edfdcaf49ccc52591502993db4c8c08ea9eec0/contracts/libraries/UniswapV2Library.sol#L42-L50\r\n    function __uniswapV2GetAmountOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut\r\n    ) private pure returns (uint256 amountOut_) {\r\n        uint256 amountInWithFee = _amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\r\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\r\n\r\n        return numerator.div(denominator);\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/IDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IDerivativePriceFeed Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Simple interface for derivative price source oracle implementations\r\ninterface IDerivativePriceFeed {\r\n    function calcUnderlyingValues(address, uint256)\r\n        external\r\n        returns (address[] memory, uint256[] memory);\r\n\r\n    function isSupportedAsset(address) external view returns (bool);\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IDerivativePriceFeed.sol\";\r\n\r\n/// @title IDerivativePriceFeed Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAggregatedDerivativePriceFeed is IDerivativePriceFeed {\r\n    function getPriceFeedForDerivative(address) external view returns (address);\r\n}\r\n"
    },
    "contracts/release/infrastructure/value-interpreter/IValueInterpreter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IValueInterpreter interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for ValueInterpreter\r\ninterface IValueInterpreter {\r\n    function calcCanonicalAssetValue(\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external returns (uint256, bool);\r\n\r\n    function calcCanonicalAssetsTotalValue(\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        address\r\n    ) external returns (uint256, bool);\r\n\r\n    function calcLiveAssetValue(\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external returns (uint256, bool);\r\n\r\n    function calcLiveAssetsTotalValue(\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        address\r\n    ) external returns (uint256, bool);\r\n}\r\n"
    },
    "contracts/release/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IUniswapV2Factory Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for our interactions with the Uniswap V2's Factory contract\r\ninterface IUniswapV2Factory {\r\n    function feeTo() external view returns (address);\r\n\r\n    function getPair(address, address) external view returns (address);\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/WdgldPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../interfaces/IChainlinkAggregator.sol\";\r\nimport \"../../../../utils/MakerDaoMath.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title WdgldPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for WDGLD <https://dgld.ch/>\r\ncontract WdgldPriceFeed is IDerivativePriceFeed, MakerDaoMath {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable XAU_AGGREGATOR;\r\n    address private immutable ETH_AGGREGATOR;\r\n\r\n    address private immutable WDGLD;\r\n    address private immutable WETH;\r\n\r\n    // GTR_CONSTANT aggregates all the invariants in the GTR formula to save gas\r\n    uint256 private constant GTR_CONSTANT = 999990821653213975346065101;\r\n    uint256 private constant GTR_PRECISION = 10**27;\r\n    uint256 private constant WDGLD_GENESIS_TIMESTAMP = 1568700000;\r\n\r\n    constructor(\r\n        address _wdgld,\r\n        address _weth,\r\n        address _ethAggregator,\r\n        address _xauAggregator\r\n    ) public {\r\n        WDGLD = _wdgld;\r\n        WETH = _weth;\r\n        ETH_AGGREGATOR = _ethAggregator;\r\n        XAU_AGGREGATOR = _xauAggregator;\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        require(isSupportedAsset(_derivative), \"calcUnderlyingValues: Only WDGLD is supported\");\r\n\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = WETH;\r\n        underlyingAmounts_ = new uint256[](1);\r\n\r\n        // Get price rates from xau and eth aggregators\r\n        int256 xauToUsdRate = IChainlinkAggregator(XAU_AGGREGATOR).latestAnswer();\r\n        int256 ethToUsdRate = IChainlinkAggregator(ETH_AGGREGATOR).latestAnswer();\r\n        require(xauToUsdRate > 0 && ethToUsdRate > 0, \"calcUnderlyingValues: rate invalid\");\r\n\r\n        uint256 wdgldToXauRate = calcWdgldToXauRate();\r\n\r\n        // 10**17 is a combination of ETH_UNIT / WDGLD_UNIT * GTR_PRECISION\r\n        underlyingAmounts_[0] = _derivativeAmount\r\n            .mul(wdgldToXauRate)\r\n            .mul(uint256(xauToUsdRate))\r\n            .div(uint256(ethToUsdRate))\r\n            .div(10**17);\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Calculates the rate of WDGLD to XAU.\r\n    /// @return wdgldToXauRate_ The current rate of WDGLD to XAU\r\n    /// @dev Full formula available <https://dgld.ch/assets/documents/dgld-whitepaper.pdf>\r\n    function calcWdgldToXauRate() public view returns (uint256 wdgldToXauRate_) {\r\n        return\r\n            __rpow(\r\n                GTR_CONSTANT,\r\n                ((block.timestamp).sub(WDGLD_GENESIS_TIMESTAMP)).div(28800), // 60 * 60 * 8 (8 hour periods)\r\n                GTR_PRECISION\r\n            )\r\n                .div(10);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by this price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if supported\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return _asset == WDGLD;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `ETH_AGGREGATOR` address\r\n    /// @return ethAggregatorAddress_ The `ETH_AGGREGATOR` address\r\n    function getEthAggregator() external view returns (address ethAggregatorAddress_) {\r\n        return ETH_AGGREGATOR;\r\n    }\r\n\r\n    /// @notice Gets the `WDGLD` token address\r\n    /// @return wdgld_ The `WDGLD` token address\r\n    function getWdgld() external view returns (address wdgld_) {\r\n        return WDGLD;\r\n    }\r\n\r\n    /// @notice Gets the `WETH` token address\r\n    /// @return weth_ The `WETH` token address\r\n    function getWeth() external view returns (address weth_) {\r\n        return WETH;\r\n    }\r\n\r\n    /// @notice Gets the `XAU_AGGREGATOR` address\r\n    /// @return xauAggregatorAddress_ The `XAU_AGGREGATOR` address\r\n    function getXauAggregator() external view returns (address xauAggregatorAddress_) {\r\n        return XAU_AGGREGATOR;\r\n    }\r\n}\r\n"
    },
    "contracts/release/utils/MakerDaoMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title MakerDaoMath Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Helper functions for math operations adapted from MakerDao contracts\r\nabstract contract MakerDaoMath {\r\n    /// @dev Performs scaled, fixed-point exponentiation.\r\n    /// Verbatim code, adapted to our style guide for variable naming only, see:\r\n    /// https://github.com/makerdao/dss/blob/master/src/pot.sol#L83-L105\r\n    // prettier-ignore\r\n    function __rpow(uint256 _x, uint256 _n, uint256 _base) internal pure returns (uint256 z_) {\r\n        assembly {\r\n            switch _x case 0 {switch _n case 0 {z_ := _base} default {z_ := 0}}\r\n            default {\r\n                switch mod(_n, 2) case 0 { z_ := _base } default { z_ := _x }\r\n                let half := div(_base, 2)\r\n                for { _n := div(_n, 2) } _n { _n := div(_n,2) } {\r\n                    let xx := mul(_x, _x)\r\n                    if iszero(eq(div(xx, _x), _x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    _x := div(xxRound, _base)\r\n                    if mod(_n,2) {\r\n                        let zx := mul(z_, _x)\r\n                        if and(iszero(iszero(_x)), iszero(eq(div(zx, _x), z_))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z_ := div(zxRound, _base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return z_;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/ManagementFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../core/fund/vault/VaultLib.sol\";\r\nimport \"../../../utils/MakerDaoMath.sol\";\r\nimport \"./utils/FeeBase.sol\";\r\n\r\n/// @title ManagementFee Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A management fee with a configurable annual rate\r\ncontract ManagementFee is FeeBase, MakerDaoMath {\r\n    using SafeMath for uint256;\r\n\r\n    event ActivatedForMigratedFund(address indexed comptrollerProxy);\r\n\r\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 scaledPerSecondRate);\r\n\r\n    event Settled(\r\n        address indexed comptrollerProxy,\r\n        uint256 sharesQuantity,\r\n        uint256 secondsSinceSettlement\r\n    );\r\n\r\n    struct FeeInfo {\r\n        uint256 scaledPerSecondRate;\r\n        uint256 lastSettled;\r\n    }\r\n\r\n    uint256 private constant RATE_SCALE_BASE = 10**27;\r\n\r\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\r\n\r\n    constructor(address _feeManager) public FeeBase(_feeManager) {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Activates the fee for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _vaultProxy The VaultProxy of the fund\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy)\r\n        external\r\n        override\r\n        onlyFeeManager\r\n    {\r\n        // It is only necessary to set `lastSettled` for a migrated fund\r\n        if (VaultLib(_vaultProxy).totalSupply() > 0) {\r\n            comptrollerProxyToFeeInfo[_comptrollerProxy].lastSettled = block.timestamp;\r\n\r\n            emit ActivatedForMigratedFund(_comptrollerProxy);\r\n        }\r\n    }\r\n\r\n    /// @notice Add the initial fee settings for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\r\n        external\r\n        override\r\n        onlyFeeManager\r\n    {\r\n        uint256 scaledPerSecondRate = abi.decode(_settingsData, (uint256));\r\n        require(\r\n            scaledPerSecondRate > 0,\r\n            \"addFundSettings: scaledPerSecondRate must be greater than 0\"\r\n        );\r\n\r\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\r\n            scaledPerSecondRate: scaledPerSecondRate,\r\n            lastSettled: 0\r\n        });\r\n\r\n        emit FundSettingsAdded(_comptrollerProxy, scaledPerSecondRate);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a fee\r\n    /// @return identifier_ The identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"MANAGEMENT\";\r\n    }\r\n\r\n    /// @notice Gets the hooks that are implemented by the fee\r\n    /// @return implementedHooksForSettle_ The hooks during which settle() is implemented\r\n    /// @return implementedHooksForUpdate_ The hooks during which update() is implemented\r\n    /// @return usesGavOnSettle_ True if GAV is used during the settle() implementation\r\n    /// @return usesGavOnUpdate_ True if GAV is used during the update() implementation\r\n    /// @dev Used only during fee registration\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\r\n            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\r\n            bool usesGavOnSettle_,\r\n            bool usesGavOnUpdate_\r\n        )\r\n    {\r\n        implementedHooksForSettle_ = new IFeeManager.FeeHook[](3);\r\n        implementedHooksForSettle_[0] = IFeeManager.FeeHook.Continuous;\r\n        implementedHooksForSettle_[1] = IFeeManager.FeeHook.BuySharesSetup;\r\n        implementedHooksForSettle_[2] = IFeeManager.FeeHook.PreRedeemShares;\r\n\r\n        return (implementedHooksForSettle_, new IFeeManager.FeeHook[](0), false, false);\r\n    }\r\n\r\n    /// @notice Settle the fee and calculate shares due\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _vaultProxy The VaultProxy of the fund\r\n    /// @return settlementType_ The type of settlement\r\n    /// @return (unused) The payer of shares due\r\n    /// @return sharesDue_ The amount of shares due\r\n    function settle(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook,\r\n        bytes calldata,\r\n        uint256\r\n    )\r\n        external\r\n        override\r\n        onlyFeeManager\r\n        returns (\r\n            IFeeManager.SettlementType settlementType_,\r\n            address,\r\n            uint256 sharesDue_\r\n        )\r\n    {\r\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n\r\n        // If this fee was settled in the current block, we can return early\r\n        uint256 secondsSinceSettlement = block.timestamp.sub(feeInfo.lastSettled);\r\n        if (secondsSinceSettlement == 0) {\r\n            return (IFeeManager.SettlementType.None, address(0), 0);\r\n        }\r\n\r\n        // If there are shares issued for the fund, calculate the shares due\r\n        VaultLib vaultProxyContract = VaultLib(_vaultProxy);\r\n        uint256 sharesSupply = vaultProxyContract.totalSupply();\r\n        if (sharesSupply > 0) {\r\n            // This assumes that all shares in the VaultProxy are shares outstanding,\r\n            // which is fine for this release. Even if they are not, they are still shares that\r\n            // are only claimable by the fund owner.\r\n            uint256 netSharesSupply = sharesSupply.sub(vaultProxyContract.balanceOf(_vaultProxy));\r\n            if (netSharesSupply > 0) {\r\n                sharesDue_ = netSharesSupply\r\n                    .mul(\r\n                    __rpow(feeInfo.scaledPerSecondRate, secondsSinceSettlement, RATE_SCALE_BASE)\r\n                        .sub(RATE_SCALE_BASE)\r\n                )\r\n                    .div(RATE_SCALE_BASE);\r\n            }\r\n        }\r\n\r\n        // Must settle even when no shares are due, for the case that settlement is being\r\n        // done when there are no shares in the fund (i.e. at the first investment, or at the\r\n        // first investment after all shares have been redeemed)\r\n        comptrollerProxyToFeeInfo[_comptrollerProxy].lastSettled = block.timestamp;\r\n        emit Settled(_comptrollerProxy, sharesDue_, secondsSinceSettlement);\r\n\r\n        if (sharesDue_ == 0) {\r\n            return (IFeeManager.SettlementType.None, address(0), 0);\r\n        }\r\n\r\n        return (IFeeManager.SettlementType.Mint, address(0), sharesDue_);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the feeInfo for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy contract of the fund\r\n    /// @return feeInfo_ The feeInfo\r\n    function getFeeInfoForFund(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (FeeInfo memory feeInfo_)\r\n    {\r\n        return comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n    }\r\n}\r\n"
    },
    "contracts/release/core/fund/vault/VaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../persistent/dispatcher/IDispatcher.sol\";\r\nimport \"../../../../persistent/vault/VaultLibBase1.sol\";\r\nimport \"./IVault.sol\";\r\n\r\n/// @title VaultLib Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice The per-release proxiable library contract for VaultProxy\r\n/// @dev The difference in terminology between \"asset\" and \"trackedAsset\" is intentional.\r\n/// A fund might actually have asset balances of un-tracked assets,\r\n/// but only tracked assets are used in gav calculations.\r\n/// Note that this contract inherits VaultLibSafeMath (a verbatim Open Zeppelin SafeMath copy)\r\n/// from SharesTokenBase via VaultLibBase1\r\ncontract VaultLib is VaultLibBase1, IVault {\r\n    using SafeERC20 for ERC20;\r\n\r\n    // Before updating TRACKED_ASSETS_LIMIT in the future, it is important to consider:\r\n    // 1. The highest tracked assets limit ever allowed in the protocol\r\n    // 2. That the next value will need to be respected by all future releases\r\n    uint256 private constant TRACKED_ASSETS_LIMIT = 20;\r\n\r\n    modifier onlyAccessor() {\r\n        require(msg.sender == accessor, \"Only the designated accessor can make this call\");\r\n        _;\r\n    }\r\n\r\n    /////////////\r\n    // GENERAL //\r\n    /////////////\r\n\r\n    /// @notice Sets the account that is allowed to migrate a fund to new releases\r\n    /// @param _nextMigrator The account to set as the allowed migrator\r\n    /// @dev Set to address(0) to remove the migrator.\r\n    function setMigrator(address _nextMigrator) external {\r\n        require(msg.sender == owner, \"setMigrator: Only the owner can call this function\");\r\n        address prevMigrator = migrator;\r\n        require(_nextMigrator != prevMigrator, \"setMigrator: Value already set\");\r\n\r\n        migrator = _nextMigrator;\r\n\r\n        emit MigratorSet(prevMigrator, _nextMigrator);\r\n    }\r\n\r\n    ///////////\r\n    // VAULT //\r\n    ///////////\r\n\r\n    /// @notice Adds a tracked asset to the fund\r\n    /// @param _asset The asset to add\r\n    /// @dev Allows addition of already tracked assets to fail silently.\r\n    function addTrackedAsset(address _asset) external override onlyAccessor {\r\n        if (!isTrackedAsset(_asset)) {\r\n            require(\r\n                trackedAssets.length < TRACKED_ASSETS_LIMIT,\r\n                \"addTrackedAsset: Limit exceeded\"\r\n            );\r\n\r\n            assetToIsTracked[_asset] = true;\r\n            trackedAssets.push(_asset);\r\n\r\n            emit TrackedAssetAdded(_asset);\r\n        }\r\n    }\r\n\r\n    /// @notice Grants an allowance to a spender to use the fund's asset\r\n    /// @param _asset The asset for which to grant an allowance\r\n    /// @param _target The spender of the allowance\r\n    /// @param _amount The amount of the allowance\r\n    function approveAssetSpender(\r\n        address _asset,\r\n        address _target,\r\n        uint256 _amount\r\n    ) external override onlyAccessor {\r\n        ERC20 assetContract = ERC20(_asset);\r\n        if (assetContract.balanceOf(_target) > 0) {\r\n            assetContract.safeApprove(_target, 0);\r\n        }\r\n        assetContract.safeApprove(_target, _amount);\r\n    }\r\n\r\n    /// @notice Makes an arbitrary call with this contract as the sender\r\n    /// @param _contract The contract to call\r\n    /// @param _callData The call data for the call\r\n    function callOnContract(address _contract, bytes calldata _callData)\r\n        external\r\n        override\r\n        onlyAccessor\r\n    {\r\n        (bool success, bytes memory returnData) = _contract.call(_callData);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    /// @notice Removes a tracked asset from the fund\r\n    /// @param _asset The asset to remove\r\n    function removeTrackedAsset(address _asset) external override onlyAccessor {\r\n        __removeTrackedAsset(_asset);\r\n    }\r\n\r\n    /// @notice Withdraws an asset from the VaultProxy to a given account\r\n    /// @param _asset The asset to withdraw\r\n    /// @param _target The account to which to withdraw the asset\r\n    /// @param _amount The amount of asset to withdraw\r\n    function withdrawAssetTo(\r\n        address _asset,\r\n        address _target,\r\n        uint256 _amount\r\n    ) external override onlyAccessor {\r\n        ERC20(_asset).safeTransfer(_target, _amount);\r\n\r\n        emit AssetWithdrawn(_asset, _target, _amount);\r\n    }\r\n\r\n    /// @dev Helper to the get the Vault's balance of a given asset\r\n    function __getAssetBalance(address _asset) private view returns (uint256 balance_) {\r\n        return ERC20(_asset).balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Helper to remove an asset from a fund's tracked assets.\r\n    /// Allows removal of non-tracked asset to fail silently.\r\n    function __removeTrackedAsset(address _asset) private {\r\n        if (isTrackedAsset(_asset)) {\r\n            assetToIsTracked[_asset] = false;\r\n\r\n            uint256 trackedAssetsCount = trackedAssets.length;\r\n            for (uint256 i = 0; i < trackedAssetsCount; i++) {\r\n                if (trackedAssets[i] == _asset) {\r\n                    if (i < trackedAssetsCount - 1) {\r\n                        trackedAssets[i] = trackedAssets[trackedAssetsCount - 1];\r\n                    }\r\n                    trackedAssets.pop();\r\n                    break;\r\n                }\r\n            }\r\n\r\n            emit TrackedAssetRemoved(_asset);\r\n        }\r\n    }\r\n\r\n    ////////////\r\n    // SHARES //\r\n    ////////////\r\n\r\n    /// @notice Burns fund shares from a particular account\r\n    /// @param _target The account for which to burn shares\r\n    /// @param _amount The amount of shares to burn\r\n    function burnShares(address _target, uint256 _amount) external override onlyAccessor {\r\n        __burn(_target, _amount);\r\n    }\r\n\r\n    /// @notice Mints fund shares to a particular account\r\n    /// @param _target The account for which to burn shares\r\n    /// @param _amount The amount of shares to mint\r\n    function mintShares(address _target, uint256 _amount) external override onlyAccessor {\r\n        __mint(_target, _amount);\r\n    }\r\n\r\n    /// @notice Transfers fund shares from one account to another\r\n    /// @param _from The account from which to transfer shares\r\n    /// @param _to The account to which to transfer shares\r\n    /// @param _amount The amount of shares to transfer\r\n    function transferShares(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override onlyAccessor {\r\n        __transfer(_from, _to, _amount);\r\n    }\r\n\r\n    // ERC20 overrides\r\n\r\n    /// @dev Disallows the standard ERC20 approve() function\r\n    function approve(address, uint256) public override returns (bool) {\r\n        revert(\"Unimplemented\");\r\n    }\r\n\r\n    /// @notice Gets the `symbol` value of the shares token\r\n    /// @return symbol_ The `symbol` value\r\n    /// @dev Defers the shares symbol value to the Dispatcher contract\r\n    function symbol() public view override returns (string memory symbol_) {\r\n        return IDispatcher(creator).getSharesTokenSymbol();\r\n    }\r\n\r\n    /// @dev Disallows the standard ERC20 transfer() function\r\n    function transfer(address, uint256) public override returns (bool) {\r\n        revert(\"Unimplemented\");\r\n    }\r\n\r\n    /// @dev Disallows the standard ERC20 transferFrom() function\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public override returns (bool) {\r\n        revert(\"Unimplemented\");\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `accessor` variable\r\n    /// @return accessor_ The `accessor` variable value\r\n    function getAccessor() external view override returns (address accessor_) {\r\n        return accessor;\r\n    }\r\n\r\n    /// @notice Gets the `creator` variable\r\n    /// @return creator_ The `creator` variable value\r\n    function getCreator() external view returns (address creator_) {\r\n        return creator;\r\n    }\r\n\r\n    /// @notice Gets the `migrator` variable\r\n    /// @return migrator_ The `migrator` variable value\r\n    function getMigrator() external view returns (address migrator_) {\r\n        return migrator;\r\n    }\r\n\r\n    /// @notice Gets the `owner` variable\r\n    /// @return owner_ The `owner` variable value\r\n    function getOwner() external view override returns (address owner_) {\r\n        return owner;\r\n    }\r\n\r\n    /// @notice Gets the `trackedAssets` variable\r\n    /// @return trackedAssets_ The `trackedAssets` variable value\r\n    function getTrackedAssets() external view override returns (address[] memory trackedAssets_) {\r\n        return trackedAssets;\r\n    }\r\n\r\n    /// @notice Check whether an address is a tracked asset of the fund\r\n    /// @param _asset The address to check\r\n    /// @return isTrackedAsset_ True if the address is a tracked asset of the fund\r\n    function isTrackedAsset(address _asset) public view override returns (bool isTrackedAsset_) {\r\n        return assetToIsTracked[_asset];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/FeeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../IFee.sol\";\r\n\r\n/// @title FeeBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Abstract base contract for all fees\r\nabstract contract FeeBase is IFee {\r\n    address internal immutable FEE_MANAGER;\r\n\r\n    modifier onlyFeeManager() {\r\n        require(msg.sender == FEE_MANAGER, \"Only the FeeManger can make this call\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _feeManager) public {\r\n        FEE_MANAGER = _feeManager;\r\n    }\r\n\r\n    /// @notice Allows Fee to run logic during fund activation\r\n    /// @dev Unimplemented by default, may be overrode.\r\n    function activateForFund(address, address) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Runs payout logic for a fee that utilizes shares outstanding as its settlement type\r\n    /// @dev Returns false by default, can be overridden by fee\r\n    function payout(address, address) external virtual override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @notice Update fee state after all settlement has occurred during a given fee hook\r\n    /// @dev Unimplemented by default, can be overridden by fee\r\n    function update(\r\n        address,\r\n        address,\r\n        IFeeManager.FeeHook,\r\n        bytes calldata,\r\n        uint256\r\n    ) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Helper to parse settlement arguments from encoded data for PreBuyShares fee hook\r\n    function __decodePreBuySharesSettlementData(bytes memory _settlementData)\r\n        internal\r\n        pure\r\n        returns (\r\n            address buyer_,\r\n            uint256 investmentAmount_,\r\n            uint256 minSharesQuantity_\r\n        )\r\n    {\r\n        return abi.decode(_settlementData, (address, uint256, uint256));\r\n    }\r\n\r\n    /// @notice Helper to parse settlement arguments from encoded data for PreRedeemShares fee hook\r\n    function __decodePreRedeemSharesSettlementData(bytes memory _settlementData)\r\n        internal\r\n        pure\r\n        returns (address redeemer_, uint256 sharesQuantity_)\r\n    {\r\n        return abi.decode(_settlementData, (address, uint256));\r\n    }\r\n\r\n    /// @notice Helper to parse settlement arguments from encoded data for PostBuyShares fee hook\r\n    function __decodePostBuySharesSettlementData(bytes memory _settlementData)\r\n        internal\r\n        pure\r\n        returns (\r\n            address buyer_,\r\n            uint256 investmentAmount_,\r\n            uint256 sharesBought_\r\n        )\r\n    {\r\n        return abi.decode(_settlementData, (address, uint256, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `FEE_MANAGER` variable\r\n    /// @return feeManager_ The `FEE_MANAGER` variable value\r\n    function getFeeManager() external view returns (address feeManager_) {\r\n        return FEE_MANAGER;\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IDispatcher Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IDispatcher {\r\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\r\n\r\n    function claimOwnership() external;\r\n\r\n    function deployVaultProxy(\r\n        address _vaultLib,\r\n        address _owner,\r\n        address _vaultAccessor,\r\n        string calldata _fundName\r\n    ) external returns (address vaultProxy_);\r\n\r\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\r\n\r\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\r\n\r\n    function getFundDeployerForVaultProxy(address _vaultProxy)\r\n        external\r\n        view\r\n        returns (address fundDeployer_);\r\n\r\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\r\n        external\r\n        view\r\n        returns (\r\n            address nextFundDeployer_,\r\n            address nextVaultAccessor_,\r\n            address nextVaultLib_,\r\n            uint256 executableTimestamp_\r\n        );\r\n\r\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\r\n\r\n    function getNominatedOwner() external view returns (address nominatedOwner_);\r\n\r\n    function getOwner() external view returns (address owner_);\r\n\r\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\r\n\r\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        returns (uint256 secondsRemaining_);\r\n\r\n    function hasExecutableMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        returns (bool hasExecutableRequest_);\r\n\r\n    function hasMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        returns (bool hasMigrationRequest_);\r\n\r\n    function removeNominatedOwner() external;\r\n\r\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\r\n\r\n    function setMigrationTimelock(uint256 _nextTimelock) external;\r\n\r\n    function setNominatedOwner(address _nextNominatedOwner) external;\r\n\r\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\r\n\r\n    function signalMigration(\r\n        address _vaultProxy,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib,\r\n        bool _bypassFailure\r\n    ) external;\r\n}\r\n"
    },
    "contracts/persistent/vault/VaultLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./VaultLibBaseCore.sol\";\r\n\r\n/// @title VaultLibBase1 Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice The first implementation of VaultLibBaseCore, with additional events and storage\r\n/// @dev All subsequent implementations should inherit the previous implementation,\r\n/// e.g., `VaultLibBase2 is VaultLibBase1`\r\n/// DO NOT EDIT CONTRACT.\r\nabstract contract VaultLibBase1 is VaultLibBaseCore {\r\n    event AssetWithdrawn(address indexed asset, address indexed target, uint256 amount);\r\n\r\n    event TrackedAssetAdded(address asset);\r\n\r\n    event TrackedAssetRemoved(address asset);\r\n\r\n    address[] internal trackedAssets;\r\n    mapping(address => bool) internal assetToIsTracked;\r\n}\r\n"
    },
    "contracts/release/core/fund/vault/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../persistent/utils/IMigratableVault.sol\";\r\n\r\n/// @title IVault Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IVault is IMigratableVault {\r\n    function addTrackedAsset(address) external;\r\n\r\n    function approveAssetSpender(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n\r\n    function burnShares(address, uint256) external;\r\n\r\n    function callOnContract(address, bytes calldata) external;\r\n\r\n    function getAccessor() external view returns (address);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function getTrackedAssets() external view returns (address[] memory);\r\n\r\n    function isTrackedAsset(address) external view returns (bool);\r\n\r\n    function mintShares(address, uint256) external;\r\n\r\n    function removeTrackedAsset(address) external;\r\n\r\n    function transferShares(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n\r\n    function withdrawAssetTo(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n}\r\n"
    },
    "contracts/persistent/vault/VaultLibBaseCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/IMigratableVault.sol\";\r\nimport \"./utils/ProxiableVaultLib.sol\";\r\nimport \"./utils/SharesTokenBase.sol\";\r\n\r\n/// @title VaultLibBaseCore Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A persistent contract containing all required storage variables and\r\n/// required functions for a VaultLib implementation\r\n/// @dev DO NOT EDIT CONTRACT. If new events or storage are necessary, they should be added to\r\n/// a numbered VaultLibBaseXXX that inherits the previous base. See VaultLibBase1.\r\nabstract contract VaultLibBaseCore is IMigratableVault, ProxiableVaultLib, SharesTokenBase {\r\n    event AccessorSet(address prevAccessor, address nextAccessor);\r\n\r\n    event MigratorSet(address prevMigrator, address nextMigrator);\r\n\r\n    event OwnerSet(address prevOwner, address nextOwner);\r\n\r\n    event VaultLibSet(address prevVaultLib, address nextVaultLib);\r\n\r\n    address internal accessor;\r\n    address internal creator;\r\n    address internal migrator;\r\n    address internal owner;\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Initializes the VaultProxy with core configuration\r\n    /// @param _owner The address to set as the fund owner\r\n    /// @param _accessor The address to set as the permissioned accessor of the VaultLib\r\n    /// @param _fundName The name of the fund\r\n    /// @dev Serves as a per-proxy pseudo-constructor\r\n    function init(\r\n        address _owner,\r\n        address _accessor,\r\n        string calldata _fundName\r\n    ) external override {\r\n        require(creator == address(0), \"init: Proxy already initialized\");\r\n        creator = msg.sender;\r\n        sharesName = _fundName;\r\n\r\n        __setAccessor(_accessor);\r\n        __setOwner(_owner);\r\n\r\n        emit VaultLibSet(address(0), getVaultLib());\r\n    }\r\n\r\n    /// @notice Sets the permissioned accessor of the VaultLib\r\n    /// @param _nextAccessor The address to set as the permissioned accessor of the VaultLib\r\n    function setAccessor(address _nextAccessor) external override {\r\n        require(msg.sender == creator, \"setAccessor: Only callable by the contract creator\");\r\n\r\n        __setAccessor(_nextAccessor);\r\n    }\r\n\r\n    /// @notice Sets the VaultLib target for the VaultProxy\r\n    /// @param _nextVaultLib The address to set as the VaultLib\r\n    /// @dev This function is absolutely critical. __updateCodeAddress() validates that the\r\n    /// target is a valid Proxiable contract instance.\r\n    /// Does not block _nextVaultLib from being the same as the current VaultLib\r\n    function setVaultLib(address _nextVaultLib) external override {\r\n        require(msg.sender == creator, \"setVaultLib: Only callable by the contract creator\");\r\n\r\n        address prevVaultLib = getVaultLib();\r\n\r\n        __updateCodeAddress(_nextVaultLib);\r\n\r\n        emit VaultLibSet(prevVaultLib, _nextVaultLib);\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Checks whether an account is allowed to migrate the VaultProxy\r\n    /// @param _who The account to check\r\n    /// @return canMigrate_ True if the account is allowed to migrate the VaultProxy\r\n    function canMigrate(address _who) public view virtual override returns (bool canMigrate_) {\r\n        return _who == owner || _who == migrator;\r\n    }\r\n\r\n    /// @notice Gets the VaultLib target for the VaultProxy\r\n    /// @return vaultLib_ The address of the VaultLib target\r\n    function getVaultLib() public view returns (address vaultLib_) {\r\n        assembly {\r\n            // solium-disable-line\r\n            vaultLib_ := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\r\n        }\r\n        return vaultLib_;\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Helper to set the permissioned accessor of the VaultProxy.\r\n    /// Does not prevent the prevAccessor from being the _nextAccessor.\r\n    function __setAccessor(address _nextAccessor) internal {\r\n        require(_nextAccessor != address(0), \"__setAccessor: _nextAccessor cannot be empty\");\r\n        address prevAccessor = accessor;\r\n\r\n        accessor = _nextAccessor;\r\n\r\n        emit AccessorSet(prevAccessor, _nextAccessor);\r\n    }\r\n\r\n    /// @dev Helper to set the owner of the VaultProxy\r\n    function __setOwner(address _nextOwner) internal {\r\n        require(_nextOwner != address(0), \"__setOwner: _nextOwner cannot be empty\");\r\n        address prevOwner = owner;\r\n        require(_nextOwner != prevOwner, \"__setOwner: _nextOwner is the current owner\");\r\n\r\n        owner = _nextOwner;\r\n\r\n        emit OwnerSet(prevOwner, _nextOwner);\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/utils/IMigratableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IMigratableVault Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @dev DO NOT EDIT CONTRACT\r\ninterface IMigratableVault {\r\n    function canMigrate(address _who) external view returns (bool canMigrate_);\r\n\r\n    function init(\r\n        address _owner,\r\n        address _accessor,\r\n        string calldata _fundName\r\n    ) external;\r\n\r\n    function setAccessor(address _nextAccessor) external;\r\n\r\n    function setVaultLib(address _nextVaultLib) external;\r\n}\r\n"
    },
    "contracts/persistent/vault/utils/ProxiableVaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ProxiableVaultLib Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A contract that defines the upgrade behavior for VaultLib instances\r\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\r\n/// Code position in storage is `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`,\r\n/// which is \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\".\r\nabstract contract ProxiableVaultLib {\r\n    /// @dev Updates the target of the proxy to be the contract at _nextVaultLib\r\n    function __updateCodeAddress(address _nextVaultLib) internal {\r\n        require(\r\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\r\n                ProxiableVaultLib(_nextVaultLib).proxiableUUID(),\r\n            \"__updateCodeAddress: _nextVaultLib not compatible\"\r\n        );\r\n        assembly {\r\n            // solium-disable-line\r\n            sstore(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\r\n                _nextVaultLib\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @notice Returns a unique bytes32 hash for VaultLib instances\r\n    /// @return uuid_ The bytes32 hash representing the UUID\r\n    /// @dev The UUID is `bytes32(keccak256('mln.proxiable.vaultlib'))`\r\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\r\n        return 0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5;\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/vault/utils/SharesTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./VaultLibSafeMath.sol\";\r\n\r\n/// @title StandardERC20 Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Contains the storage, events, and default logic of an ERC20-compliant contract.\r\n/// @dev The logic can be overridden by VaultLib implementations.\r\n/// Adapted from OpenZeppelin 3.2.0.\r\n/// DO NOT EDIT THIS CONTRACT.\r\nabstract contract SharesTokenBase {\r\n    using VaultLibSafeMath for uint256;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    string internal sharesName;\r\n    string internal sharesSymbol;\r\n    uint256 internal sharesTotalSupply;\r\n    mapping(address => uint256) internal sharesBalances;\r\n    mapping(address => mapping(address => uint256)) internal sharesAllowances;\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @dev Standard implementation of ERC20's approve(). Can be overridden.\r\n    function approve(address _spender, uint256 _amount) public virtual returns (bool) {\r\n        __approve(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's transfer(). Can be overridden.\r\n    function transfer(address _recipient, uint256 _amount) public virtual returns (bool) {\r\n        __transfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's transferFrom(). Can be overridden.\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) public virtual returns (bool) {\r\n        __transfer(_sender, _recipient, _amount);\r\n        __approve(\r\n            _sender,\r\n            msg.sender,\r\n            sharesAllowances[_sender][msg.sender].sub(\r\n                _amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS - VIEW\r\n\r\n    /// @dev Standard implementation of ERC20's allowance(). Can be overridden.\r\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\r\n        return sharesAllowances[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's balanceOf(). Can be overridden.\r\n    function balanceOf(address _account) public view virtual returns (uint256) {\r\n        return sharesBalances[_account];\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's decimals(). Can not be overridden.\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's name(). Can be overridden.\r\n    function name() public view virtual returns (string memory) {\r\n        return sharesName;\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's symbol(). Can be overridden.\r\n    function symbol() public view virtual returns (string memory) {\r\n        return sharesSymbol;\r\n    }\r\n\r\n    /// @dev Standard implementation of ERC20's totalSupply(). Can be overridden.\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return sharesTotalSupply;\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Helper for approve(). Can be overridden.\r\n    function __approve(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal virtual {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        sharesAllowances[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    /// @dev Helper to burn tokens from an account. Can be overridden.\r\n    function __burn(address _account, uint256 _amount) internal virtual {\r\n        require(_account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        sharesBalances[_account] = sharesBalances[_account].sub(\r\n            _amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        sharesTotalSupply = sharesTotalSupply.sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /// @dev Helper to mint tokens to an account. Can be overridden.\r\n    function __mint(address _account, uint256 _amount) internal virtual {\r\n        require(_account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        sharesTotalSupply = sharesTotalSupply.add(_amount);\r\n        sharesBalances[_account] = sharesBalances[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /// @dev Helper to transfer tokens between accounts. Can be overridden.\r\n    function __transfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal virtual {\r\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        sharesBalances[_sender] = sharesBalances[_sender].sub(\r\n            _amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        sharesBalances[_recipient] = sharesBalances[_recipient].add(_amount);\r\n        emit Transfer(_sender, _recipient, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/vault/utils/VaultLibSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title VaultLibSafeMath library\r\n/// @notice A narrowed, verbatim implementation of OpenZeppelin 3.2.0 SafeMath\r\n/// for use with VaultLib\r\n/// @dev Preferred to importing from npm to guarantee consistent logic and revert reasons\r\n/// between VaultLib implementations\r\n/// DO NOT EDIT THIS CONTRACT\r\nlibrary VaultLibSafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"VaultLibSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"VaultLibSafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"VaultLibSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"VaultLibSafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"VaultLibSafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/IFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IFeeManager.sol\";\r\n\r\n/// @title Fee Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for all fees\r\ninterface IFee {\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\r\n\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData) external;\r\n\r\n    function identifier() external pure returns (string memory identifier_);\r\n\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        returns (\r\n            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\r\n            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\r\n            bool usesGavOnSettle_,\r\n            bool usesGavOnUpdate_\r\n        );\r\n\r\n    function payout(address _comptrollerProxy, address _vaultProxy)\r\n        external\r\n        returns (bool isPayable_);\r\n\r\n    function settle(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook _hook,\r\n        bytes calldata _settlementData,\r\n        uint256 _gav\r\n    )\r\n        external\r\n        returns (\r\n            IFeeManager.SettlementType settlementType_,\r\n            address payer_,\r\n            uint256 sharesDue_\r\n        );\r\n\r\n    function update(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook _hook,\r\n        bytes calldata _settlementData,\r\n        uint256 _gav\r\n    ) external;\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title FeeManager Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for the FeeManager\r\ninterface IFeeManager {\r\n    // No fees for the current release are implemented post-redeemShares\r\n    enum FeeHook {\r\n        Continuous,\r\n        BuySharesSetup,\r\n        PreBuyShares,\r\n        PostBuyShares,\r\n        BuySharesCompleted,\r\n        PreRedeemShares\r\n    }\r\n    enum SettlementType {None, Direct, Mint, Burn, MintSharesOutstanding, BurnSharesOutstanding}\r\n\r\n    function invokeHook(\r\n        FeeHook,\r\n        bytes calldata,\r\n        uint256\r\n    ) external;\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../FeeManager.sol\";\r\nimport \"./utils/FeeBase.sol\";\r\n\r\n/// @title PerformanceFee Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A performance-based fee with configurable rate and crystallization period, using\r\n/// a high watermark\r\n/// @dev This contract assumes that all shares in the VaultProxy are shares outstanding,\r\n/// which is fine for this release. Even if they are not, they are still shares that\r\n/// are only claimable by the fund owner.\r\ncontract PerformanceFee is FeeBase {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    event ActivatedForFund(address indexed comptrollerProxy, uint256 highWaterMark);\r\n\r\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate, uint256 period);\r\n\r\n    event LastSharePriceUpdated(\r\n        address indexed comptrollerProxy,\r\n        uint256 prevSharePrice,\r\n        uint256 nextSharePrice\r\n    );\r\n\r\n    event PaidOut(\r\n        address indexed comptrollerProxy,\r\n        uint256 prevHighWaterMark,\r\n        uint256 nextHighWaterMark,\r\n        uint256 aggregateValueDue\r\n    );\r\n\r\n    event PerformanceUpdated(\r\n        address indexed comptrollerProxy,\r\n        uint256 prevAggregateValueDue,\r\n        uint256 nextAggregateValueDue,\r\n        int256 sharesOutstandingDiff\r\n    );\r\n\r\n    struct FeeInfo {\r\n        uint256 rate;\r\n        uint256 period;\r\n        uint256 activated;\r\n        uint256 lastPaid;\r\n        uint256 highWaterMark;\r\n        uint256 lastSharePrice;\r\n        uint256 aggregateValueDue;\r\n    }\r\n\r\n    uint256 private constant RATE_DIVISOR = 10**18;\r\n    uint256 private constant SHARE_UNIT = 10**18;\r\n\r\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\r\n\r\n    constructor(address _feeManager) public FeeBase(_feeManager) {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Activates the fee for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    function activateForFund(address _comptrollerProxy, address) external override onlyFeeManager {\r\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n\r\n        // We must not force asset finality, otherwise funds that have Synths as tracked assets\r\n        // would be susceptible to a DoS attack when attempting to migrate to a release that uses\r\n        // this fee: an attacker trades a negligible amount of a tracked Synth with the VaultProxy\r\n        // as the recipient, thus causing `calcGrossShareValue(true)` to fail.\r\n        (uint256 grossSharePrice, bool sharePriceIsValid) = ComptrollerLib(_comptrollerProxy)\r\n            .calcGrossShareValue(false);\r\n        require(sharePriceIsValid, \"activateForFund: Invalid share price\");\r\n\r\n        feeInfo.highWaterMark = grossSharePrice;\r\n        feeInfo.lastSharePrice = grossSharePrice;\r\n        feeInfo.activated = block.timestamp;\r\n\r\n        emit ActivatedForFund(_comptrollerProxy, grossSharePrice);\r\n    }\r\n\r\n    /// @notice Add the initial fee settings for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _settingsData Encoded settings to apply to the policy for the fund\r\n    /// @dev `highWaterMark`, `lastSharePrice`, and `activated` are set during activation\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\r\n        external\r\n        override\r\n        onlyFeeManager\r\n    {\r\n        (uint256 feeRate, uint256 feePeriod) = abi.decode(_settingsData, (uint256, uint256));\r\n        require(feeRate > 0, \"addFundSettings: feeRate must be greater than 0\");\r\n        require(feePeriod > 0, \"addFundSettings: feePeriod must be greater than 0\");\r\n\r\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\r\n            rate: feeRate,\r\n            period: feePeriod,\r\n            activated: 0,\r\n            lastPaid: 0,\r\n            highWaterMark: 0,\r\n            lastSharePrice: 0,\r\n            aggregateValueDue: 0\r\n        });\r\n\r\n        emit FundSettingsAdded(_comptrollerProxy, feeRate, feePeriod);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a fee\r\n    /// @return identifier_ The identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"PERFORMANCE\";\r\n    }\r\n\r\n    /// @notice Gets the hooks that are implemented by the fee\r\n    /// @return implementedHooksForSettle_ The hooks during which settle() is implemented\r\n    /// @return implementedHooksForUpdate_ The hooks during which update() is implemented\r\n    /// @return usesGavOnSettle_ True if GAV is used during the settle() implementation\r\n    /// @return usesGavOnUpdate_ True if GAV is used during the update() implementation\r\n    /// @dev Used only during fee registration\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\r\n            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\r\n            bool usesGavOnSettle_,\r\n            bool usesGavOnUpdate_\r\n        )\r\n    {\r\n        implementedHooksForSettle_ = new IFeeManager.FeeHook[](3);\r\n        implementedHooksForSettle_[0] = IFeeManager.FeeHook.Continuous;\r\n        implementedHooksForSettle_[1] = IFeeManager.FeeHook.BuySharesSetup;\r\n        implementedHooksForSettle_[2] = IFeeManager.FeeHook.PreRedeemShares;\r\n\r\n        implementedHooksForUpdate_ = new IFeeManager.FeeHook[](3);\r\n        implementedHooksForUpdate_[0] = IFeeManager.FeeHook.Continuous;\r\n        implementedHooksForUpdate_[1] = IFeeManager.FeeHook.BuySharesCompleted;\r\n        implementedHooksForUpdate_[2] = IFeeManager.FeeHook.PreRedeemShares;\r\n\r\n        return (implementedHooksForSettle_, implementedHooksForUpdate_, true, true);\r\n    }\r\n\r\n    /// @notice Checks whether the shares outstanding for the fee can be paid out, and updates\r\n    /// the info for the fee's last payout\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return isPayable_ True if shares outstanding can be paid out\r\n    function payout(address _comptrollerProxy, address)\r\n        external\r\n        override\r\n        onlyFeeManager\r\n        returns (bool isPayable_)\r\n    {\r\n        if (!payoutAllowed(_comptrollerProxy)) {\r\n            return false;\r\n        }\r\n\r\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n        feeInfo.lastPaid = block.timestamp;\r\n\r\n        uint256 prevHighWaterMark = feeInfo.highWaterMark;\r\n        uint256 nextHighWaterMark = __calcUint256Max(feeInfo.lastSharePrice, prevHighWaterMark);\r\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\r\n\r\n        // Update state as necessary\r\n        if (prevAggregateValueDue > 0) {\r\n            feeInfo.aggregateValueDue = 0;\r\n        }\r\n        if (nextHighWaterMark > prevHighWaterMark) {\r\n            feeInfo.highWaterMark = nextHighWaterMark;\r\n        }\r\n\r\n        emit PaidOut(\r\n            _comptrollerProxy,\r\n            prevHighWaterMark,\r\n            nextHighWaterMark,\r\n            prevAggregateValueDue\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Settles the fee and calculates shares due\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _vaultProxy The VaultProxy of the fund\r\n    /// @param _gav The GAV of the fund\r\n    /// @return settlementType_ The type of settlement\r\n    /// @return (unused) The payer of shares due\r\n    /// @return sharesDue_ The amount of shares due\r\n    function settle(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook,\r\n        bytes calldata,\r\n        uint256 _gav\r\n    )\r\n        external\r\n        override\r\n        onlyFeeManager\r\n        returns (\r\n            IFeeManager.SettlementType settlementType_,\r\n            address,\r\n            uint256 sharesDue_\r\n        )\r\n    {\r\n        if (_gav == 0) {\r\n            return (IFeeManager.SettlementType.None, address(0), 0);\r\n        }\r\n\r\n        int256 settlementSharesDue = __settleAndUpdatePerformance(\r\n            _comptrollerProxy,\r\n            _vaultProxy,\r\n            _gav\r\n        );\r\n        if (settlementSharesDue == 0) {\r\n            return (IFeeManager.SettlementType.None, address(0), 0);\r\n        } else if (settlementSharesDue > 0) {\r\n            // Settle by minting shares outstanding for custody\r\n            return (\r\n                IFeeManager.SettlementType.MintSharesOutstanding,\r\n                address(0),\r\n                uint256(settlementSharesDue)\r\n            );\r\n        } else {\r\n            // Settle by burning from shares outstanding\r\n            return (\r\n                IFeeManager.SettlementType.BurnSharesOutstanding,\r\n                address(0),\r\n                uint256(-settlementSharesDue)\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the fee state after all fees have finished settle()\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _vaultProxy The VaultProxy of the fund\r\n    /// @param _hook The FeeHook being executed\r\n    /// @param _settlementData Encoded args to use in calculating the settlement\r\n    /// @param _gav The GAV of the fund\r\n    function update(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook _hook,\r\n        bytes calldata _settlementData,\r\n        uint256 _gav\r\n    ) external override onlyFeeManager {\r\n        uint256 prevSharePrice = comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice;\r\n        uint256 nextSharePrice = __calcNextSharePrice(\r\n            _comptrollerProxy,\r\n            _vaultProxy,\r\n            _hook,\r\n            _settlementData,\r\n            _gav\r\n        );\r\n\r\n        if (nextSharePrice == prevSharePrice) {\r\n            return;\r\n        }\r\n\r\n        comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice = nextSharePrice;\r\n\r\n        emit LastSharePriceUpdated(_comptrollerProxy, prevSharePrice, nextSharePrice);\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Checks whether the shares outstanding can be paid out\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return payoutAllowed_ True if the fee payment is due\r\n    /// @dev Payout is allowed if fees have not yet been settled in a crystallization period,\r\n    /// and at least 1 crystallization period has passed since activation\r\n    function payoutAllowed(address _comptrollerProxy) public view returns (bool payoutAllowed_) {\r\n        FeeInfo memory feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n        uint256 period = feeInfo.period;\r\n\r\n        uint256 timeSinceActivated = block.timestamp.sub(feeInfo.activated);\r\n\r\n        // Check if at least 1 crystallization period has passed since activation\r\n        if (timeSinceActivated < period) {\r\n            return false;\r\n        }\r\n\r\n        // Check that a full crystallization period has passed since the last payout\r\n        uint256 timeSincePeriodStart = timeSinceActivated % period;\r\n        uint256 periodStart = block.timestamp.sub(timeSincePeriodStart);\r\n        return feeInfo.lastPaid < periodStart;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to calculate the aggregated value accumulated to a fund since the last\r\n    /// settlement (happening at investment/redemption)\r\n    /// Validated:\r\n    /// _netSharesSupply > 0\r\n    /// _sharePriceWithoutPerformance != _prevSharePrice\r\n    function __calcAggregateValueDue(\r\n        uint256 _netSharesSupply,\r\n        uint256 _sharePriceWithoutPerformance,\r\n        uint256 _prevSharePrice,\r\n        uint256 _prevAggregateValueDue,\r\n        uint256 _feeRate,\r\n        uint256 _highWaterMark\r\n    ) private pure returns (uint256) {\r\n        int256 superHWMValueSinceLastSettled = (\r\n            int256(__calcUint256Max(_highWaterMark, _sharePriceWithoutPerformance)).sub(\r\n                int256(__calcUint256Max(_highWaterMark, _prevSharePrice))\r\n            )\r\n        )\r\n            .mul(int256(_netSharesSupply))\r\n            .div(int256(SHARE_UNIT));\r\n\r\n        int256 valueDueSinceLastSettled = superHWMValueSinceLastSettled.mul(int256(_feeRate)).div(\r\n            int256(RATE_DIVISOR)\r\n        );\r\n\r\n        return\r\n            uint256(\r\n                __calcInt256Max(0, int256(_prevAggregateValueDue).add(valueDueSinceLastSettled))\r\n            );\r\n    }\r\n\r\n    /// @dev Helper to calculate the max of two int values\r\n    function __calcInt256Max(int256 _a, int256 _b) private pure returns (int256) {\r\n        if (_a >= _b) {\r\n            return _a;\r\n        }\r\n\r\n        return _b;\r\n    }\r\n\r\n    /// @dev Helper to calculate the next `lastSharePrice` value\r\n    function __calcNextSharePrice(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IFeeManager.FeeHook _hook,\r\n        bytes memory _settlementData,\r\n        uint256 _gav\r\n    ) private view returns (uint256 nextSharePrice_) {\r\n        uint256 denominationAssetUnit = 10 **\r\n            uint256(ERC20(ComptrollerLib(_comptrollerProxy).getDenominationAsset()).decimals());\r\n        if (_gav == 0) {\r\n            return denominationAssetUnit;\r\n        }\r\n\r\n        // Get shares outstanding via VaultProxy balance and calc shares supply to get net shares supply\r\n        ERC20 vaultProxyContract = ERC20(_vaultProxy);\r\n        uint256 totalSharesSupply = vaultProxyContract.totalSupply();\r\n        uint256 nextNetSharesSupply = totalSharesSupply.sub(\r\n            vaultProxyContract.balanceOf(_vaultProxy)\r\n        );\r\n        if (nextNetSharesSupply == 0) {\r\n            return denominationAssetUnit;\r\n        }\r\n\r\n        uint256 nextGav = _gav;\r\n\r\n        // For both Continuous and BuySharesCompleted hooks, _gav and shares supply will not change,\r\n        // we only need additional calculations for PreRedeemShares\r\n        if (_hook == IFeeManager.FeeHook.PreRedeemShares) {\r\n            (, uint256 sharesDecrease) = __decodePreRedeemSharesSettlementData(_settlementData);\r\n\r\n            // Shares have not yet been burned\r\n            nextNetSharesSupply = nextNetSharesSupply.sub(sharesDecrease);\r\n            if (nextNetSharesSupply == 0) {\r\n                return denominationAssetUnit;\r\n            }\r\n\r\n            // Assets have not yet been withdrawn\r\n            uint256 gavDecrease = _gav.mul(sharesDecrease).div(totalSharesSupply);\r\n\r\n            nextGav = nextGav.sub(gavDecrease);\r\n            if (nextGav == 0) {\r\n                return denominationAssetUnit;\r\n            }\r\n        }\r\n\r\n        return nextGav.mul(SHARE_UNIT).div(nextNetSharesSupply);\r\n    }\r\n\r\n    /// @dev Helper to calculate the performance metrics for a fund.\r\n    /// Validated:\r\n    /// _totalSharesSupply > 0\r\n    /// _gav > 0\r\n    /// _totalSharesSupply != _totalSharesOutstanding\r\n    function __calcPerformance(\r\n        address _comptrollerProxy,\r\n        uint256 _totalSharesSupply,\r\n        uint256 _totalSharesOutstanding,\r\n        uint256 _prevAggregateValueDue,\r\n        FeeInfo memory feeInfo,\r\n        uint256 _gav\r\n    ) private view returns (uint256 nextAggregateValueDue_, int256 sharesDue_) {\r\n        // Use the 'shares supply net shares outstanding' for performance calcs.\r\n        // Cannot be 0, as _totalSharesSupply != _totalSharesOutstanding\r\n        uint256 netSharesSupply = _totalSharesSupply.sub(_totalSharesOutstanding);\r\n        uint256 sharePriceWithoutPerformance = _gav.mul(SHARE_UNIT).div(netSharesSupply);\r\n\r\n        // If gross share price has not changed, can exit early\r\n        uint256 prevSharePrice = feeInfo.lastSharePrice;\r\n        if (sharePriceWithoutPerformance == prevSharePrice) {\r\n            return (_prevAggregateValueDue, 0);\r\n        }\r\n\r\n        nextAggregateValueDue_ = __calcAggregateValueDue(\r\n            netSharesSupply,\r\n            sharePriceWithoutPerformance,\r\n            prevSharePrice,\r\n            _prevAggregateValueDue,\r\n            feeInfo.rate,\r\n            feeInfo.highWaterMark\r\n        );\r\n\r\n        sharesDue_ = __calcSharesDue(\r\n            _comptrollerProxy,\r\n            netSharesSupply,\r\n            _gav,\r\n            nextAggregateValueDue_\r\n        );\r\n\r\n        return (nextAggregateValueDue_, sharesDue_);\r\n    }\r\n\r\n    /// @dev Helper to calculate sharesDue during settlement.\r\n    /// Validated:\r\n    /// _netSharesSupply > 0\r\n    /// _gav > 0\r\n    function __calcSharesDue(\r\n        address _comptrollerProxy,\r\n        uint256 _netSharesSupply,\r\n        uint256 _gav,\r\n        uint256 _nextAggregateValueDue\r\n    ) private view returns (int256 sharesDue_) {\r\n        // If _nextAggregateValueDue > _gav, then no shares can be created.\r\n        // This is a known limitation of the model, which is only reached for unrealistically\r\n        // high performance fee rates (> 100%). A revert is allowed in such a case.\r\n        uint256 sharesDueForAggregateValueDue = _nextAggregateValueDue.mul(_netSharesSupply).div(\r\n            _gav.sub(_nextAggregateValueDue)\r\n        );\r\n\r\n        // Shares due is the +/- diff or the total shares outstanding already minted\r\n        return\r\n            int256(sharesDueForAggregateValueDue).sub(\r\n                int256(\r\n                    FeeManager(FEE_MANAGER).getFeeSharesOutstandingForFund(\r\n                        _comptrollerProxy,\r\n                        address(this)\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @dev Helper to calculate the max of two uint values\r\n    function __calcUint256Max(uint256 _a, uint256 _b) private pure returns (uint256) {\r\n        if (_a >= _b) {\r\n            return _a;\r\n        }\r\n\r\n        return _b;\r\n    }\r\n\r\n    /// @dev Helper to settle the fee and update performance state.\r\n    /// Validated:\r\n    /// _gav > 0\r\n    function __settleAndUpdatePerformance(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        uint256 _gav\r\n    ) private returns (int256 sharesDue_) {\r\n        ERC20 sharesTokenContract = ERC20(_vaultProxy);\r\n\r\n        uint256 totalSharesSupply = sharesTokenContract.totalSupply();\r\n        if (totalSharesSupply == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 totalSharesOutstanding = sharesTokenContract.balanceOf(_vaultProxy);\r\n        if (totalSharesOutstanding == totalSharesSupply) {\r\n            return 0;\r\n        }\r\n\r\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\r\n\r\n        uint256 nextAggregateValueDue;\r\n        (nextAggregateValueDue, sharesDue_) = __calcPerformance(\r\n            _comptrollerProxy,\r\n            totalSharesSupply,\r\n            totalSharesOutstanding,\r\n            prevAggregateValueDue,\r\n            feeInfo,\r\n            _gav\r\n        );\r\n        if (nextAggregateValueDue == prevAggregateValueDue) {\r\n            return 0;\r\n        }\r\n\r\n        // Update fee state\r\n        feeInfo.aggregateValueDue = nextAggregateValueDue;\r\n\r\n        emit PerformanceUpdated(\r\n            _comptrollerProxy,\r\n            prevAggregateValueDue,\r\n            nextAggregateValueDue,\r\n            sharesDue_\r\n        );\r\n\r\n        return sharesDue_;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the feeInfo for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy contract of the fund\r\n    /// @return feeInfo_ The feeInfo\r\n    function getFeeInfoForFund(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (FeeInfo memory feeInfo_)\r\n    {\r\n        return comptrollerProxyToFeeInfo[_comptrollerProxy];\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../persistent/dispatcher/IDispatcher.sol\";\r\nimport \"../../../extensions/IExtension.sol\";\r\nimport \"../../../extensions/fee-manager/IFeeManager.sol\";\r\nimport \"../../../extensions/policy-manager/IPolicyManager.sol\";\r\nimport \"../../../infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol\";\r\nimport \"../../../infrastructure/value-interpreter/IValueInterpreter.sol\";\r\nimport \"../../../utils/AddressArrayLib.sol\";\r\nimport \"../../../utils/AssetFinalityResolver.sol\";\r\nimport \"../../fund-deployer/IFundDeployer.sol\";\r\nimport \"../vault/IVault.sol\";\r\nimport \"./IComptroller.sol\";\r\n\r\n/// @title ComptrollerLib Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice The core logic library shared by all funds\r\ncontract ComptrollerLib is IComptroller, AssetFinalityResolver {\r\n    using AddressArrayLib for address[];\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    event MigratedSharesDuePaid(uint256 sharesDue);\r\n\r\n    event OverridePauseSet(bool indexed overridePause);\r\n\r\n    event PreRedeemSharesHookFailed(\r\n        bytes failureReturnData,\r\n        address redeemer,\r\n        uint256 sharesQuantity\r\n    );\r\n\r\n    event SharesBought(\r\n        address indexed caller,\r\n        address indexed buyer,\r\n        uint256 investmentAmount,\r\n        uint256 sharesIssued,\r\n        uint256 sharesReceived\r\n    );\r\n\r\n    event SharesRedeemed(\r\n        address indexed redeemer,\r\n        uint256 sharesQuantity,\r\n        address[] receivedAssets,\r\n        uint256[] receivedAssetQuantities\r\n    );\r\n\r\n    event VaultProxySet(address vaultProxy);\r\n\r\n    // Constants and immutables - shared by all proxies\r\n    uint256 private constant SHARES_UNIT = 10**18;\r\n    address private immutable DISPATCHER;\r\n    address private immutable FUND_DEPLOYER;\r\n    address private immutable FEE_MANAGER;\r\n    address private immutable INTEGRATION_MANAGER;\r\n    address private immutable PRIMITIVE_PRICE_FEED;\r\n    address private immutable POLICY_MANAGER;\r\n    address private immutable VALUE_INTERPRETER;\r\n\r\n    // Pseudo-constants (can only be set once)\r\n\r\n    address internal denominationAsset;\r\n    address internal vaultProxy;\r\n    // True only for the one non-proxy\r\n    bool internal isLib;\r\n\r\n    // Storage\r\n\r\n    // Allows a fund owner to override a release-level pause\r\n    bool internal overridePause;\r\n    // A reverse-mutex, granting atomic permission for particular contracts to make vault calls\r\n    bool internal permissionedVaultActionAllowed;\r\n    // A mutex to protect against reentrancy\r\n    bool internal reentranceLocked;\r\n    // A timelock between any \"shares actions\" (i.e., buy and redeem shares), per-account\r\n    uint256 internal sharesActionTimelock;\r\n    mapping(address => uint256) internal acctToLastSharesAction;\r\n\r\n    ///////////////\r\n    // MODIFIERS //\r\n    ///////////////\r\n\r\n    modifier allowsPermissionedVaultAction() {\r\n        __assertPermissionedVaultActionNotAllowed();\r\n        permissionedVaultActionAllowed = true;\r\n        _;\r\n        permissionedVaultActionAllowed = false;\r\n    }\r\n\r\n    modifier locksReentrance() {\r\n        __assertNotReentranceLocked();\r\n        reentranceLocked = true;\r\n        _;\r\n        reentranceLocked = false;\r\n    }\r\n\r\n    modifier onlyActive() {\r\n        __assertIsActive(vaultProxy);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotPaused() {\r\n        __assertNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier onlyFundDeployer() {\r\n        __assertIsFundDeployer(msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        __assertIsOwner(msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier timelockedSharesAction(address _account) {\r\n        __assertSharesActionNotTimelocked(_account);\r\n        _;\r\n        acctToLastSharesAction[_account] = block.timestamp;\r\n    }\r\n\r\n    // ASSERTION HELPERS\r\n\r\n    // Modifiers are inefficient in terms of contract size,\r\n    // so we use helper functions to prevent repetitive inlining of expensive string values.\r\n\r\n    /// @dev Since vaultProxy is set during activate(),\r\n    /// we can check that var rather than storing additional state\r\n    function __assertIsActive(address _vaultProxy) private pure {\r\n        require(_vaultProxy != address(0), \"Fund not active\");\r\n    }\r\n\r\n    function __assertIsFundDeployer(address _who) private view {\r\n        require(_who == FUND_DEPLOYER, \"Only FundDeployer callable\");\r\n    }\r\n\r\n    function __assertIsOwner(address _who) private view {\r\n        require(_who == IVault(vaultProxy).getOwner(), \"Only fund owner callable\");\r\n    }\r\n\r\n    function __assertLowLevelCall(bool _success, bytes memory _returnData) private pure {\r\n        require(_success, string(_returnData));\r\n    }\r\n\r\n    function __assertNotPaused() private view {\r\n        require(!__fundIsPaused(), \"Fund is paused\");\r\n    }\r\n\r\n    function __assertNotReentranceLocked() private view {\r\n        require(!reentranceLocked, \"Re-entrance\");\r\n    }\r\n\r\n    function __assertPermissionedVaultActionNotAllowed() private view {\r\n        require(!permissionedVaultActionAllowed, \"Vault action re-entrance\");\r\n    }\r\n\r\n    function __assertSharesActionNotTimelocked(address _account) private view {\r\n        require(\r\n            block.timestamp.sub(acctToLastSharesAction[_account]) >= sharesActionTimelock,\r\n            \"Shares action timelocked\"\r\n        );\r\n    }\r\n\r\n    constructor(\r\n        address _dispatcher,\r\n        address _fundDeployer,\r\n        address _valueInterpreter,\r\n        address _feeManager,\r\n        address _integrationManager,\r\n        address _policyManager,\r\n        address _primitivePriceFeed,\r\n        address _synthetixPriceFeed,\r\n        address _synthetixAddressResolver\r\n    ) public AssetFinalityResolver(_synthetixPriceFeed, _synthetixAddressResolver) {\r\n        DISPATCHER = _dispatcher;\r\n        FEE_MANAGER = _feeManager;\r\n        FUND_DEPLOYER = _fundDeployer;\r\n        INTEGRATION_MANAGER = _integrationManager;\r\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\r\n        POLICY_MANAGER = _policyManager;\r\n        VALUE_INTERPRETER = _valueInterpreter;\r\n        isLib = true;\r\n    }\r\n\r\n    /////////////\r\n    // GENERAL //\r\n    /////////////\r\n\r\n    /// @notice Calls a specified action on an Extension\r\n    /// @param _extension The Extension contract to call (e.g., FeeManager)\r\n    /// @param _actionId An ID representing the action to take on the extension (see extension)\r\n    /// @param _callArgs The encoded data for the call\r\n    /// @dev Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy\r\n    /// (for access control). Uses a mutex of sorts that allows \"permissioned vault actions\"\r\n    /// during calls originating from this function.\r\n    function callOnExtension(\r\n        address _extension,\r\n        uint256 _actionId,\r\n        bytes calldata _callArgs\r\n    ) external override onlyNotPaused onlyActive locksReentrance allowsPermissionedVaultAction {\r\n        require(\r\n            _extension == FEE_MANAGER || _extension == INTEGRATION_MANAGER,\r\n            \"callOnExtension: _extension invalid\"\r\n        );\r\n\r\n        IExtension(_extension).receiveCallFromComptroller(msg.sender, _actionId, _callArgs);\r\n    }\r\n\r\n    /// @notice Sets or unsets an override on a release-wide pause\r\n    /// @param _nextOverridePause True if the pause should be overrode\r\n    function setOverridePause(bool _nextOverridePause) external onlyOwner {\r\n        require(_nextOverridePause != overridePause, \"setOverridePause: Value already set\");\r\n\r\n        overridePause = _nextOverridePause;\r\n\r\n        emit OverridePauseSet(_nextOverridePause);\r\n    }\r\n\r\n    /// @notice Makes an arbitrary call with the VaultProxy contract as the sender\r\n    /// @param _contract The contract to call\r\n    /// @param _selector The selector to call\r\n    /// @param _encodedArgs The encoded arguments for the call\r\n    function vaultCallOnContract(\r\n        address _contract,\r\n        bytes4 _selector,\r\n        bytes calldata _encodedArgs\r\n    ) external onlyNotPaused onlyActive onlyOwner {\r\n        require(\r\n            IFundDeployer(FUND_DEPLOYER).isRegisteredVaultCall(_contract, _selector),\r\n            \"vaultCallOnContract: Unregistered\"\r\n        );\r\n\r\n        IVault(vaultProxy).callOnContract(_contract, abi.encodePacked(_selector, _encodedArgs));\r\n    }\r\n\r\n    /// @dev Helper to check whether the release is paused, and that there is no local override\r\n    function __fundIsPaused() private view returns (bool) {\r\n        return\r\n            IFundDeployer(FUND_DEPLOYER).getReleaseStatus() ==\r\n            IFundDeployer.ReleaseStatus.Paused &&\r\n            !overridePause;\r\n    }\r\n\r\n    ////////////////////////////////\r\n    // PERMISSIONED VAULT ACTIONS //\r\n    ////////////////////////////////\r\n\r\n    /// @notice Makes a permissioned, state-changing call on the VaultProxy contract\r\n    /// @param _action The enum representing the VaultAction to perform on the VaultProxy\r\n    /// @param _actionData The call data for the action to perform\r\n    function permissionedVaultAction(VaultAction _action, bytes calldata _actionData)\r\n        external\r\n        override\r\n        onlyNotPaused\r\n        onlyActive\r\n    {\r\n        __assertPermissionedVaultAction(msg.sender, _action);\r\n\r\n        if (_action == VaultAction.AddTrackedAsset) {\r\n            __vaultActionAddTrackedAsset(_actionData);\r\n        } else if (_action == VaultAction.ApproveAssetSpender) {\r\n            __vaultActionApproveAssetSpender(_actionData);\r\n        } else if (_action == VaultAction.BurnShares) {\r\n            __vaultActionBurnShares(_actionData);\r\n        } else if (_action == VaultAction.MintShares) {\r\n            __vaultActionMintShares(_actionData);\r\n        } else if (_action == VaultAction.RemoveTrackedAsset) {\r\n            __vaultActionRemoveTrackedAsset(_actionData);\r\n        } else if (_action == VaultAction.TransferShares) {\r\n            __vaultActionTransferShares(_actionData);\r\n        } else if (_action == VaultAction.WithdrawAssetTo) {\r\n            __vaultActionWithdrawAssetTo(_actionData);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to assert that a caller is allowed to perform a particular VaultAction\r\n    function __assertPermissionedVaultAction(address _caller, VaultAction _action) private view {\r\n        require(\r\n            permissionedVaultActionAllowed,\r\n            \"__assertPermissionedVaultAction: No action allowed\"\r\n        );\r\n\r\n        if (_caller == INTEGRATION_MANAGER) {\r\n            require(\r\n                _action == VaultAction.ApproveAssetSpender ||\r\n                    _action == VaultAction.AddTrackedAsset ||\r\n                    _action == VaultAction.RemoveTrackedAsset ||\r\n                    _action == VaultAction.WithdrawAssetTo,\r\n                \"__assertPermissionedVaultAction: Not valid for IntegrationManager\"\r\n            );\r\n        } else if (_caller == FEE_MANAGER) {\r\n            require(\r\n                _action == VaultAction.BurnShares ||\r\n                    _action == VaultAction.MintShares ||\r\n                    _action == VaultAction.TransferShares,\r\n                \"__assertPermissionedVaultAction: Not valid for FeeManager\"\r\n            );\r\n        } else {\r\n            revert(\"__assertPermissionedVaultAction: Not a valid actor\");\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to add a tracked asset to the fund\r\n    function __vaultActionAddTrackedAsset(bytes memory _actionData) private {\r\n        address asset = abi.decode(_actionData, (address));\r\n        IVault(vaultProxy).addTrackedAsset(asset);\r\n    }\r\n\r\n    /// @dev Helper to grant a spender an allowance for a fund's asset\r\n    function __vaultActionApproveAssetSpender(bytes memory _actionData) private {\r\n        (address asset, address target, uint256 amount) = abi.decode(\r\n            _actionData,\r\n            (address, address, uint256)\r\n        );\r\n        IVault(vaultProxy).approveAssetSpender(asset, target, amount);\r\n    }\r\n\r\n    /// @dev Helper to burn fund shares for a particular account\r\n    function __vaultActionBurnShares(bytes memory _actionData) private {\r\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\r\n        IVault(vaultProxy).burnShares(target, amount);\r\n    }\r\n\r\n    /// @dev Helper to mint fund shares to a particular account\r\n    function __vaultActionMintShares(bytes memory _actionData) private {\r\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\r\n        IVault(vaultProxy).mintShares(target, amount);\r\n    }\r\n\r\n    /// @dev Helper to remove a tracked asset from the fund\r\n    function __vaultActionRemoveTrackedAsset(bytes memory _actionData) private {\r\n        address asset = abi.decode(_actionData, (address));\r\n\r\n        // Allowing this to fail silently makes it cheaper and simpler\r\n        // for Extensions to not query for the denomination asset\r\n        if (asset != denominationAsset) {\r\n            IVault(vaultProxy).removeTrackedAsset(asset);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to transfer fund shares from one account to another\r\n    function __vaultActionTransferShares(bytes memory _actionData) private {\r\n        (address from, address to, uint256 amount) = abi.decode(\r\n            _actionData,\r\n            (address, address, uint256)\r\n        );\r\n        IVault(vaultProxy).transferShares(from, to, amount);\r\n    }\r\n\r\n    /// @dev Helper to withdraw an asset from the VaultProxy to a given account\r\n    function __vaultActionWithdrawAssetTo(bytes memory _actionData) private {\r\n        (address asset, address target, uint256 amount) = abi.decode(\r\n            _actionData,\r\n            (address, address, uint256)\r\n        );\r\n        IVault(vaultProxy).withdrawAssetTo(asset, target, amount);\r\n    }\r\n\r\n    ///////////////\r\n    // LIFECYCLE //\r\n    ///////////////\r\n\r\n    /// @notice Initializes a fund with its core config\r\n    /// @param _denominationAsset The asset in which the fund's value should be denominated\r\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\r\n    /// (buying or selling shares) by the same user\r\n    /// @dev Pseudo-constructor per proxy.\r\n    /// No need to assert access because this is called atomically on deployment,\r\n    /// and once it's called, it cannot be called again.\r\n    function init(address _denominationAsset, uint256 _sharesActionTimelock) external override {\r\n        require(denominationAsset == address(0), \"init: Already initialized\");\r\n        require(\r\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_denominationAsset),\r\n            \"init: Bad denomination asset\"\r\n        );\r\n\r\n        denominationAsset = _denominationAsset;\r\n        sharesActionTimelock = _sharesActionTimelock;\r\n    }\r\n\r\n    /// @notice Configure the extensions of a fund\r\n    /// @param _feeManagerConfigData Encoded config for fees to enable\r\n    /// @param _policyManagerConfigData Encoded config for policies to enable\r\n    /// @dev No need to assert anything beyond FundDeployer access.\r\n    /// Called atomically with init(), but after ComptrollerLib has been deployed,\r\n    /// giving access to its state and interface\r\n    function configureExtensions(\r\n        bytes calldata _feeManagerConfigData,\r\n        bytes calldata _policyManagerConfigData\r\n    ) external override onlyFundDeployer {\r\n        if (_feeManagerConfigData.length > 0) {\r\n            IExtension(FEE_MANAGER).setConfigForFund(_feeManagerConfigData);\r\n        }\r\n        if (_policyManagerConfigData.length > 0) {\r\n            IExtension(POLICY_MANAGER).setConfigForFund(_policyManagerConfigData);\r\n        }\r\n    }\r\n\r\n    /// @notice Activates the fund by attaching a VaultProxy and activating all Extensions\r\n    /// @param _vaultProxy The VaultProxy to attach to the fund\r\n    /// @param _isMigration True if a migrated fund is being activated\r\n    /// @dev No need to assert anything beyond FundDeployer access.\r\n    function activate(address _vaultProxy, bool _isMigration) external override onlyFundDeployer {\r\n        vaultProxy = _vaultProxy;\r\n\r\n        emit VaultProxySet(_vaultProxy);\r\n\r\n        if (_isMigration) {\r\n            // Distribute any shares in the VaultProxy to the fund owner.\r\n            // This is a mechanism to ensure that even in the edge case of a fund being unable\r\n            // to payout fee shares owed during migration, these shares are not lost.\r\n            uint256 sharesDue = ERC20(_vaultProxy).balanceOf(_vaultProxy);\r\n            if (sharesDue > 0) {\r\n                IVault(_vaultProxy).transferShares(\r\n                    _vaultProxy,\r\n                    IVault(_vaultProxy).getOwner(),\r\n                    sharesDue\r\n                );\r\n\r\n                emit MigratedSharesDuePaid(sharesDue);\r\n            }\r\n        }\r\n\r\n        // Note: a future release could consider forcing the adding of a tracked asset here,\r\n        // just in case a fund is migrating from an old configuration where they are not able\r\n        // to remove an asset to get under the tracked assets limit\r\n        IVault(_vaultProxy).addTrackedAsset(denominationAsset);\r\n\r\n        // Activate extensions\r\n        IExtension(FEE_MANAGER).activateForFund(_isMigration);\r\n        IExtension(INTEGRATION_MANAGER).activateForFund(_isMigration);\r\n        IExtension(POLICY_MANAGER).activateForFund(_isMigration);\r\n    }\r\n\r\n    /// @notice Remove the config for a fund\r\n    /// @dev No need to assert anything beyond FundDeployer access.\r\n    /// Calling onlyNotPaused here rather than in the FundDeployer allows\r\n    /// the owner to potentially override the pause and rescue unpaid fees.\r\n    function destruct()\r\n        external\r\n        override\r\n        onlyFundDeployer\r\n        onlyNotPaused\r\n        allowsPermissionedVaultAction\r\n    {\r\n        // Failsafe to protect the libs against selfdestruct\r\n        require(!isLib, \"destruct: Only delegate callable\");\r\n\r\n        // Deactivate the extensions\r\n        IExtension(FEE_MANAGER).deactivateForFund();\r\n        IExtension(INTEGRATION_MANAGER).deactivateForFund();\r\n        IExtension(POLICY_MANAGER).deactivateForFund();\r\n\r\n        // Delete storage of ComptrollerProxy\r\n        // There should never be ETH in the ComptrollerLib, so no need to waste gas\r\n        // to get the fund owner\r\n        selfdestruct(address(0));\r\n    }\r\n\r\n    ////////////////\r\n    // ACCOUNTING //\r\n    ////////////////\r\n\r\n    /// @notice Calculates the gross asset value (GAV) of the fund\r\n    /// @param _requireFinality True if all assets must have exact final balances settled\r\n    /// @return gav_ The fund GAV\r\n    /// @return isValid_ True if the conversion rates used to derive the GAV are all valid\r\n    function calcGav(bool _requireFinality) public override returns (uint256 gav_, bool isValid_) {\r\n        address vaultProxyAddress = vaultProxy;\r\n        address[] memory assets = IVault(vaultProxyAddress).getTrackedAssets();\r\n        if (assets.length == 0) {\r\n            return (0, true);\r\n        }\r\n\r\n        uint256[] memory balances = new uint256[](assets.length);\r\n        for (uint256 i; i < assets.length; i++) {\r\n            balances[i] = __finalizeIfSynthAndGetAssetBalance(\r\n                vaultProxyAddress,\r\n                assets[i],\r\n                _requireFinality\r\n            );\r\n        }\r\n\r\n        (gav_, isValid_) = IValueInterpreter(VALUE_INTERPRETER).calcCanonicalAssetsTotalValue(\r\n            assets,\r\n            balances,\r\n            denominationAsset\r\n        );\r\n\r\n        return (gav_, isValid_);\r\n    }\r\n\r\n    /// @notice Calculates the gross value of 1 unit of shares in the fund's denomination asset\r\n    /// @param _requireFinality True if all assets must have exact final balances settled\r\n    /// @return grossShareValue_ The amount of the denomination asset per share\r\n    /// @return isValid_ True if the conversion rates to derive the value are all valid\r\n    /// @dev Does not account for any fees outstanding.\r\n    function calcGrossShareValue(bool _requireFinality)\r\n        external\r\n        override\r\n        returns (uint256 grossShareValue_, bool isValid_)\r\n    {\r\n        uint256 gav;\r\n        (gav, isValid_) = calcGav(_requireFinality);\r\n\r\n        grossShareValue_ = __calcGrossShareValue(\r\n            gav,\r\n            ERC20(vaultProxy).totalSupply(),\r\n            10**uint256(ERC20(denominationAsset).decimals())\r\n        );\r\n\r\n        return (grossShareValue_, isValid_);\r\n    }\r\n\r\n    /// @dev Helper for calculating the gross share value\r\n    function __calcGrossShareValue(\r\n        uint256 _gav,\r\n        uint256 _sharesSupply,\r\n        uint256 _denominationAssetUnit\r\n    ) private pure returns (uint256 grossShareValue_) {\r\n        if (_sharesSupply == 0) {\r\n            return _denominationAssetUnit;\r\n        }\r\n\r\n        return _gav.mul(SHARES_UNIT).div(_sharesSupply);\r\n    }\r\n\r\n    ///////////////////\r\n    // PARTICIPATION //\r\n    ///////////////////\r\n\r\n    // BUY SHARES\r\n\r\n    /// @notice Buys shares in the fund for multiple sets of criteria\r\n    /// @param _buyers The accounts for which to buy shares\r\n    /// @param _investmentAmounts The amounts of the fund's denomination asset\r\n    /// with which to buy shares for the corresponding _buyers\r\n    /// @param _minSharesQuantities The minimum quantities of shares to buy\r\n    /// with the corresponding _investmentAmounts\r\n    /// @return sharesReceivedAmounts_ The actual amounts of shares received\r\n    /// by the corresponding _buyers\r\n    /// @dev Param arrays have indexes corresponding to individual __buyShares() orders.\r\n    function buyShares(\r\n        address[] calldata _buyers,\r\n        uint256[] calldata _investmentAmounts,\r\n        uint256[] calldata _minSharesQuantities\r\n    )\r\n        external\r\n        onlyNotPaused\r\n        locksReentrance\r\n        allowsPermissionedVaultAction\r\n        returns (uint256[] memory sharesReceivedAmounts_)\r\n    {\r\n        require(_buyers.length > 0, \"buyShares: Empty _buyers\");\r\n        require(\r\n            _buyers.length == _investmentAmounts.length &&\r\n                _buyers.length == _minSharesQuantities.length,\r\n            \"buyShares: Unequal arrays\"\r\n        );\r\n\r\n        address vaultProxyCopy = vaultProxy;\r\n        __assertIsActive(vaultProxyCopy);\r\n        require(\r\n            !IDispatcher(DISPATCHER).hasMigrationRequest(vaultProxyCopy),\r\n            \"buyShares: Pending migration\"\r\n        );\r\n\r\n        (uint256 gav, bool gavIsValid) = calcGav(true);\r\n        require(gavIsValid, \"buyShares: Invalid GAV\");\r\n\r\n        __buySharesSetupHook(msg.sender, _investmentAmounts, gav);\r\n\r\n        address denominationAssetCopy = denominationAsset;\r\n        uint256 sharePrice = __calcGrossShareValue(\r\n            gav,\r\n            ERC20(vaultProxyCopy).totalSupply(),\r\n            10**uint256(ERC20(denominationAssetCopy).decimals())\r\n        );\r\n\r\n        sharesReceivedAmounts_ = new uint256[](_buyers.length);\r\n        for (uint256 i; i < _buyers.length; i++) {\r\n            sharesReceivedAmounts_[i] = __buyShares(\r\n                _buyers[i],\r\n                _investmentAmounts[i],\r\n                _minSharesQuantities[i],\r\n                vaultProxyCopy,\r\n                sharePrice,\r\n                gav,\r\n                denominationAssetCopy\r\n            );\r\n\r\n            gav = gav.add(_investmentAmounts[i]);\r\n        }\r\n\r\n        __buySharesCompletedHook(msg.sender, sharesReceivedAmounts_, gav);\r\n\r\n        return sharesReceivedAmounts_;\r\n    }\r\n\r\n    /// @dev Helper to buy shares\r\n    function __buyShares(\r\n        address _buyer,\r\n        uint256 _investmentAmount,\r\n        uint256 _minSharesQuantity,\r\n        address _vaultProxy,\r\n        uint256 _sharePrice,\r\n        uint256 _preBuySharesGav,\r\n        address _denominationAsset\r\n    ) private timelockedSharesAction(_buyer) returns (uint256 sharesReceived_) {\r\n        require(_investmentAmount > 0, \"__buyShares: Empty _investmentAmount\");\r\n\r\n        // Gives Extensions a chance to run logic prior to the minting of bought shares\r\n        __preBuySharesHook(_buyer, _investmentAmount, _minSharesQuantity, _preBuySharesGav);\r\n\r\n        // Calculate the amount of shares to issue with the investment amount\r\n        uint256 sharesIssued = _investmentAmount.mul(SHARES_UNIT).div(_sharePrice);\r\n\r\n        // Mint shares to the buyer\r\n        uint256 prevBuyerShares = ERC20(_vaultProxy).balanceOf(_buyer);\r\n        IVault(_vaultProxy).mintShares(_buyer, sharesIssued);\r\n\r\n        // Transfer the investment asset to the fund.\r\n        // Does not follow the checks-effects-interactions pattern, but it is preferred\r\n        // to have the final state of the VaultProxy prior to running __postBuySharesHook().\r\n        ERC20(_denominationAsset).safeTransferFrom(msg.sender, _vaultProxy, _investmentAmount);\r\n\r\n        // Gives Extensions a chance to run logic after shares are issued\r\n        __postBuySharesHook(_buyer, _investmentAmount, sharesIssued, _preBuySharesGav);\r\n\r\n        // The number of actual shares received may differ from shares issued due to\r\n        // how the PostBuyShares hooks are invoked by Extensions (i.e., fees)\r\n        sharesReceived_ = ERC20(_vaultProxy).balanceOf(_buyer).sub(prevBuyerShares);\r\n        require(\r\n            sharesReceived_ >= _minSharesQuantity,\r\n            \"__buyShares: Shares received < _minSharesQuantity\"\r\n        );\r\n\r\n        emit SharesBought(msg.sender, _buyer, _investmentAmount, sharesIssued, sharesReceived_);\r\n\r\n        return sharesReceived_;\r\n    }\r\n\r\n    /// @dev Helper for Extension actions after all __buyShares() calls are made\r\n    function __buySharesCompletedHook(\r\n        address _caller,\r\n        uint256[] memory _sharesReceivedAmounts,\r\n        uint256 _gav\r\n    ) private {\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            address(this),\r\n            IPolicyManager.PolicyHook.BuySharesCompleted,\r\n            abi.encode(_caller, _sharesReceivedAmounts, _gav)\r\n        );\r\n\r\n        IFeeManager(FEE_MANAGER).invokeHook(\r\n            IFeeManager.FeeHook.BuySharesCompleted,\r\n            abi.encode(_caller, _sharesReceivedAmounts),\r\n            _gav\r\n        );\r\n    }\r\n\r\n    /// @dev Helper for Extension actions before any __buyShares() calls are made\r\n    function __buySharesSetupHook(\r\n        address _caller,\r\n        uint256[] memory _investmentAmounts,\r\n        uint256 _gav\r\n    ) private {\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            address(this),\r\n            IPolicyManager.PolicyHook.BuySharesSetup,\r\n            abi.encode(_caller, _investmentAmounts, _gav)\r\n        );\r\n\r\n        IFeeManager(FEE_MANAGER).invokeHook(\r\n            IFeeManager.FeeHook.BuySharesSetup,\r\n            abi.encode(_caller, _investmentAmounts),\r\n            _gav\r\n        );\r\n    }\r\n\r\n    /// @dev Helper for Extension actions immediately prior to issuing shares.\r\n    /// This could be cleaned up so both Extensions take the same encoded args and handle GAV\r\n    /// in the same way, but there is not the obvious need for gas savings of recycling\r\n    /// the GAV value for the current policies as there is for the fees.\r\n    function __preBuySharesHook(\r\n        address _buyer,\r\n        uint256 _investmentAmount,\r\n        uint256 _minSharesQuantity,\r\n        uint256 _gav\r\n    ) private {\r\n        IFeeManager(FEE_MANAGER).invokeHook(\r\n            IFeeManager.FeeHook.PreBuyShares,\r\n            abi.encode(_buyer, _investmentAmount, _minSharesQuantity),\r\n            _gav\r\n        );\r\n\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            address(this),\r\n            IPolicyManager.PolicyHook.PreBuyShares,\r\n            abi.encode(_buyer, _investmentAmount, _minSharesQuantity, _gav)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper for Extension actions immediately after issuing shares.\r\n    /// Same comment applies from __preBuySharesHook() above.\r\n    function __postBuySharesHook(\r\n        address _buyer,\r\n        uint256 _investmentAmount,\r\n        uint256 _sharesIssued,\r\n        uint256 _preBuySharesGav\r\n    ) private {\r\n        uint256 gav = _preBuySharesGav.add(_investmentAmount);\r\n        IFeeManager(FEE_MANAGER).invokeHook(\r\n            IFeeManager.FeeHook.PostBuyShares,\r\n            abi.encode(_buyer, _investmentAmount, _sharesIssued),\r\n            gav\r\n        );\r\n\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            address(this),\r\n            IPolicyManager.PolicyHook.PostBuyShares,\r\n            abi.encode(_buyer, _investmentAmount, _sharesIssued, gav)\r\n        );\r\n    }\r\n\r\n    // REDEEM SHARES\r\n\r\n    /// @notice Redeem all of the sender's shares for a proportionate slice of the fund's assets\r\n    /// @return payoutAssets_ The assets paid out to the redeemer\r\n    /// @return payoutAmounts_ The amount of each asset paid out to the redeemer\r\n    /// @dev See __redeemShares() for further detail\r\n    function redeemShares()\r\n        external\r\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\r\n    {\r\n        return\r\n            __redeemShares(\r\n                msg.sender,\r\n                ERC20(vaultProxy).balanceOf(msg.sender),\r\n                new address[](0),\r\n                new address[](0)\r\n            );\r\n    }\r\n\r\n    /// @notice Redeem a specified quantity of the sender's shares for a proportionate slice of\r\n    /// the fund's assets, optionally specifying additional assets and assets to skip.\r\n    /// @param _sharesQuantity The quantity of shares to redeem\r\n    /// @param _additionalAssets Additional (non-tracked) assets to claim\r\n    /// @param _assetsToSkip Tracked assets to forfeit\r\n    /// @return payoutAssets_ The assets paid out to the redeemer\r\n    /// @return payoutAmounts_ The amount of each asset paid out to the redeemer\r\n    /// @dev Any claim to passed _assetsToSkip will be forfeited entirely. This should generally\r\n    /// only be exercised if a bad asset is causing redemption to fail.\r\n    function redeemSharesDetailed(\r\n        uint256 _sharesQuantity,\r\n        address[] calldata _additionalAssets,\r\n        address[] calldata _assetsToSkip\r\n    ) external returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_) {\r\n        return __redeemShares(msg.sender, _sharesQuantity, _additionalAssets, _assetsToSkip);\r\n    }\r\n\r\n    /// @dev Helper to parse an array of payout assets during redemption, taking into account\r\n    /// additional assets and assets to skip. _assetsToSkip ignores _additionalAssets.\r\n    /// All input arrays are assumed to be unique.\r\n    function __parseRedemptionPayoutAssets(\r\n        address[] memory _trackedAssets,\r\n        address[] memory _additionalAssets,\r\n        address[] memory _assetsToSkip\r\n    ) private pure returns (address[] memory payoutAssets_) {\r\n        address[] memory trackedAssetsToPayout = _trackedAssets.removeItems(_assetsToSkip);\r\n        if (_additionalAssets.length == 0) {\r\n            return trackedAssetsToPayout;\r\n        }\r\n\r\n        // Add additional assets. Duplicates of trackedAssets are ignored.\r\n        bool[] memory indexesToAdd = new bool[](_additionalAssets.length);\r\n        uint256 additionalItemsCount;\r\n        for (uint256 i; i < _additionalAssets.length; i++) {\r\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\r\n                indexesToAdd[i] = true;\r\n                additionalItemsCount++;\r\n            }\r\n        }\r\n        if (additionalItemsCount == 0) {\r\n            return trackedAssetsToPayout;\r\n        }\r\n\r\n        payoutAssets_ = new address[](trackedAssetsToPayout.length.add(additionalItemsCount));\r\n        for (uint256 i; i < trackedAssetsToPayout.length; i++) {\r\n            payoutAssets_[i] = trackedAssetsToPayout[i];\r\n        }\r\n        uint256 payoutAssetsIndex = trackedAssetsToPayout.length;\r\n        for (uint256 i; i < _additionalAssets.length; i++) {\r\n            if (indexesToAdd[i]) {\r\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\r\n                payoutAssetsIndex++;\r\n            }\r\n        }\r\n\r\n        return payoutAssets_;\r\n    }\r\n\r\n    /// @dev Helper for system actions immediately prior to redeeming shares.\r\n    /// Policy validation is not currently allowed on redemption, to ensure continuous redeemability.\r\n    function __preRedeemSharesHook(address _redeemer, uint256 _sharesQuantity)\r\n        private\r\n        allowsPermissionedVaultAction\r\n    {\r\n        try\r\n            IFeeManager(FEE_MANAGER).invokeHook(\r\n                IFeeManager.FeeHook.PreRedeemShares,\r\n                abi.encode(_redeemer, _sharesQuantity),\r\n                0\r\n            )\r\n         {} catch (bytes memory reason) {\r\n            emit PreRedeemSharesHookFailed(reason, _redeemer, _sharesQuantity);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to redeem shares.\r\n    /// This function should never fail without a way to bypass the failure, which is assured\r\n    /// through two mechanisms:\r\n    /// 1. The FeeManager is called with the try/catch pattern to assure that calls to it\r\n    /// can never block redemption.\r\n    /// 2. If a token fails upon transfer(), that token can be skipped (and its balance forfeited)\r\n    /// by explicitly specifying _assetsToSkip.\r\n    /// Because of these assurances, shares should always be redeemable, with the exception\r\n    /// of the timelock period on shares actions that must be respected.\r\n    function __redeemShares(\r\n        address _redeemer,\r\n        uint256 _sharesQuantity,\r\n        address[] memory _additionalAssets,\r\n        address[] memory _assetsToSkip\r\n    )\r\n        private\r\n        locksReentrance\r\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\r\n    {\r\n        require(_sharesQuantity > 0, \"__redeemShares: _sharesQuantity must be >0\");\r\n        require(\r\n            _additionalAssets.isUniqueSet(),\r\n            \"__redeemShares: _additionalAssets contains duplicates\"\r\n        );\r\n        require(_assetsToSkip.isUniqueSet(), \"__redeemShares: _assetsToSkip contains duplicates\");\r\n\r\n        IVault vaultProxyContract = IVault(vaultProxy);\r\n\r\n        // Only apply the sharesActionTimelock when a migration is not pending\r\n        if (!IDispatcher(DISPATCHER).hasMigrationRequest(address(vaultProxyContract))) {\r\n            __assertSharesActionNotTimelocked(_redeemer);\r\n            acctToLastSharesAction[_redeemer] = block.timestamp;\r\n        }\r\n\r\n        // When a fund is paused, settling fees will be skipped\r\n        if (!__fundIsPaused()) {\r\n            // Note that if a fee with `SettlementType.Direct` is charged here (i.e., not `Mint`),\r\n            // then those fee shares will be transferred from the user's balance rather\r\n            // than reallocated from the sharesQuantity being redeemed.\r\n            __preRedeemSharesHook(_redeemer, _sharesQuantity);\r\n        }\r\n\r\n        // Check the shares quantity against the user's balance after settling fees\r\n        ERC20 sharesContract = ERC20(address(vaultProxyContract));\r\n        require(\r\n            _sharesQuantity <= sharesContract.balanceOf(_redeemer),\r\n            \"__redeemShares: Insufficient shares\"\r\n        );\r\n\r\n        // Parse the payout assets given optional params to add or skip assets.\r\n        // Note that there is no validation that the _additionalAssets are known assets to\r\n        // the protocol. This means that the redeemer could specify a malicious asset,\r\n        // but since all state-changing, user-callable functions on this contract share the\r\n        // non-reentrant modifier, there is nowhere to perform a reentrancy attack.\r\n        payoutAssets_ = __parseRedemptionPayoutAssets(\r\n            vaultProxyContract.getTrackedAssets(),\r\n            _additionalAssets,\r\n            _assetsToSkip\r\n        );\r\n        require(payoutAssets_.length > 0, \"__redeemShares: No payout assets\");\r\n\r\n        // Destroy the shares.\r\n        // Must get the shares supply before doing so.\r\n        uint256 sharesSupply = sharesContract.totalSupply();\r\n        vaultProxyContract.burnShares(_redeemer, _sharesQuantity);\r\n\r\n        // Calculate and transfer payout asset amounts due to redeemer\r\n        payoutAmounts_ = new uint256[](payoutAssets_.length);\r\n        address denominationAssetCopy = denominationAsset;\r\n        for (uint256 i; i < payoutAssets_.length; i++) {\r\n            uint256 assetBalance = __finalizeIfSynthAndGetAssetBalance(\r\n                address(vaultProxyContract),\r\n                payoutAssets_[i],\r\n                true\r\n            );\r\n\r\n            // If all remaining shares are being redeemed, the logic changes slightly\r\n            if (_sharesQuantity == sharesSupply) {\r\n                payoutAmounts_[i] = assetBalance;\r\n                // Remove every tracked asset, except the denomination asset\r\n                if (payoutAssets_[i] != denominationAssetCopy) {\r\n                    vaultProxyContract.removeTrackedAsset(payoutAssets_[i]);\r\n                }\r\n            } else {\r\n                payoutAmounts_[i] = assetBalance.mul(_sharesQuantity).div(sharesSupply);\r\n            }\r\n\r\n            // Transfer payout asset to redeemer\r\n            if (payoutAmounts_[i] > 0) {\r\n                vaultProxyContract.withdrawAssetTo(payoutAssets_[i], _redeemer, payoutAmounts_[i]);\r\n            }\r\n        }\r\n\r\n        emit SharesRedeemed(_redeemer, _sharesQuantity, payoutAssets_, payoutAmounts_);\r\n\r\n        return (payoutAssets_, payoutAmounts_);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `denominationAsset` variable\r\n    /// @return denominationAsset_ The `denominationAsset` variable value\r\n    function getDenominationAsset() external view override returns (address denominationAsset_) {\r\n        return denominationAsset;\r\n    }\r\n\r\n    /// @notice Gets the routes for the various contracts used by all funds\r\n    /// @return dispatcher_ The `DISPATCHER` variable value\r\n    /// @return feeManager_ The `FEE_MANAGER` variable value\r\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\r\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\r\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\r\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\r\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\r\n    function getLibRoutes()\r\n        external\r\n        view\r\n        returns (\r\n            address dispatcher_,\r\n            address feeManager_,\r\n            address fundDeployer_,\r\n            address integrationManager_,\r\n            address policyManager_,\r\n            address primitivePriceFeed_,\r\n            address valueInterpreter_\r\n        )\r\n    {\r\n        return (\r\n            DISPATCHER,\r\n            FEE_MANAGER,\r\n            FUND_DEPLOYER,\r\n            INTEGRATION_MANAGER,\r\n            POLICY_MANAGER,\r\n            PRIMITIVE_PRICE_FEED,\r\n            VALUE_INTERPRETER\r\n        );\r\n    }\r\n\r\n    /// @notice Gets the `overridePause` variable\r\n    /// @return overridePause_ The `overridePause` variable value\r\n    function getOverridePause() external view returns (bool overridePause_) {\r\n        return overridePause;\r\n    }\r\n\r\n    /// @notice Gets the `sharesActionTimelock` variable\r\n    /// @return sharesActionTimelock_ The `sharesActionTimelock` variable value\r\n    function getSharesActionTimelock() external view returns (uint256 sharesActionTimelock_) {\r\n        return sharesActionTimelock;\r\n    }\r\n\r\n    /// @notice Gets the `vaultProxy` variable\r\n    /// @return vaultProxy_ The `vaultProxy` variable value\r\n    function getVaultProxy() external view override returns (address vaultProxy_) {\r\n        return vaultProxy;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"../../core/fund/comptroller/IComptroller.sol\";\r\nimport \"../../core/fund/vault/IVault.sol\";\r\nimport \"../../utils/AddressArrayLib.sol\";\r\nimport \"../utils/ExtensionBase.sol\";\r\nimport \"../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../utils/PermissionedVaultActionMixin.sol\";\r\nimport \"./IFee.sol\";\r\nimport \"./IFeeManager.sol\";\r\n\r\n/// @title FeeManager Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Manages fees for funds\r\ncontract FeeManager is\r\n    IFeeManager,\r\n    ExtensionBase,\r\n    FundDeployerOwnerMixin,\r\n    PermissionedVaultActionMixin\r\n{\r\n    using AddressArrayLib for address[];\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using SafeMath for uint256;\r\n\r\n    event AllSharesOutstandingForcePaidForFund(\r\n        address indexed comptrollerProxy,\r\n        address payee,\r\n        uint256 sharesDue\r\n    );\r\n\r\n    event FeeDeregistered(address indexed fee, string indexed identifier);\r\n\r\n    event FeeEnabledForFund(\r\n        address indexed comptrollerProxy,\r\n        address indexed fee,\r\n        bytes settingsData\r\n    );\r\n\r\n    event FeeRegistered(\r\n        address indexed fee,\r\n        string indexed identifier,\r\n        FeeHook[] implementedHooksForSettle,\r\n        FeeHook[] implementedHooksForUpdate,\r\n        bool usesGavOnSettle,\r\n        bool usesGavOnUpdate\r\n    );\r\n\r\n    event FeeSettledForFund(\r\n        address indexed comptrollerProxy,\r\n        address indexed fee,\r\n        SettlementType indexed settlementType,\r\n        address payer,\r\n        address payee,\r\n        uint256 sharesDue\r\n    );\r\n\r\n    event SharesOutstandingPaidForFund(\r\n        address indexed comptrollerProxy,\r\n        address indexed fee,\r\n        uint256 sharesDue\r\n    );\r\n\r\n    event FeesRecipientSetForFund(\r\n        address indexed comptrollerProxy,\r\n        address prevFeesRecipient,\r\n        address nextFeesRecipient\r\n    );\r\n\r\n    EnumerableSet.AddressSet private registeredFees;\r\n    mapping(address => bool) private feeToUsesGavOnSettle;\r\n    mapping(address => bool) private feeToUsesGavOnUpdate;\r\n    mapping(address => mapping(FeeHook => bool)) private feeToHookToImplementsSettle;\r\n    mapping(address => mapping(FeeHook => bool)) private feeToHookToImplementsUpdate;\r\n\r\n    mapping(address => address[]) private comptrollerProxyToFees;\r\n    mapping(address => mapping(address => uint256))\r\n        private comptrollerProxyToFeeToSharesOutstanding;\r\n\r\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Activate already-configured fees for use in the calling fund\r\n    function activateForFund(bool) external override {\r\n        address vaultProxy = __setValidatedVaultProxy(msg.sender);\r\n\r\n        address[] memory enabledFees = comptrollerProxyToFees[msg.sender];\r\n        for (uint256 i; i < enabledFees.length; i++) {\r\n            IFee(enabledFees[i]).activateForFund(msg.sender, vaultProxy);\r\n        }\r\n    }\r\n\r\n    /// @notice Deactivate fees for a fund\r\n    /// @dev msg.sender is validated during __invokeHook()\r\n    function deactivateForFund() external override {\r\n        // Settle continuous fees one last time, but without calling Fee.update()\r\n        __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \"\", 0, false);\r\n\r\n        // Force payout of remaining shares outstanding\r\n        __forcePayoutAllSharesOutstanding(msg.sender);\r\n\r\n        // Clean up storage\r\n        __deleteFundStorage(msg.sender);\r\n    }\r\n\r\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\r\n    /// @param _actionId An ID representing the desired action\r\n    /// @param _callArgs Encoded arguments specific to the _actionId\r\n    /// @dev This is the only way to call a function on this contract that updates VaultProxy state.\r\n    /// For both of these actions, any caller is allowed, so we don't use the caller param.\r\n    function receiveCallFromComptroller(\r\n        address,\r\n        uint256 _actionId,\r\n        bytes calldata _callArgs\r\n    ) external override {\r\n        if (_actionId == 0) {\r\n            // Settle and update all continuous fees\r\n            __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \"\", 0, true);\r\n        } else if (_actionId == 1) {\r\n            __payoutSharesOutstandingForFees(msg.sender, _callArgs);\r\n        } else {\r\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\r\n        }\r\n    }\r\n\r\n    /// @notice Enable and configure fees for use in the calling fund\r\n    /// @param _configData Encoded config data\r\n    /// @dev Caller is expected to be a valid ComptrollerProxy, but there isn't a need to validate.\r\n    /// The order of `fees` determines the order in which fees of the same FeeHook will be applied.\r\n    /// It is recommended to run ManagementFee before PerformanceFee in order to achieve precise\r\n    /// PerformanceFee calcs.\r\n    function setConfigForFund(bytes calldata _configData) external override {\r\n        (address[] memory fees, bytes[] memory settingsData) = abi.decode(\r\n            _configData,\r\n            (address[], bytes[])\r\n        );\r\n\r\n        // Sanity checks\r\n        require(\r\n            fees.length == settingsData.length,\r\n            \"setConfigForFund: fees and settingsData array lengths unequal\"\r\n        );\r\n        require(fees.isUniqueSet(), \"setConfigForFund: fees cannot include duplicates\");\r\n\r\n        // Enable each fee with settings\r\n        for (uint256 i; i < fees.length; i++) {\r\n            require(isRegisteredFee(fees[i]), \"setConfigForFund: Fee is not registered\");\r\n\r\n            // Set fund config on fee\r\n            IFee(fees[i]).addFundSettings(msg.sender, settingsData[i]);\r\n\r\n            // Enable fee for fund\r\n            comptrollerProxyToFees[msg.sender].push(fees[i]);\r\n\r\n            emit FeeEnabledForFund(msg.sender, fees[i], settingsData[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows all fees for a particular FeeHook to implement settle() and update() logic\r\n    /// @param _hook The FeeHook to invoke\r\n    /// @param _settlementData The encoded settlement parameters specific to the FeeHook\r\n    /// @param _gav The GAV for a fund if known in the invocating code, otherwise 0\r\n    function invokeHook(\r\n        FeeHook _hook,\r\n        bytes calldata _settlementData,\r\n        uint256 _gav\r\n    ) external override {\r\n        __invokeHook(msg.sender, _hook, _settlementData, _gav, true);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to destroy local storage to get gas refund,\r\n    /// and to prevent further calls to fee manager\r\n    function __deleteFundStorage(address _comptrollerProxy) private {\r\n        delete comptrollerProxyToFees[_comptrollerProxy];\r\n        delete comptrollerProxyToVaultProxy[_comptrollerProxy];\r\n    }\r\n\r\n    /// @dev Helper to force the payout of shares outstanding across all fees.\r\n    /// For the current release, all shares in the VaultProxy are assumed to be\r\n    /// shares outstanding from fees. If not, then they were sent there by mistake\r\n    /// and are otherwise unrecoverable. We can therefore take the VaultProxy's\r\n    /// shares balance as the totalSharesOutstanding to payout to the fund owner.\r\n    function __forcePayoutAllSharesOutstanding(address _comptrollerProxy) private {\r\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\r\n\r\n        uint256 totalSharesOutstanding = ERC20(vaultProxy).balanceOf(vaultProxy);\r\n        if (totalSharesOutstanding == 0) {\r\n            return;\r\n        }\r\n\r\n        // Destroy any shares outstanding storage\r\n        address[] memory fees = comptrollerProxyToFees[_comptrollerProxy];\r\n        for (uint256 i; i < fees.length; i++) {\r\n            delete comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]];\r\n        }\r\n\r\n        // Distribute all shares outstanding to the fees recipient\r\n        address payee = IVault(vaultProxy).getOwner();\r\n        __transferShares(_comptrollerProxy, vaultProxy, payee, totalSharesOutstanding);\r\n\r\n        emit AllSharesOutstandingForcePaidForFund(\r\n            _comptrollerProxy,\r\n            payee,\r\n            totalSharesOutstanding\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to get the canonical value of GAV if not yet set and required by fee\r\n    function __getGavAsNecessary(\r\n        address _comptrollerProxy,\r\n        address _fee,\r\n        uint256 _gavOrZero\r\n    ) private returns (uint256 gav_) {\r\n        if (_gavOrZero == 0 && feeUsesGavOnUpdate(_fee)) {\r\n            // Assumes that any fee that requires GAV would need to revert if invalid or not final\r\n            bool gavIsValid;\r\n            (gav_, gavIsValid) = IComptroller(_comptrollerProxy).calcGav(true);\r\n            require(gavIsValid, \"__getGavAsNecessary: Invalid GAV\");\r\n        } else {\r\n            gav_ = _gavOrZero;\r\n        }\r\n\r\n        return gav_;\r\n    }\r\n\r\n    /// @dev Helper to run settle() on all enabled fees for a fund that implement a given hook, and then to\r\n    /// optionally run update() on the same fees. This order allows fees an opportunity to update\r\n    /// their local state after all VaultProxy state transitions (i.e., minting, burning,\r\n    /// transferring shares) have finished. To optimize for the expensive operation of calculating\r\n    /// GAV, once one fee requires GAV, we recycle that `gav` value for subsequent fees.\r\n    /// Assumes that _gav is either 0 or has already been validated.\r\n    function __invokeHook(\r\n        address _comptrollerProxy,\r\n        FeeHook _hook,\r\n        bytes memory _settlementData,\r\n        uint256 _gavOrZero,\r\n        bool _updateFees\r\n    ) private {\r\n        address[] memory fees = comptrollerProxyToFees[_comptrollerProxy];\r\n        if (fees.length == 0) {\r\n            return;\r\n        }\r\n\r\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\r\n\r\n        // This check isn't strictly necessary, but its cost is insignificant,\r\n        // and helps to preserve data integrity.\r\n        require(vaultProxy != address(0), \"__invokeHook: Fund is not active\");\r\n\r\n        // First, allow all fees to implement settle()\r\n        uint256 gav = __settleFees(\r\n            _comptrollerProxy,\r\n            vaultProxy,\r\n            fees,\r\n            _hook,\r\n            _settlementData,\r\n            _gavOrZero\r\n        );\r\n\r\n        // Second, allow fees to implement update()\r\n        // This function does not allow any further altering of VaultProxy state\r\n        // (i.e., burning, minting, or transferring shares)\r\n        if (_updateFees) {\r\n            __updateFees(_comptrollerProxy, vaultProxy, fees, _hook, _settlementData, gav);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to payout the shares outstanding for the specified fees.\r\n    /// Does not call settle() on fees.\r\n    /// Only callable via ComptrollerProxy.callOnExtension().\r\n    function __payoutSharesOutstandingForFees(address _comptrollerProxy, bytes memory _callArgs)\r\n        private\r\n    {\r\n        address[] memory fees = abi.decode(_callArgs, (address[]));\r\n        address vaultProxy = getVaultProxyForFund(msg.sender);\r\n\r\n        uint256 sharesOutstandingDue;\r\n        for (uint256 i; i < fees.length; i++) {\r\n            if (!IFee(fees[i]).payout(_comptrollerProxy, vaultProxy)) {\r\n                continue;\r\n            }\r\n\r\n\r\n                uint256 sharesOutstandingForFee\r\n             = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]];\r\n            if (sharesOutstandingForFee == 0) {\r\n                continue;\r\n            }\r\n\r\n            sharesOutstandingDue = sharesOutstandingDue.add(sharesOutstandingForFee);\r\n\r\n            // Delete shares outstanding and distribute from VaultProxy to the fees recipient\r\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][fees[i]] = 0;\r\n\r\n            emit SharesOutstandingPaidForFund(_comptrollerProxy, fees[i], sharesOutstandingForFee);\r\n        }\r\n\r\n        if (sharesOutstandingDue > 0) {\r\n            __transferShares(\r\n                _comptrollerProxy,\r\n                vaultProxy,\r\n                IVault(vaultProxy).getOwner(),\r\n                sharesOutstandingDue\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to settle a fee\r\n    function __settleFee(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        address _fee,\r\n        FeeHook _hook,\r\n        bytes memory _settlementData,\r\n        uint256 _gav\r\n    ) private {\r\n        (SettlementType settlementType, address payer, uint256 sharesDue) = IFee(_fee).settle(\r\n            _comptrollerProxy,\r\n            _vaultProxy,\r\n            _hook,\r\n            _settlementData,\r\n            _gav\r\n        );\r\n        if (settlementType == SettlementType.None) {\r\n            return;\r\n        }\r\n\r\n        address payee;\r\n        if (settlementType == SettlementType.Direct) {\r\n            payee = IVault(_vaultProxy).getOwner();\r\n            __transferShares(_comptrollerProxy, payer, payee, sharesDue);\r\n        } else if (settlementType == SettlementType.Mint) {\r\n            payee = IVault(_vaultProxy).getOwner();\r\n            __mintShares(_comptrollerProxy, payee, sharesDue);\r\n        } else if (settlementType == SettlementType.Burn) {\r\n            __burnShares(_comptrollerProxy, payer, sharesDue);\r\n        } else if (settlementType == SettlementType.MintSharesOutstanding) {\r\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\r\n                .add(sharesDue);\r\n\r\n            payee = _vaultProxy;\r\n            __mintShares(_comptrollerProxy, payee, sharesDue);\r\n        } else if (settlementType == SettlementType.BurnSharesOutstanding) {\r\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\r\n                .sub(sharesDue);\r\n\r\n            payer = _vaultProxy;\r\n            __burnShares(_comptrollerProxy, payer, sharesDue);\r\n        } else {\r\n            revert(\"__settleFee: Invalid SettlementType\");\r\n        }\r\n\r\n        emit FeeSettledForFund(_comptrollerProxy, _fee, settlementType, payer, payee, sharesDue);\r\n    }\r\n\r\n    /// @dev Helper to settle fees that implement a given fee hook\r\n    function __settleFees(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        address[] memory _fees,\r\n        FeeHook _hook,\r\n        bytes memory _settlementData,\r\n        uint256 _gavOrZero\r\n    ) private returns (uint256 gav_) {\r\n        gav_ = _gavOrZero;\r\n\r\n        for (uint256 i; i < _fees.length; i++) {\r\n            if (!feeSettlesOnHook(_fees[i], _hook)) {\r\n                continue;\r\n            }\r\n\r\n            gav_ = __getGavAsNecessary(_comptrollerProxy, _fees[i], gav_);\r\n\r\n            __settleFee(_comptrollerProxy, _vaultProxy, _fees[i], _hook, _settlementData, gav_);\r\n        }\r\n\r\n        return gav_;\r\n    }\r\n\r\n    /// @dev Helper to update fees that implement a given fee hook\r\n    function __updateFees(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        address[] memory _fees,\r\n        FeeHook _hook,\r\n        bytes memory _settlementData,\r\n        uint256 _gavOrZero\r\n    ) private {\r\n        uint256 gav = _gavOrZero;\r\n\r\n        for (uint256 i; i < _fees.length; i++) {\r\n            if (!feeUpdatesOnHook(_fees[i], _hook)) {\r\n                continue;\r\n            }\r\n\r\n            gav = __getGavAsNecessary(_comptrollerProxy, _fees[i], gav);\r\n\r\n            IFee(_fees[i]).update(_comptrollerProxy, _vaultProxy, _hook, _settlementData, gav);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // FEES REGISTRY //\r\n    ///////////////////\r\n\r\n    /// @notice Remove fees from the list of registered fees\r\n    /// @param _fees Addresses of fees to be deregistered\r\n    function deregisterFees(address[] calldata _fees) external onlyFundDeployerOwner {\r\n        require(_fees.length > 0, \"deregisterFees: _fees cannot be empty\");\r\n\r\n        for (uint256 i; i < _fees.length; i++) {\r\n            require(isRegisteredFee(_fees[i]), \"deregisterFees: fee is not registered\");\r\n\r\n            registeredFees.remove(_fees[i]);\r\n\r\n            emit FeeDeregistered(_fees[i], IFee(_fees[i]).identifier());\r\n        }\r\n    }\r\n\r\n    /// @notice Add fees to the list of registered fees\r\n    /// @param _fees Addresses of fees to be registered\r\n    /// @dev Stores the hooks that a fee implements and whether each implementation uses GAV,\r\n    /// which fronts the gas for calls to check if a hook is implemented, and guarantees\r\n    /// that these hook implementation return values do not change post-registration.\r\n    function registerFees(address[] calldata _fees) external onlyFundDeployerOwner {\r\n        require(_fees.length > 0, \"registerFees: _fees cannot be empty\");\r\n\r\n        for (uint256 i; i < _fees.length; i++) {\r\n            require(!isRegisteredFee(_fees[i]), \"registerFees: fee already registered\");\r\n\r\n            registeredFees.add(_fees[i]);\r\n\r\n            IFee feeContract = IFee(_fees[i]);\r\n            (\r\n                FeeHook[] memory implementedHooksForSettle,\r\n                FeeHook[] memory implementedHooksForUpdate,\r\n                bool usesGavOnSettle,\r\n                bool usesGavOnUpdate\r\n            ) = feeContract.implementedHooks();\r\n\r\n            // Stores the hooks for which each fee implements settle() and update()\r\n            for (uint256 j; j < implementedHooksForSettle.length; j++) {\r\n                feeToHookToImplementsSettle[_fees[i]][implementedHooksForSettle[j]] = true;\r\n            }\r\n            for (uint256 j; j < implementedHooksForUpdate.length; j++) {\r\n                feeToHookToImplementsUpdate[_fees[i]][implementedHooksForUpdate[j]] = true;\r\n            }\r\n\r\n            // Stores whether each fee requires GAV during its implementations for settle() and update()\r\n            if (usesGavOnSettle) {\r\n                feeToUsesGavOnSettle[_fees[i]] = true;\r\n            }\r\n            if (usesGavOnUpdate) {\r\n                feeToUsesGavOnUpdate[_fees[i]] = true;\r\n            }\r\n\r\n            emit FeeRegistered(\r\n                _fees[i],\r\n                feeContract.identifier(),\r\n                implementedHooksForSettle,\r\n                implementedHooksForUpdate,\r\n                usesGavOnSettle,\r\n                usesGavOnUpdate\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Get a list of enabled fees for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return enabledFees_ An array of enabled fee addresses\r\n    function getEnabledFeesForFund(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (address[] memory enabledFees_)\r\n    {\r\n        return comptrollerProxyToFees[_comptrollerProxy];\r\n    }\r\n\r\n    /// @notice Get the amount of shares outstanding for a particular fee for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _fee The fee address\r\n    /// @return sharesOutstanding_ The amount of shares outstanding\r\n    function getFeeSharesOutstandingForFund(address _comptrollerProxy, address _fee)\r\n        external\r\n        view\r\n        returns (uint256 sharesOutstanding_)\r\n    {\r\n        return comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\r\n    }\r\n\r\n    /// @notice Get all registered fees\r\n    /// @return registeredFees_ A list of all registered fee addresses\r\n    function getRegisteredFees() external view returns (address[] memory registeredFees_) {\r\n        registeredFees_ = new address[](registeredFees.length());\r\n        for (uint256 i; i < registeredFees_.length; i++) {\r\n            registeredFees_[i] = registeredFees.at(i);\r\n        }\r\n\r\n        return registeredFees_;\r\n    }\r\n\r\n    /// @notice Checks if a fee implements settle() on a particular hook\r\n    /// @param _fee The address of the fee to check\r\n    /// @param _hook The FeeHook to check\r\n    /// @return settlesOnHook_ True if the fee settles on the given hook\r\n    function feeSettlesOnHook(address _fee, FeeHook _hook)\r\n        public\r\n        view\r\n        returns (bool settlesOnHook_)\r\n    {\r\n        return feeToHookToImplementsSettle[_fee][_hook];\r\n    }\r\n\r\n    /// @notice Checks if a fee implements update() on a particular hook\r\n    /// @param _fee The address of the fee to check\r\n    /// @param _hook The FeeHook to check\r\n    /// @return updatesOnHook_ True if the fee updates on the given hook\r\n    function feeUpdatesOnHook(address _fee, FeeHook _hook)\r\n        public\r\n        view\r\n        returns (bool updatesOnHook_)\r\n    {\r\n        return feeToHookToImplementsUpdate[_fee][_hook];\r\n    }\r\n\r\n    /// @notice Checks if a fee uses GAV in its settle() implementation\r\n    /// @param _fee The address of the fee to check\r\n    /// @return usesGav_ True if the fee uses GAV during settle() implementation\r\n    function feeUsesGavOnSettle(address _fee) public view returns (bool usesGav_) {\r\n        return feeToUsesGavOnSettle[_fee];\r\n    }\r\n\r\n    /// @notice Checks if a fee uses GAV in its update() implementation\r\n    /// @param _fee The address of the fee to check\r\n    /// @return usesGav_ True if the fee uses GAV during update() implementation\r\n    function feeUsesGavOnUpdate(address _fee) public view returns (bool usesGav_) {\r\n        return feeToUsesGavOnUpdate[_fee];\r\n    }\r\n\r\n    /// @notice Check whether a fee is registered\r\n    /// @param _fee The address of the fee to check\r\n    /// @return isRegisteredFee_ True if the fee is registered\r\n    function isRegisteredFee(address _fee) public view returns (bool isRegisteredFee_) {\r\n        return registeredFees.contains(_fee);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/IExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IExtension Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for all extensions\r\ninterface IExtension {\r\n    function activateForFund(bool _isMigration) external;\r\n\r\n    function deactivateForFund() external;\r\n\r\n    function receiveCallFromComptroller(\r\n        address _comptrollerProxy,\r\n        uint256 _actionId,\r\n        bytes calldata _callArgs\r\n    ) external;\r\n\r\n    function setConfigForFund(bytes calldata _configData) external;\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/IPolicyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title PolicyManager Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Interface for the PolicyManager\r\ninterface IPolicyManager {\r\n    enum PolicyHook {\r\n        BuySharesSetup,\r\n        PreBuyShares,\r\n        PostBuyShares,\r\n        BuySharesCompleted,\r\n        PreCallOnIntegration,\r\n        PostCallOnIntegration\r\n    }\r\n\r\n    function validatePolicies(\r\n        address,\r\n        PolicyHook,\r\n        bytes calldata\r\n    ) external;\r\n}\r\n"
    },
    "contracts/release/utils/AssetFinalityResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol\";\r\nimport \"../interfaces/ISynthetixAddressResolver.sol\";\r\nimport \"../interfaces/ISynthetixExchanger.sol\";\r\n\r\n/// @title AssetFinalityResolver Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A contract that helps achieve asset finality\r\nabstract contract AssetFinalityResolver {\r\n    address internal immutable SYNTHETIX_ADDRESS_RESOLVER;\r\n    address internal immutable SYNTHETIX_PRICE_FEED;\r\n\r\n    constructor(address _synthetixPriceFeed, address _synthetixAddressResolver) public {\r\n        SYNTHETIX_ADDRESS_RESOLVER = _synthetixAddressResolver;\r\n        SYNTHETIX_PRICE_FEED = _synthetixPriceFeed;\r\n    }\r\n\r\n    /// @dev Helper to finalize a Synth balance at a given target address and return its balance\r\n    function __finalizeIfSynthAndGetAssetBalance(\r\n        address _target,\r\n        address _asset,\r\n        bool _requireFinality\r\n    ) internal returns (uint256 assetBalance_) {\r\n        bytes32 currencyKey = SynthetixPriceFeed(SYNTHETIX_PRICE_FEED).getCurrencyKeyForSynth(\r\n            _asset\r\n        );\r\n        if (currencyKey != 0) {\r\n            address synthetixExchanger = ISynthetixAddressResolver(SYNTHETIX_ADDRESS_RESOLVER)\r\n                .requireAndGetAddress(\r\n                \"Exchanger\",\r\n                \"finalizeAndGetAssetBalance: Missing Exchanger\"\r\n            );\r\n            try ISynthetixExchanger(synthetixExchanger).settle(_target, currencyKey)  {} catch {\r\n                require(!_requireFinality, \"finalizeAndGetAssetBalance: Cannot settle Synth\");\r\n            }\r\n        }\r\n\r\n        return ERC20(_asset).balanceOf(_target);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable\r\n    /// @return synthetixAddressResolver_ The `SYNTHETIX_ADDRESS_RESOLVER` variable value\r\n    function getSynthetixAddressResolver()\r\n        external\r\n        view\r\n        returns (address synthetixAddressResolver_)\r\n    {\r\n        return SYNTHETIX_ADDRESS_RESOLVER;\r\n    }\r\n\r\n    /// @notice Gets the `SYNTHETIX_PRICE_FEED` variable\r\n    /// @return synthetixPriceFeed_ The `SYNTHETIX_PRICE_FEED` variable value\r\n    function getSynthetixPriceFeed() external view returns (address synthetixPriceFeed_) {\r\n        return SYNTHETIX_PRICE_FEED;\r\n    }\r\n}\r\n"
    },
    "contracts/release/core/fund/comptroller/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IComptroller Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IComptroller {\r\n    enum VaultAction {\r\n        None,\r\n        BurnShares,\r\n        MintShares,\r\n        TransferShares,\r\n        ApproveAssetSpender,\r\n        WithdrawAssetTo,\r\n        AddTrackedAsset,\r\n        RemoveTrackedAsset\r\n    }\r\n\r\n    function activate(address, bool) external;\r\n\r\n    function calcGav(bool) external returns (uint256, bool);\r\n\r\n    function calcGrossShareValue(bool) external returns (uint256, bool);\r\n\r\n    function callOnExtension(\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external;\r\n\r\n    function configureExtensions(bytes calldata, bytes calldata) external;\r\n\r\n    function destruct() external;\r\n\r\n    function getDenominationAsset() external view returns (address);\r\n\r\n    function getVaultProxy() external view returns (address);\r\n\r\n    function init(address, uint256) external;\r\n\r\n    function permissionedVaultAction(VaultAction, bytes calldata) external;\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../../../../interfaces/ISynthetix.sol\";\r\nimport \"../../../../interfaces/ISynthetixAddressResolver.sol\";\r\nimport \"../../../../interfaces/ISynthetixExchangeRates.sol\";\r\nimport \"../../../../interfaces/ISynthetixProxyERC20.sol\";\r\nimport \"../../../../interfaces/ISynthetixSynth.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title SynthetixPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A price feed that uses Synthetix oracles as price sources\r\ncontract SynthetixPriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\r\n    using SafeMath for uint256;\r\n\r\n    event SynthAdded(address indexed synth, bytes32 currencyKey);\r\n\r\n    event SynthCurrencyKeyUpdated(\r\n        address indexed synth,\r\n        bytes32 prevCurrencyKey,\r\n        bytes32 nextCurrencyKey\r\n    );\r\n\r\n    uint256 private constant SYNTH_UNIT = 10**18;\r\n    address private immutable ADDRESS_RESOLVER;\r\n    address private immutable SUSD;\r\n\r\n    mapping(address => bytes32) private synthToCurrencyKey;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address _addressResolver,\r\n        address _sUSD,\r\n        address[] memory _synths\r\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\r\n        ADDRESS_RESOLVER = _addressResolver;\r\n        SUSD = _sUSD;\r\n\r\n        if (_sUSD != address(0)) {\r\n            address[] memory sUSDSynths = new address[](1);\r\n            sUSDSynths[0] = _sUSD;\r\n            __addSynths(sUSDSynths);\r\n        }\r\n        __addSynths(_synths);\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = SUSD;\r\n        underlyingAmounts_ = new uint256[](1);\r\n\r\n        bytes32 currencyKey = getCurrencyKeyForSynth(_derivative);\r\n        require(currencyKey != 0, \"calcUnderlyingValues: _derivative is not supported\");\r\n\r\n        address exchangeRates = ISynthetixAddressResolver(ADDRESS_RESOLVER).requireAndGetAddress(\r\n            \"ExchangeRates\",\r\n            \"calcUnderlyingValues: Missing ExchangeRates\"\r\n        );\r\n\r\n        (uint256 rate, bool isInvalid) = ISynthetixExchangeRates(exchangeRates).rateAndInvalid(\r\n            currencyKey\r\n        );\r\n        require(!isInvalid, \"calcUnderlyingValues: _derivative rate is not valid\");\r\n\r\n        underlyingAmounts_[0] = _derivativeAmount.mul(rate).div(SYNTH_UNIT);\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks whether an asset is a supported primitive of the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is a supported primitive\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return getCurrencyKeyForSynth(_asset) != 0;\r\n    }\r\n\r\n    /////////////////////\r\n    // SYNTHS REGISTRY //\r\n    /////////////////////\r\n\r\n    /// @notice Adds Synths to the price feed\r\n    /// @param _synths Synths to add\r\n    function addSynths(address[] calldata _synths) external onlyFundDeployerOwner {\r\n        require(_synths.length > 0, \"addSynths: Empty _synths\");\r\n\r\n        __addSynths(_synths);\r\n    }\r\n\r\n    /// @notice Updates the cached currencyKey value for specified Synths\r\n    /// @param _synths Synths to update\r\n    /// @dev Anybody can call this function\r\n    function updateSynthCurrencyKeys(address[] calldata _synths) external {\r\n        require(_synths.length > 0, \"updateSynthCurrencyKeys: Empty _synths\");\r\n\r\n        for (uint256 i; i < _synths.length; i++) {\r\n            bytes32 prevCurrencyKey = synthToCurrencyKey[_synths[i]];\r\n            require(prevCurrencyKey != 0, \"updateSynthCurrencyKeys: Synth not set\");\r\n\r\n            bytes32 nextCurrencyKey = __getCurrencyKey(_synths[i]);\r\n            require(\r\n                nextCurrencyKey != prevCurrencyKey,\r\n                \"updateSynthCurrencyKeys: Synth has correct currencyKey\"\r\n            );\r\n\r\n            synthToCurrencyKey[_synths[i]] = nextCurrencyKey;\r\n\r\n            emit SynthCurrencyKeyUpdated(_synths[i], prevCurrencyKey, nextCurrencyKey);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to add Synths\r\n    function __addSynths(address[] memory _synths) private {\r\n        for (uint256 i; i < _synths.length; i++) {\r\n            require(synthToCurrencyKey[_synths[i]] == 0, \"__addSynths: Value already set\");\r\n\r\n            bytes32 currencyKey = __getCurrencyKey(_synths[i]);\r\n            require(currencyKey != 0, \"__addSynths: No currencyKey\");\r\n\r\n            synthToCurrencyKey[_synths[i]] = currencyKey;\r\n\r\n            emit SynthAdded(_synths[i], currencyKey);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to query a currencyKey from Synthetix\r\n    function __getCurrencyKey(address _synthProxy) private view returns (bytes32 currencyKey_) {\r\n        return ISynthetixSynth(ISynthetixProxyERC20(_synthProxy).target()).currencyKey();\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `ADDRESS_RESOLVER` variable\r\n    /// @return addressResolver_ The `ADDRESS_RESOLVER` variable value\r\n    function getAddressResolver() external view returns (address) {\r\n        return ADDRESS_RESOLVER;\r\n    }\r\n\r\n    /// @notice Gets the currencyKey for multiple given Synths\r\n    /// @return currencyKeys_ The currencyKey values\r\n    function getCurrencyKeysForSynths(address[] calldata _synths)\r\n        external\r\n        view\r\n        returns (bytes32[] memory currencyKeys_)\r\n    {\r\n        currencyKeys_ = new bytes32[](_synths.length);\r\n        for (uint256 i; i < _synths.length; i++) {\r\n            currencyKeys_[i] = synthToCurrencyKey[_synths[i]];\r\n        }\r\n\r\n        return currencyKeys_;\r\n    }\r\n\r\n    /// @notice Gets the `SUSD` variable\r\n    /// @return susd_ The `SUSD` variable value\r\n    function getSUSD() external view returns (address susd_) {\r\n        return SUSD;\r\n    }\r\n\r\n    /// @notice Gets the currencyKey for a given Synth\r\n    /// @return currencyKey_ The currencyKey value\r\n    function getCurrencyKeyForSynth(address _synth) public view returns (bytes32 currencyKey_) {\r\n        return synthToCurrencyKey[_synth];\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetixAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetixAddressResolver Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetixAddressResolver {\r\n    function requireAndGetAddress(bytes32, string calldata) external view returns (address);\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetixExchanger.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetixExchanger Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetixExchanger {\r\n    function getAmountsForExchange(\r\n        uint256,\r\n        bytes32,\r\n        bytes32\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function settle(address, bytes32)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetix Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetix {\r\n    function exchangeOnBehalfWithTracking(\r\n        address,\r\n        bytes32,\r\n        uint256,\r\n        bytes32,\r\n        address,\r\n        bytes32\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetixExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetixExchangeRates Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetixExchangeRates {\r\n    function rateAndInvalid(bytes32) external view returns (uint256, bool);\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetixProxyERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetixProxyERC20 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetixProxyERC20 {\r\n    function target() external view returns (address);\r\n}\r\n"
    },
    "contracts/release/interfaces/ISynthetixSynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ISynthetixSynth Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ISynthetixSynth {\r\n    function currencyKey() external view returns (bytes32);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/release/extensions/utils/ExtensionBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../core/fund/comptroller/IComptroller.sol\";\r\nimport \"../../core/fund/vault/IVault.sol\";\r\nimport \"../IExtension.sol\";\r\n\r\n/// @title ExtensionBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Base class for an extension\r\nabstract contract ExtensionBase is IExtension {\r\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\r\n\r\n    /// @notice Allows extension to run logic during fund activation\r\n    /// @dev Unimplemented by default, may be overridden.\r\n    function activateForFund(bool) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\r\n    /// @dev Unimplemented by default, may be overridden.\r\n    function deactivateForFund() external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\r\n    /// and dispatches the appropriate action\r\n    /// @dev Unimplemented by default, may be overridden.\r\n    function receiveCallFromComptroller(\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual override {\r\n        revert(\"receiveCallFromComptroller: Unimplemented for Extension\");\r\n    }\r\n\r\n    /// @notice Allows extension to run logic during fund configuration\r\n    /// @dev Unimplemented by default, may be overridden.\r\n    function setConfigForFund(bytes calldata) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @dev Helper to validate a ComptrollerProxy-VaultProxy relation, which we store for both\r\n    /// gas savings and to guarantee a spoofed ComptrollerProxy does not change getVaultProxy().\r\n    /// Will revert without reason if the expected interfaces do not exist.\r\n    function __setValidatedVaultProxy(address _comptrollerProxy)\r\n        internal\r\n        returns (address vaultProxy_)\r\n    {\r\n        require(\r\n            comptrollerProxyToVaultProxy[_comptrollerProxy] == address(0),\r\n            \"__setValidatedVaultProxy: Already set\"\r\n        );\r\n\r\n        vaultProxy_ = IComptroller(_comptrollerProxy).getVaultProxy();\r\n        require(vaultProxy_ != address(0), \"__setValidatedVaultProxy: Missing vaultProxy\");\r\n\r\n        require(\r\n            _comptrollerProxy == IVault(vaultProxy_).getAccessor(),\r\n            \"__setValidatedVaultProxy: Not the VaultProxy accessor\"\r\n        );\r\n\r\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = vaultProxy_;\r\n\r\n        return vaultProxy_;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return vaultProxy_ The VaultProxy of the fund\r\n    function getVaultProxyForFund(address _comptrollerProxy)\r\n        public\r\n        view\r\n        returns (address vaultProxy_)\r\n    {\r\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/utils/PermissionedVaultActionMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../core/fund/comptroller/IComptroller.sol\";\r\n\r\n/// @title PermissionedVaultActionMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract for extensions that can make permissioned vault calls\r\nabstract contract PermissionedVaultActionMixin {\r\n    /// @notice Adds a tracked asset to the fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _asset The asset to add\r\n    function __addTrackedAsset(address _comptrollerProxy, address _asset) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.AddTrackedAsset,\r\n            abi.encode(_asset)\r\n        );\r\n    }\r\n\r\n    /// @notice Grants an allowance to a spender to use a fund's asset\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _asset The asset for which to grant an allowance\r\n    /// @param _target The spender of the allowance\r\n    /// @param _amount The amount of the allowance\r\n    function __approveAssetSpender(\r\n        address _comptrollerProxy,\r\n        address _asset,\r\n        address _target,\r\n        uint256 _amount\r\n    ) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.ApproveAssetSpender,\r\n            abi.encode(_asset, _target, _amount)\r\n        );\r\n    }\r\n\r\n    /// @notice Burns fund shares for a particular account\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _target The account for which to burn shares\r\n    /// @param _amount The amount of shares to burn\r\n    function __burnShares(\r\n        address _comptrollerProxy,\r\n        address _target,\r\n        uint256 _amount\r\n    ) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.BurnShares,\r\n            abi.encode(_target, _amount)\r\n        );\r\n    }\r\n\r\n    /// @notice Mints fund shares to a particular account\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _target The account to which to mint shares\r\n    /// @param _amount The amount of shares to mint\r\n    function __mintShares(\r\n        address _comptrollerProxy,\r\n        address _target,\r\n        uint256 _amount\r\n    ) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.MintShares,\r\n            abi.encode(_target, _amount)\r\n        );\r\n    }\r\n\r\n    /// @notice Removes a tracked asset from the fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _asset The asset to remove\r\n    function __removeTrackedAsset(address _comptrollerProxy, address _asset) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.RemoveTrackedAsset,\r\n            abi.encode(_asset)\r\n        );\r\n    }\r\n\r\n    /// @notice Transfers fund shares from one account to another\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _from The account from which to transfer shares\r\n    /// @param _to The account to which to transfer shares\r\n    /// @param _amount The amount of shares to transfer\r\n    function __transferShares(\r\n        address _comptrollerProxy,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.TransferShares,\r\n            abi.encode(_from, _to, _amount)\r\n        );\r\n    }\r\n\r\n    /// @notice Withdraws an asset from the VaultProxy to a given account\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _asset The asset to withdraw\r\n    /// @param _target The account to which to withdraw the asset\r\n    /// @param _amount The amount of asset to withdraw\r\n    function __withdrawAssetTo(\r\n        address _comptrollerProxy,\r\n        address _asset,\r\n        address _target,\r\n        uint256 _amount\r\n    ) internal {\r\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\r\n            IComptroller.VaultAction.WithdrawAssetTo,\r\n            abi.encode(_asset, _target, _amount)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/release/peripheral/FundActionsWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../interfaces/IWETH.sol\";\r\nimport \"../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../extensions/fee-manager/FeeManager.sol\";\r\n\r\n/// @title FundActionsWrapper Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Logic related to wrapping fund actions, not necessary in the core protocol\r\ncontract FundActionsWrapper {\r\n    using SafeERC20 for ERC20;\r\n\r\n    address private immutable FEE_MANAGER;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    mapping(address => bool) private accountToHasMaxWethAllowance;\r\n\r\n    constructor(address _feeManager, address _weth) public {\r\n        FEE_MANAGER = _feeManager;\r\n        WETH_TOKEN = _weth;\r\n    }\r\n\r\n    /// @dev Needed in case WETH not fully used during exchangeAndBuyShares,\r\n    /// to unwrap into ETH and refund\r\n    receive() external payable {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Calculates the net value of 1 unit of shares in the fund's denomination asset\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return netShareValue_ The amount of the denomination asset per share\r\n    /// @return isValid_ True if the conversion rates to derive the value are all valid\r\n    /// @dev Accounts for fees outstanding. This is a convenience function for external consumption\r\n    /// that can be used to determine the cost of purchasing shares at any given point in time.\r\n    /// It essentially just bundles settling all fees that implement the Continuous hook and then\r\n    /// looking up the gross share value.\r\n    function calcNetShareValueForFund(address _comptrollerProxy)\r\n        external\r\n        returns (uint256 netShareValue_, bool isValid_)\r\n    {\r\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\r\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 0, \"\");\r\n\r\n        return comptrollerProxyContract.calcGrossShareValue(false);\r\n    }\r\n\r\n    /// @notice Exchanges ETH into a fund's denomination asset and then buys shares\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _buyer The account for which to buy shares\r\n    /// @param _minSharesQuantity The minimum quantity of shares to buy with the sent ETH\r\n    /// @param _exchange The exchange on which to execute the swap to the denomination asset\r\n    /// @param _exchangeApproveTarget The address that should be given an allowance of WETH\r\n    /// for the given _exchange\r\n    /// @param _exchangeData The data with which to call the exchange to execute the swap\r\n    /// to the denomination asset\r\n    /// @param _minInvestmentAmount The minimum amount of the denomination asset\r\n    /// to receive in the trade for investment (not necessary for WETH)\r\n    /// @return sharesReceivedAmount_ The actual amount of shares received\r\n    /// @dev Use a reasonable _minInvestmentAmount always, in case the exchange\r\n    /// does not perform as expected (low incoming asset amount, blend of assets, etc).\r\n    /// If the fund's denomination asset is WETH, _exchange, _exchangeApproveTarget, _exchangeData,\r\n    /// and _minInvestmentAmount will be ignored.\r\n    function exchangeAndBuyShares(\r\n        address _comptrollerProxy,\r\n        address _denominationAsset,\r\n        address _buyer,\r\n        uint256 _minSharesQuantity,\r\n        address _exchange,\r\n        address _exchangeApproveTarget,\r\n        bytes calldata _exchangeData,\r\n        uint256 _minInvestmentAmount\r\n    ) external payable returns (uint256 sharesReceivedAmount_) {\r\n        // Wrap ETH into WETH\r\n        IWETH(payable(WETH_TOKEN)).deposit{value: msg.value}();\r\n\r\n        // If denominationAsset is WETH, can just buy shares directly\r\n        if (_denominationAsset == WETH_TOKEN) {\r\n            __approveMaxWethAsNeeded(_comptrollerProxy);\r\n            return __buyShares(_comptrollerProxy, _buyer, msg.value, _minSharesQuantity);\r\n        }\r\n\r\n        // Exchange ETH to the fund's denomination asset\r\n        __approveMaxWethAsNeeded(_exchangeApproveTarget);\r\n        (bool success, bytes memory returnData) = _exchange.call(_exchangeData);\r\n        require(success, string(returnData));\r\n\r\n        // Confirm the amount received in the exchange is above the min acceptable amount\r\n        uint256 investmentAmount = ERC20(_denominationAsset).balanceOf(address(this));\r\n        require(\r\n            investmentAmount >= _minInvestmentAmount,\r\n            \"exchangeAndBuyShares: _minInvestmentAmount not met\"\r\n        );\r\n\r\n        // Give the ComptrollerProxy max allowance for its denomination asset as necessary\r\n        __approveMaxAsNeeded(_denominationAsset, _comptrollerProxy, investmentAmount);\r\n\r\n        // Buy fund shares\r\n        sharesReceivedAmount_ = __buyShares(\r\n            _comptrollerProxy,\r\n            _buyer,\r\n            investmentAmount,\r\n            _minSharesQuantity\r\n        );\r\n\r\n        // Unwrap and refund any remaining WETH not used in the exchange\r\n        uint256 remainingWeth = ERC20(WETH_TOKEN).balanceOf(address(this));\r\n        if (remainingWeth > 0) {\r\n            IWETH(payable(WETH_TOKEN)).withdraw(remainingWeth);\r\n            (success, returnData) = msg.sender.call{value: remainingWeth}(\"\");\r\n            require(success, string(returnData));\r\n        }\r\n\r\n        return sharesReceivedAmount_;\r\n    }\r\n\r\n    /// @notice Invokes the Continuous fee hook on all specified fees, and then attempts to payout\r\n    /// any shares outstanding on those fees\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _fees The fees for which to run these actions\r\n    /// @dev This is just a wrapper to execute two callOnExtension() actions atomically, in sequence.\r\n    /// The caller must pass in the fees that they want to run this logic on.\r\n    function invokeContinuousFeeHookAndPayoutSharesOutstandingForFund(\r\n        address _comptrollerProxy,\r\n        address[] calldata _fees\r\n    ) external {\r\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\r\n\r\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 0, \"\");\r\n        comptrollerProxyContract.callOnExtension(FEE_MANAGER, 1, abi.encode(_fees));\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Gets all fees that implement the `Continuous` fee hook for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return continuousFees_ The fees that implement the `Continuous` fee hook\r\n    function getContinuousFeesForFund(address _comptrollerProxy)\r\n        public\r\n        view\r\n        returns (address[] memory continuousFees_)\r\n    {\r\n        FeeManager feeManagerContract = FeeManager(FEE_MANAGER);\r\n\r\n        address[] memory fees = feeManagerContract.getEnabledFeesForFund(_comptrollerProxy);\r\n\r\n        // Count the continuous fees\r\n        uint256 continuousFeesCount;\r\n        bool[] memory implementsContinuousHook = new bool[](fees.length);\r\n        for (uint256 i; i < fees.length; i++) {\r\n            if (feeManagerContract.feeSettlesOnHook(fees[i], IFeeManager.FeeHook.Continuous)) {\r\n                continuousFeesCount++;\r\n                implementsContinuousHook[i] = true;\r\n            }\r\n        }\r\n\r\n        // Return early if no continuous fees\r\n        if (continuousFeesCount == 0) {\r\n            return new address[](0);\r\n        }\r\n\r\n        // Create continuous fees array\r\n        continuousFees_ = new address[](continuousFeesCount);\r\n        uint256 continuousFeesIndex;\r\n        for (uint256 i; i < fees.length; i++) {\r\n            if (implementsContinuousHook[i]) {\r\n                continuousFees_[continuousFeesIndex] = fees[i];\r\n                continuousFeesIndex++;\r\n            }\r\n        }\r\n\r\n        return continuousFees_;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to approve a target with the max amount of an asset, only when necessary\r\n    function __approveMaxAsNeeded(\r\n        address _asset,\r\n        address _target,\r\n        uint256 _neededAmount\r\n    ) internal {\r\n        if (ERC20(_asset).allowance(address(this), _target) < _neededAmount) {\r\n            ERC20(_asset).safeApprove(_target, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to approve a target with the max amount of weth, only when necessary.\r\n    /// Since WETH does not decrease the allowance if it uint256(-1), only ever need to do this\r\n    /// once per target.\r\n    function __approveMaxWethAsNeeded(address _target) internal {\r\n        if (!accountHasMaxWethAllowance(_target)) {\r\n            ERC20(WETH_TOKEN).safeApprove(_target, type(uint256).max);\r\n            accountToHasMaxWethAllowance[_target] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev Helper for buying shares\r\n    function __buyShares(\r\n        address _comptrollerProxy,\r\n        address _buyer,\r\n        uint256 _investmentAmount,\r\n        uint256 _minSharesQuantity\r\n    ) private returns (uint256 sharesReceivedAmount_) {\r\n        address[] memory buyers = new address[](1);\r\n        buyers[0] = _buyer;\r\n        uint256[] memory investmentAmounts = new uint256[](1);\r\n        investmentAmounts[0] = _investmentAmount;\r\n        uint256[] memory minSharesQuantities = new uint256[](1);\r\n        minSharesQuantities[0] = _minSharesQuantity;\r\n\r\n        return\r\n            ComptrollerLib(_comptrollerProxy).buyShares(\r\n                buyers,\r\n                investmentAmounts,\r\n                minSharesQuantities\r\n            )[0];\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `FEE_MANAGER` variable\r\n    /// @return feeManager_ The `FEE_MANAGER` variable value\r\n    function getFeeManager() external view returns (address feeManager_) {\r\n        return FEE_MANAGER;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n\r\n    /// @notice Checks whether an account has the max allowance for WETH\r\n    /// @param _who The account to check\r\n    /// @return hasMaxWethAllowance_ True if the account has the max allowance\r\n    function accountHasMaxWethAllowance(address _who)\r\n        public\r\n        view\r\n        returns (bool hasMaxWethAllowance_)\r\n    {\r\n        return accountToHasMaxWethAllowance[_who];\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title WETH Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/release/peripheral/shares-requestors/AuthUserExecutedSharesRequestorLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../../core/fund/vault/VaultLib.sol\";\r\nimport \"./IAuthUserExecutedSharesRequestor.sol\";\r\n\r\n/// @title AuthUserExecutedSharesRequestorLib Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Provides the logic for AuthUserExecutedSharesRequestorProxy instances,\r\n/// in which shares requests are manually executed by a permissioned user\r\n/// @dev This will not work with a `denominationAsset` that does not transfer\r\n/// the exact expected amount or has an elastic supply.\r\ncontract AuthUserExecutedSharesRequestorLib is IAuthUserExecutedSharesRequestor {\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n\r\n    event RequestCanceled(\r\n        address indexed requestOwner,\r\n        uint256 investmentAmount,\r\n        uint256 minSharesQuantity\r\n    );\r\n\r\n    event RequestCreated(\r\n        address indexed requestOwner,\r\n        uint256 investmentAmount,\r\n        uint256 minSharesQuantity\r\n    );\r\n\r\n    event RequestExecuted(\r\n        address indexed caller,\r\n        address indexed requestOwner,\r\n        uint256 investmentAmount,\r\n        uint256 minSharesQuantity\r\n    );\r\n\r\n    event RequestExecutorAdded(address indexed account);\r\n\r\n    event RequestExecutorRemoved(address indexed account);\r\n\r\n    struct RequestInfo {\r\n        uint256 investmentAmount;\r\n        uint256 minSharesQuantity;\r\n    }\r\n\r\n    uint256 private constant CANCELLATION_COOLDOWN_TIMELOCK = 10 minutes;\r\n\r\n    address private comptrollerProxy;\r\n    address private denominationAsset;\r\n    address private fundOwner;\r\n\r\n    mapping(address => RequestInfo) private ownerToRequestInfo;\r\n    mapping(address => bool) private acctToIsRequestExecutor;\r\n    mapping(address => uint256) private ownerToLastRequestCancellation;\r\n\r\n    modifier onlyFundOwner() {\r\n        require(msg.sender == fundOwner, \"Only fund owner callable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Initializes a proxy instance that uses this library\r\n    /// @dev Serves as a per-proxy pseudo-constructor\r\n    function init(address _comptrollerProxy) external override {\r\n        require(comptrollerProxy == address(0), \"init: Already initialized\");\r\n\r\n        comptrollerProxy = _comptrollerProxy;\r\n\r\n        // Cache frequently-used values that require external calls\r\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\r\n        denominationAsset = comptrollerProxyContract.getDenominationAsset();\r\n        fundOwner = VaultLib(comptrollerProxyContract.getVaultProxy()).getOwner();\r\n    }\r\n\r\n    /// @notice Cancels the shares request of the caller\r\n    function cancelRequest() external {\r\n        RequestInfo memory request = ownerToRequestInfo[msg.sender];\r\n        require(request.investmentAmount > 0, \"cancelRequest: Request does not exist\");\r\n\r\n        // Delete the request, start the cooldown period, and return the investment asset\r\n        delete ownerToRequestInfo[msg.sender];\r\n        ownerToLastRequestCancellation[msg.sender] = block.timestamp;\r\n        ERC20(denominationAsset).safeTransfer(msg.sender, request.investmentAmount);\r\n\r\n        emit RequestCanceled(msg.sender, request.investmentAmount, request.minSharesQuantity);\r\n    }\r\n\r\n    /// @notice Creates a shares request for the caller\r\n    /// @param _investmentAmount The amount of the fund's denomination asset to use to buy shares\r\n    /// @param _minSharesQuantity The minimum quantity of shares to buy with the _investmentAmount\r\n    function createRequest(uint256 _investmentAmount, uint256 _minSharesQuantity) external {\r\n        require(_investmentAmount > 0, \"createRequest: _investmentAmount must be > 0\");\r\n        require(\r\n            ownerToRequestInfo[msg.sender].investmentAmount == 0,\r\n            \"createRequest: The request owner can only create one request before executed or canceled\"\r\n        );\r\n        require(\r\n            ownerToLastRequestCancellation[msg.sender] <\r\n                block.timestamp.sub(CANCELLATION_COOLDOWN_TIMELOCK),\r\n            \"createRequest: Cannot create request during cancellation cooldown period\"\r\n        );\r\n\r\n        // Create the Request and take custody of investment asset\r\n        ownerToRequestInfo[msg.sender] = RequestInfo({\r\n            investmentAmount: _investmentAmount,\r\n            minSharesQuantity: _minSharesQuantity\r\n        });\r\n        ERC20(denominationAsset).safeTransferFrom(msg.sender, address(this), _investmentAmount);\r\n\r\n        emit RequestCreated(msg.sender, _investmentAmount, _minSharesQuantity);\r\n    }\r\n\r\n    /// @notice Executes multiple shares requests\r\n    /// @param _requestOwners The owners of the pending shares requests\r\n    function executeRequests(address[] calldata _requestOwners) external {\r\n        require(\r\n            msg.sender == fundOwner || isRequestExecutor(msg.sender),\r\n            \"executeRequests: Invalid caller\"\r\n        );\r\n        require(_requestOwners.length > 0, \"executeRequests: _requestOwners can not be empty\");\r\n\r\n        (\r\n            address[] memory buyers,\r\n            uint256[] memory investmentAmounts,\r\n            uint256[] memory minSharesQuantities,\r\n            uint256 totalInvestmentAmount\r\n        ) = __convertRequestsToBuySharesParams(_requestOwners);\r\n\r\n        // Since ComptrollerProxy instances are fully trusted,\r\n        // we can approve them with the max amount of the denomination asset,\r\n        // and only top the approval back to max if ever necessary.\r\n        address comptrollerProxyCopy = comptrollerProxy;\r\n        ERC20 denominationAssetContract = ERC20(denominationAsset);\r\n        if (\r\n            denominationAssetContract.allowance(address(this), comptrollerProxyCopy) <\r\n            totalInvestmentAmount\r\n        ) {\r\n            denominationAssetContract.safeApprove(comptrollerProxyCopy, type(uint256).max);\r\n        }\r\n\r\n        ComptrollerLib(comptrollerProxyCopy).buyShares(\r\n            buyers,\r\n            investmentAmounts,\r\n            minSharesQuantities\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to convert raw shares requests into the format required by buyShares().\r\n    /// It also removes any empty requests, which is necessary to prevent a DoS attack where a user\r\n    /// cancels their request earlier in the same block (can be repeated from multiple accounts).\r\n    /// This function also removes shares requests and fires success events as it loops through them.\r\n    function __convertRequestsToBuySharesParams(address[] memory _requestOwners)\r\n        private\r\n        returns (\r\n            address[] memory buyers_,\r\n            uint256[] memory investmentAmounts_,\r\n            uint256[] memory minSharesQuantities_,\r\n            uint256 totalInvestmentAmount_\r\n        )\r\n    {\r\n        uint256 existingRequestsCount = _requestOwners.length;\r\n        uint256[] memory allInvestmentAmounts = new uint256[](_requestOwners.length);\r\n\r\n        // Loop through once to get the count of existing requests\r\n        for (uint256 i; i < _requestOwners.length; i++) {\r\n            allInvestmentAmounts[i] = ownerToRequestInfo[_requestOwners[i]].investmentAmount;\r\n\r\n            if (allInvestmentAmounts[i] == 0) {\r\n                existingRequestsCount--;\r\n            }\r\n        }\r\n\r\n        // Loop through a second time to format requests for buyShares(),\r\n        // and to delete the requests and emit events early so no further looping is needed.\r\n        buyers_ = new address[](existingRequestsCount);\r\n        investmentAmounts_ = new uint256[](existingRequestsCount);\r\n        minSharesQuantities_ = new uint256[](existingRequestsCount);\r\n        uint256 existingRequestsIndex;\r\n        for (uint256 i; i < _requestOwners.length; i++) {\r\n            if (allInvestmentAmounts[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            buyers_[existingRequestsIndex] = _requestOwners[i];\r\n            investmentAmounts_[existingRequestsIndex] = allInvestmentAmounts[i];\r\n            minSharesQuantities_[existingRequestsIndex] = ownerToRequestInfo[_requestOwners[i]]\r\n                .minSharesQuantity;\r\n            totalInvestmentAmount_ = totalInvestmentAmount_.add(allInvestmentAmounts[i]);\r\n\r\n            delete ownerToRequestInfo[_requestOwners[i]];\r\n\r\n            emit RequestExecuted(\r\n                msg.sender,\r\n                buyers_[existingRequestsIndex],\r\n                investmentAmounts_[existingRequestsIndex],\r\n                minSharesQuantities_[existingRequestsIndex]\r\n            );\r\n\r\n            existingRequestsIndex++;\r\n        }\r\n\r\n        return (buyers_, investmentAmounts_, minSharesQuantities_, totalInvestmentAmount_);\r\n    }\r\n\r\n    ///////////////////////////////\r\n    // REQUEST EXECUTOR REGISTRY //\r\n    ///////////////////////////////\r\n\r\n    /// @notice Adds accounts to request executors\r\n    /// @param _requestExecutors Accounts to add\r\n    function addRequestExecutors(address[] calldata _requestExecutors) external onlyFundOwner {\r\n        require(_requestExecutors.length > 0, \"addRequestExecutors: Empty _requestExecutors\");\r\n\r\n        for (uint256 i; i < _requestExecutors.length; i++) {\r\n            require(\r\n                !isRequestExecutor(_requestExecutors[i]),\r\n                \"addRequestExecutors: Value already set\"\r\n            );\r\n            require(\r\n                _requestExecutors[i] != fundOwner,\r\n                \"addRequestExecutors: The fund owner cannot be added\"\r\n            );\r\n\r\n            acctToIsRequestExecutor[_requestExecutors[i]] = true;\r\n\r\n            emit RequestExecutorAdded(_requestExecutors[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Removes accounts from request executors\r\n    /// @param _requestExecutors Accounts to remove\r\n    function removeRequestExecutors(address[] calldata _requestExecutors) external onlyFundOwner {\r\n        require(_requestExecutors.length > 0, \"removeRequestExecutors: Empty _requestExecutors\");\r\n\r\n        for (uint256 i; i < _requestExecutors.length; i++) {\r\n            require(\r\n                isRequestExecutor(_requestExecutors[i]),\r\n                \"removeRequestExecutors: Account is not a request executor\"\r\n            );\r\n\r\n            acctToIsRequestExecutor[_requestExecutors[i]] = false;\r\n\r\n            emit RequestExecutorRemoved(_requestExecutors[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the value of `comptrollerProxy` variable\r\n    /// @return comptrollerProxy_ The `comptrollerProxy` variable value\r\n    function getComptrollerProxy() external view returns (address comptrollerProxy_) {\r\n        return comptrollerProxy;\r\n    }\r\n\r\n    /// @notice Gets the value of `denominationAsset` variable\r\n    /// @return denominationAsset_ The `denominationAsset` variable value\r\n    function getDenominationAsset() external view returns (address denominationAsset_) {\r\n        return denominationAsset;\r\n    }\r\n\r\n    /// @notice Gets the value of `fundOwner` variable\r\n    /// @return fundOwner_ The `fundOwner` variable value\r\n    function getFundOwner() external view returns (address fundOwner_) {\r\n        return fundOwner;\r\n    }\r\n\r\n    /// @notice Gets the request info of a user\r\n    /// @param _requestOwner The address of the user that creates the request\r\n    /// @return requestInfo_ The request info created by the user\r\n    function getSharesRequestInfoForOwner(address _requestOwner)\r\n        external\r\n        view\r\n        returns (RequestInfo memory requestInfo_)\r\n    {\r\n        return ownerToRequestInfo[_requestOwner];\r\n    }\r\n\r\n    /// @notice Checks whether an account is a request executor\r\n    /// @param _who The account to check\r\n    /// @return isRequestExecutor_ True if _who is a request executor\r\n    function isRequestExecutor(address _who) public view returns (bool isRequestExecutor_) {\r\n        return acctToIsRequestExecutor[_who];\r\n    }\r\n}\r\n"
    },
    "contracts/release/peripheral/shares-requestors/IAuthUserExecutedSharesRequestor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IAuthUserExecutedSharesRequestor Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAuthUserExecutedSharesRequestor {\r\n    function init(address) external;\r\n}\r\n"
    },
    "contracts/release/peripheral/shares-requestors/AuthUserExecutedSharesRequestorFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../../core/fund/vault/VaultLib.sol\";\r\nimport \"./AuthUserExecutedSharesRequestorProxy.sol\";\r\nimport \"./IAuthUserExecutedSharesRequestor.sol\";\r\n\r\n/// @title AuthUserExecutedSharesRequestorFactory Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Deploys and maintains a record of AuthUserExecutedSharesRequestorProxy instances\r\ncontract AuthUserExecutedSharesRequestorFactory {\r\n    event SharesRequestorProxyDeployed(\r\n        address indexed comptrollerProxy,\r\n        address sharesRequestorProxy\r\n    );\r\n\r\n    address private immutable AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB;\r\n    address private immutable DISPATCHER;\r\n\r\n    mapping(address => address) private comptrollerProxyToSharesRequestorProxy;\r\n\r\n    constructor(address _dispatcher, address _authUserExecutedSharesRequestorLib) public {\r\n        AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB = _authUserExecutedSharesRequestorLib;\r\n        DISPATCHER = _dispatcher;\r\n    }\r\n\r\n    /// @notice Deploys a shares requestor proxy instance for a given ComptrollerProxy instance\r\n    /// @param _comptrollerProxy The ComptrollerProxy for which to deploy the shares requestor proxy\r\n    /// @return sharesRequestorProxy_ The address of the newly-deployed shares requestor proxy\r\n    function deploySharesRequestorProxy(address _comptrollerProxy)\r\n        external\r\n        returns (address sharesRequestorProxy_)\r\n    {\r\n        // Confirm fund is genuine\r\n        VaultLib vaultProxyContract = VaultLib(ComptrollerLib(_comptrollerProxy).getVaultProxy());\r\n        require(\r\n            vaultProxyContract.getAccessor() == _comptrollerProxy,\r\n            \"deploySharesRequestorProxy: Invalid VaultProxy for ComptrollerProxy\"\r\n        );\r\n        require(\r\n            IDispatcher(DISPATCHER).getFundDeployerForVaultProxy(address(vaultProxyContract)) !=\r\n                address(0),\r\n            \"deploySharesRequestorProxy: Not a genuine fund\"\r\n        );\r\n\r\n        // Validate that the caller is the fund owner\r\n        require(\r\n            msg.sender == vaultProxyContract.getOwner(),\r\n            \"deploySharesRequestorProxy: Only fund owner callable\"\r\n        );\r\n\r\n        // Validate that a proxy does not already exist\r\n        require(\r\n            comptrollerProxyToSharesRequestorProxy[_comptrollerProxy] == address(0),\r\n            \"deploySharesRequestorProxy: Proxy already exists\"\r\n        );\r\n\r\n        // Deploy the proxy\r\n        bytes memory constructData = abi.encodeWithSelector(\r\n            IAuthUserExecutedSharesRequestor.init.selector,\r\n            _comptrollerProxy\r\n        );\r\n        sharesRequestorProxy_ = address(\r\n            new AuthUserExecutedSharesRequestorProxy(\r\n                constructData,\r\n                AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB\r\n            )\r\n        );\r\n\r\n        comptrollerProxyToSharesRequestorProxy[_comptrollerProxy] = sharesRequestorProxy_;\r\n\r\n        emit SharesRequestorProxyDeployed(_comptrollerProxy, sharesRequestorProxy_);\r\n\r\n        return sharesRequestorProxy_;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the value of the `AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB` variable\r\n    /// @return authUserExecutedSharesRequestorLib_ The `AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB` variable value\r\n    function getAuthUserExecutedSharesRequestorLib()\r\n        external\r\n        view\r\n        returns (address authUserExecutedSharesRequestorLib_)\r\n    {\r\n        return AUTH_USER_EXECUTED_SHARES_REQUESTOR_LIB;\r\n    }\r\n\r\n    /// @notice Gets the value of the `DISPATCHER` variable\r\n    /// @return dispatcher_ The `DISPATCHER` variable value\r\n    function getDispatcher() external view returns (address dispatcher_) {\r\n        return DISPATCHER;\r\n    }\r\n\r\n    /// @notice Gets the AuthUserExecutedSharesRequestorProxy associated with the given ComptrollerProxy\r\n    /// @param _comptrollerProxy The ComptrollerProxy for which to get the associated AuthUserExecutedSharesRequestorProxy\r\n    /// @return sharesRequestorProxy_ The associated AuthUserExecutedSharesRequestorProxy address\r\n    function getSharesRequestorProxyForComptrollerProxy(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (address sharesRequestorProxy_)\r\n    {\r\n        return comptrollerProxyToSharesRequestorProxy[_comptrollerProxy];\r\n    }\r\n}\r\n"
    },
    "contracts/release/peripheral/shares-requestors/AuthUserExecutedSharesRequestorProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/Proxy.sol\";\r\n\r\ncontract AuthUserExecutedSharesRequestorProxy is Proxy {\r\n    constructor(bytes memory _constructData, address _authUserExecutedSharesRequestorLib)\r\n        public\r\n        Proxy(_constructData, _authUserExecutedSharesRequestorLib)\r\n    {}\r\n}\r\n"
    },
    "contracts/release/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Proxy Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A proxy contract for all Proxy instances\r\n/// @dev The recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\r\n/// and using the EIP-1967 storage slot for the proxiable implementation.\r\n/// i.e., `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`, which is\r\n/// \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\r\n/// See: https://eips.ethereum.org/EIPS/eip-1822\r\ncontract Proxy {\r\n    constructor(bytes memory _constructData, address _contractLogic) public {\r\n        assembly {\r\n            sstore(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\r\n                _contractLogic\r\n            )\r\n        }\r\n        (bool success, bytes memory returnData) = _contractLogic.delegatecall(_constructData);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    fallback() external payable {\r\n        assembly {\r\n            let contractLogic := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(\r\n                sub(gas(), 10000),\r\n                contractLogic,\r\n                0x0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n                case 0 {\r\n                    revert(0, retSz)\r\n                }\r\n                default {\r\n                    return(0, retSz)\r\n                }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../utils/Proxy.sol\";\r\n\r\n/// @title ComptrollerProxy Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A proxy contract for all ComptrollerProxy instances\r\ncontract ComptrollerProxy is Proxy {\r\n    constructor(bytes memory _constructData, address _comptrollerLib)\r\n        public\r\n        Proxy(_constructData, _comptrollerLib)\r\n    {}\r\n}\r\n"
    },
    "contracts/release/core/fund-deployer/FundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../../../persistent/dispatcher/IDispatcher.sol\";\r\nimport \"../../../persistent/utils/IMigrationHookHandler.sol\";\r\nimport \"../fund/comptroller/IComptroller.sol\";\r\nimport \"../fund/comptroller/ComptrollerProxy.sol\";\r\nimport \"../fund/vault/IVault.sol\";\r\nimport \"./IFundDeployer.sol\";\r\n\r\n/// @title FundDeployer Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice The top-level contract of the release.\r\n/// It primarily coordinates fund deployment and fund migration, but\r\n/// it is also deferred to for contract access control and for allowed calls\r\n/// that can be made with a fund's VaultProxy as the msg.sender.\r\ncontract FundDeployer is IFundDeployer, IMigrationHookHandler {\r\n    event ComptrollerLibSet(address comptrollerLib);\r\n\r\n    event ComptrollerProxyDeployed(\r\n        address indexed creator,\r\n        address comptrollerProxy,\r\n        address indexed denominationAsset,\r\n        uint256 sharesActionTimelock,\r\n        bytes feeManagerConfigData,\r\n        bytes policyManagerConfigData,\r\n        bool indexed forMigration\r\n    );\r\n\r\n    event NewFundCreated(\r\n        address indexed creator,\r\n        address comptrollerProxy,\r\n        address vaultProxy,\r\n        address indexed fundOwner,\r\n        string fundName,\r\n        address indexed denominationAsset,\r\n        uint256 sharesActionTimelock,\r\n        bytes feeManagerConfigData,\r\n        bytes policyManagerConfigData\r\n    );\r\n\r\n    event ReleaseStatusSet(ReleaseStatus indexed prevStatus, ReleaseStatus indexed nextStatus);\r\n\r\n    event VaultCallDeregistered(address indexed contractAddress, bytes4 selector);\r\n\r\n    event VaultCallRegistered(address indexed contractAddress, bytes4 selector);\r\n\r\n    // Constants\r\n    address private immutable CREATOR;\r\n    address private immutable DISPATCHER;\r\n    address private immutable VAULT_LIB;\r\n\r\n    // Pseudo-constants (can only be set once)\r\n    address private comptrollerLib;\r\n\r\n    // Storage\r\n    ReleaseStatus private releaseStatus;\r\n    mapping(address => mapping(bytes4 => bool)) private contractToSelectorToIsRegisteredVaultCall;\r\n    mapping(address => address) private pendingComptrollerProxyToCreator;\r\n\r\n    modifier onlyLiveRelease() {\r\n        require(releaseStatus == ReleaseStatus.Live, \"Release is not Live\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrator(address _vaultProxy) {\r\n        require(\r\n            IVault(_vaultProxy).canMigrate(msg.sender),\r\n            \"Only a permissioned migrator can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == getOwner(), \"Only the contract owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPendingComptrollerProxyCreator(address _comptrollerProxy) {\r\n        require(\r\n            msg.sender == pendingComptrollerProxyToCreator[_comptrollerProxy],\r\n            \"Only the ComptrollerProxy creator can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _dispatcher,\r\n        address _vaultLib,\r\n        address[] memory _vaultCallContracts,\r\n        bytes4[] memory _vaultCallSelectors\r\n    ) public {\r\n        if (_vaultCallContracts.length > 0) {\r\n            __registerVaultCalls(_vaultCallContracts, _vaultCallSelectors);\r\n        }\r\n        CREATOR = msg.sender;\r\n        DISPATCHER = _dispatcher;\r\n        VAULT_LIB = _vaultLib;\r\n    }\r\n\r\n    /////////////\r\n    // GENERAL //\r\n    /////////////\r\n\r\n    /// @notice Sets the comptrollerLib\r\n    /// @param _comptrollerLib The ComptrollerLib contract address\r\n    /// @dev Can only be set once\r\n    function setComptrollerLib(address _comptrollerLib) external onlyOwner {\r\n        require(\r\n            comptrollerLib == address(0),\r\n            \"setComptrollerLib: This value can only be set once\"\r\n        );\r\n\r\n        comptrollerLib = _comptrollerLib;\r\n\r\n        emit ComptrollerLibSet(_comptrollerLib);\r\n    }\r\n\r\n    /// @notice Sets the status of the protocol to a new state\r\n    /// @param _nextStatus The next status state to set\r\n    function setReleaseStatus(ReleaseStatus _nextStatus) external {\r\n        require(\r\n            msg.sender == getOwner(),\r\n            \"setReleaseStatus: Only the owner can call this function\"\r\n        );\r\n        require(\r\n            _nextStatus != ReleaseStatus.PreLaunch,\r\n            \"setReleaseStatus: Cannot return to PreLaunch status\"\r\n        );\r\n        require(\r\n            comptrollerLib != address(0),\r\n            \"setReleaseStatus: Can only set the release status when comptrollerLib is set\"\r\n        );\r\n\r\n        ReleaseStatus prevStatus = releaseStatus;\r\n        require(_nextStatus != prevStatus, \"setReleaseStatus: _nextStatus is the current status\");\r\n\r\n        releaseStatus = _nextStatus;\r\n\r\n        emit ReleaseStatusSet(prevStatus, _nextStatus);\r\n    }\r\n\r\n    /// @notice Gets the current owner of the contract\r\n    /// @return owner_ The contract owner address\r\n    /// @dev Dynamically gets the owner based on the Protocol status. The owner is initially the\r\n    /// contract's deployer, for convenience in setting up configuration.\r\n    /// Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council)\r\n    /// sets the releaseStatus to `Live`.\r\n    function getOwner() public view override returns (address owner_) {\r\n        if (releaseStatus == ReleaseStatus.PreLaunch) {\r\n            return CREATOR;\r\n        }\r\n\r\n        return IDispatcher(DISPATCHER).getOwner();\r\n    }\r\n\r\n    ///////////////////\r\n    // FUND CREATION //\r\n    ///////////////////\r\n\r\n    /// @notice Creates a fully-configured ComptrollerProxy, to which a fund from a previous\r\n    /// release can migrate in a subsequent step\r\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\r\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\r\n    /// (buying or selling shares) by the same user\r\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\r\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\r\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\r\n    function createMigratedFundConfig(\r\n        address _denominationAsset,\r\n        uint256 _sharesActionTimelock,\r\n        bytes calldata _feeManagerConfigData,\r\n        bytes calldata _policyManagerConfigData\r\n    ) external onlyLiveRelease returns (address comptrollerProxy_) {\r\n        comptrollerProxy_ = __deployComptrollerProxy(\r\n            _denominationAsset,\r\n            _sharesActionTimelock,\r\n            _feeManagerConfigData,\r\n            _policyManagerConfigData,\r\n            true\r\n        );\r\n\r\n        pendingComptrollerProxyToCreator[comptrollerProxy_] = msg.sender;\r\n\r\n        return comptrollerProxy_;\r\n    }\r\n\r\n    /// @notice Creates a new fund\r\n    /// @param _fundOwner The address of the owner for the fund\r\n    /// @param _fundName The name of the fund\r\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\r\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\r\n    /// (buying or selling shares) by the same user\r\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\r\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\r\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\r\n    function createNewFund(\r\n        address _fundOwner,\r\n        string calldata _fundName,\r\n        address _denominationAsset,\r\n        uint256 _sharesActionTimelock,\r\n        bytes calldata _feeManagerConfigData,\r\n        bytes calldata _policyManagerConfigData\r\n    ) external onlyLiveRelease returns (address comptrollerProxy_, address vaultProxy_) {\r\n        return\r\n            __createNewFund(\r\n                _fundOwner,\r\n                _fundName,\r\n                _denominationAsset,\r\n                _sharesActionTimelock,\r\n                _feeManagerConfigData,\r\n                _policyManagerConfigData\r\n            );\r\n    }\r\n\r\n    /// @dev Helper to avoid the stack-too-deep error during createNewFund\r\n    function __createNewFund(\r\n        address _fundOwner,\r\n        string memory _fundName,\r\n        address _denominationAsset,\r\n        uint256 _sharesActionTimelock,\r\n        bytes memory _feeManagerConfigData,\r\n        bytes memory _policyManagerConfigData\r\n    ) private returns (address comptrollerProxy_, address vaultProxy_) {\r\n        require(_fundOwner != address(0), \"__createNewFund: _owner cannot be empty\");\r\n\r\n        comptrollerProxy_ = __deployComptrollerProxy(\r\n            _denominationAsset,\r\n            _sharesActionTimelock,\r\n            _feeManagerConfigData,\r\n            _policyManagerConfigData,\r\n            false\r\n        );\r\n\r\n        vaultProxy_ = IDispatcher(DISPATCHER).deployVaultProxy(\r\n            VAULT_LIB,\r\n            _fundOwner,\r\n            comptrollerProxy_,\r\n            _fundName\r\n        );\r\n\r\n        IComptroller(comptrollerProxy_).activate(vaultProxy_, false);\r\n\r\n        emit NewFundCreated(\r\n            msg.sender,\r\n            comptrollerProxy_,\r\n            vaultProxy_,\r\n            _fundOwner,\r\n            _fundName,\r\n            _denominationAsset,\r\n            _sharesActionTimelock,\r\n            _feeManagerConfigData,\r\n            _policyManagerConfigData\r\n        );\r\n\r\n        return (comptrollerProxy_, vaultProxy_);\r\n    }\r\n\r\n    /// @dev Helper function to deploy a configured ComptrollerProxy\r\n    function __deployComptrollerProxy(\r\n        address _denominationAsset,\r\n        uint256 _sharesActionTimelock,\r\n        bytes memory _feeManagerConfigData,\r\n        bytes memory _policyManagerConfigData,\r\n        bool _forMigration\r\n    ) private returns (address comptrollerProxy_) {\r\n        require(\r\n            _denominationAsset != address(0),\r\n            \"__deployComptrollerProxy: _denominationAsset cannot be empty\"\r\n        );\r\n\r\n        bytes memory constructData = abi.encodeWithSelector(\r\n            IComptroller.init.selector,\r\n            _denominationAsset,\r\n            _sharesActionTimelock\r\n        );\r\n        comptrollerProxy_ = address(new ComptrollerProxy(constructData, comptrollerLib));\r\n\r\n        if (_feeManagerConfigData.length > 0 || _policyManagerConfigData.length > 0) {\r\n            IComptroller(comptrollerProxy_).configureExtensions(\r\n                _feeManagerConfigData,\r\n                _policyManagerConfigData\r\n            );\r\n        }\r\n\r\n        emit ComptrollerProxyDeployed(\r\n            msg.sender,\r\n            comptrollerProxy_,\r\n            _denominationAsset,\r\n            _sharesActionTimelock,\r\n            _feeManagerConfigData,\r\n            _policyManagerConfigData,\r\n            _forMigration\r\n        );\r\n\r\n        return comptrollerProxy_;\r\n    }\r\n\r\n    //////////////////\r\n    // MIGRATION IN //\r\n    //////////////////\r\n\r\n    /// @notice Cancels fund migration\r\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\r\n    function cancelMigration(address _vaultProxy) external {\r\n        __cancelMigration(_vaultProxy, false);\r\n    }\r\n\r\n    /// @notice Cancels fund migration, bypassing any failures.\r\n    /// Should be used in an emergency only.\r\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\r\n    function cancelMigrationEmergency(address _vaultProxy) external {\r\n        __cancelMigration(_vaultProxy, true);\r\n    }\r\n\r\n    /// @notice Executes fund migration\r\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\r\n    function executeMigration(address _vaultProxy) external {\r\n        __executeMigration(_vaultProxy, false);\r\n    }\r\n\r\n    /// @notice Executes fund migration, bypassing any failures.\r\n    /// Should be used in an emergency only.\r\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\r\n    function executeMigrationEmergency(address _vaultProxy) external {\r\n        __executeMigration(_vaultProxy, true);\r\n    }\r\n\r\n    /// @dev Unimplemented\r\n    function invokeMigrationInCancelHook(\r\n        address,\r\n        address,\r\n        address,\r\n        address\r\n    ) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Signal a fund migration\r\n    /// @param _vaultProxy The VaultProxy for which to signal the migration\r\n    /// @param _comptrollerProxy The ComptrollerProxy for which to signal the migration\r\n    function signalMigration(address _vaultProxy, address _comptrollerProxy) external {\r\n        __signalMigration(_vaultProxy, _comptrollerProxy, false);\r\n    }\r\n\r\n    /// @notice Signal a fund migration, bypassing any failures.\r\n    /// Should be used in an emergency only.\r\n    /// @param _vaultProxy The VaultProxy for which to signal the migration\r\n    /// @param _comptrollerProxy The ComptrollerProxy for which to signal the migration\r\n    function signalMigrationEmergency(address _vaultProxy, address _comptrollerProxy) external {\r\n        __signalMigration(_vaultProxy, _comptrollerProxy, true);\r\n    }\r\n\r\n    /// @dev Helper to cancel a migration\r\n    function __cancelMigration(address _vaultProxy, bool _bypassFailure)\r\n        private\r\n        onlyLiveRelease\r\n        onlyMigrator(_vaultProxy)\r\n    {\r\n        IDispatcher(DISPATCHER).cancelMigration(_vaultProxy, _bypassFailure);\r\n    }\r\n\r\n    /// @dev Helper to execute a migration\r\n    function __executeMigration(address _vaultProxy, bool _bypassFailure)\r\n        private\r\n        onlyLiveRelease\r\n        onlyMigrator(_vaultProxy)\r\n    {\r\n        IDispatcher dispatcherContract = IDispatcher(DISPATCHER);\r\n\r\n        (, address comptrollerProxy, , ) = dispatcherContract\r\n            .getMigrationRequestDetailsForVaultProxy(_vaultProxy);\r\n\r\n        dispatcherContract.executeMigration(_vaultProxy, _bypassFailure);\r\n\r\n        IComptroller(comptrollerProxy).activate(_vaultProxy, true);\r\n\r\n        delete pendingComptrollerProxyToCreator[comptrollerProxy];\r\n    }\r\n\r\n    /// @dev Helper to signal a migration\r\n    function __signalMigration(\r\n        address _vaultProxy,\r\n        address _comptrollerProxy,\r\n        bool _bypassFailure\r\n    )\r\n        private\r\n        onlyLiveRelease\r\n        onlyPendingComptrollerProxyCreator(_comptrollerProxy)\r\n        onlyMigrator(_vaultProxy)\r\n    {\r\n        IDispatcher(DISPATCHER).signalMigration(\r\n            _vaultProxy,\r\n            _comptrollerProxy,\r\n            VAULT_LIB,\r\n            _bypassFailure\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // MIGRATION OUT //\r\n    ///////////////////\r\n\r\n    /// @notice Allows \"hooking into\" specific moments in the migration pipeline\r\n    /// to execute arbitrary logic during a migration out of this release\r\n    /// @param _vaultProxy The VaultProxy being migrated\r\n    function invokeMigrationOutHook(\r\n        MigrationOutHook _hook,\r\n        address _vaultProxy,\r\n        address,\r\n        address,\r\n        address\r\n    ) external override {\r\n        if (_hook != MigrationOutHook.PreMigrate) {\r\n            return;\r\n        }\r\n\r\n        require(\r\n            msg.sender == DISPATCHER,\r\n            \"postMigrateOriginHook: Only Dispatcher can call this function\"\r\n        );\r\n\r\n        // Must use PreMigrate hook to get the ComptrollerProxy from the VaultProxy\r\n        address comptrollerProxy = IVault(_vaultProxy).getAccessor();\r\n\r\n        // Wind down fund and destroy its config\r\n        IComptroller(comptrollerProxy).destruct();\r\n    }\r\n\r\n    //////////////\r\n    // REGISTRY //\r\n    //////////////\r\n\r\n    /// @notice De-registers allowed arbitrary contract calls that can be sent from the VaultProxy\r\n    /// @param _contracts The contracts of the calls to de-register\r\n    /// @param _selectors The selectors of the calls to de-register\r\n    function deregisterVaultCalls(address[] calldata _contracts, bytes4[] calldata _selectors)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_contracts.length > 0, \"deregisterVaultCalls: Empty _contracts\");\r\n        require(\r\n            _contracts.length == _selectors.length,\r\n            \"deregisterVaultCalls: Uneven input arrays\"\r\n        );\r\n\r\n        for (uint256 i; i < _contracts.length; i++) {\r\n            require(\r\n                isRegisteredVaultCall(_contracts[i], _selectors[i]),\r\n                \"deregisterVaultCalls: Call not registered\"\r\n            );\r\n\r\n            contractToSelectorToIsRegisteredVaultCall[_contracts[i]][_selectors[i]] = false;\r\n\r\n            emit VaultCallDeregistered(_contracts[i], _selectors[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Registers allowed arbitrary contract calls that can be sent from the VaultProxy\r\n    /// @param _contracts The contracts of the calls to register\r\n    /// @param _selectors The selectors of the calls to register\r\n    function registerVaultCalls(address[] calldata _contracts, bytes4[] calldata _selectors)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_contracts.length > 0, \"registerVaultCalls: Empty _contracts\");\r\n\r\n        __registerVaultCalls(_contracts, _selectors);\r\n    }\r\n\r\n    /// @dev Helper to register allowed vault calls\r\n    function __registerVaultCalls(address[] memory _contracts, bytes4[] memory _selectors)\r\n        private\r\n    {\r\n        require(\r\n            _contracts.length == _selectors.length,\r\n            \"__registerVaultCalls: Uneven input arrays\"\r\n        );\r\n\r\n        for (uint256 i; i < _contracts.length; i++) {\r\n            require(\r\n                !isRegisteredVaultCall(_contracts[i], _selectors[i]),\r\n                \"__registerVaultCalls: Call already registered\"\r\n            );\r\n\r\n            contractToSelectorToIsRegisteredVaultCall[_contracts[i]][_selectors[i]] = true;\r\n\r\n            emit VaultCallRegistered(_contracts[i], _selectors[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `comptrollerLib` variable value\r\n    /// @return comptrollerLib_ The `comptrollerLib` variable value\r\n    function getComptrollerLib() external view returns (address comptrollerLib_) {\r\n        return comptrollerLib;\r\n    }\r\n\r\n    /// @notice Gets the `CREATOR` variable value\r\n    /// @return creator_ The `CREATOR` variable value\r\n    function getCreator() external view returns (address creator_) {\r\n        return CREATOR;\r\n    }\r\n\r\n    /// @notice Gets the `DISPATCHER` variable value\r\n    /// @return dispatcher_ The `DISPATCHER` variable value\r\n    function getDispatcher() external view returns (address dispatcher_) {\r\n        return DISPATCHER;\r\n    }\r\n\r\n    /// @notice Gets the creator of a pending ComptrollerProxy\r\n    /// @return pendingComptrollerProxyCreator_ The pending ComptrollerProxy creator\r\n    function getPendingComptrollerProxyCreator(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (address pendingComptrollerProxyCreator_)\r\n    {\r\n        return pendingComptrollerProxyToCreator[_comptrollerProxy];\r\n    }\r\n\r\n    /// @notice Gets the `releaseStatus` variable value\r\n    /// @return status_ The `releaseStatus` variable value\r\n    function getReleaseStatus() external view override returns (ReleaseStatus status_) {\r\n        return releaseStatus;\r\n    }\r\n\r\n    /// @notice Gets the `VAULT_LIB` variable value\r\n    /// @return vaultLib_ The `VAULT_LIB` variable value\r\n    function getVaultLib() external view returns (address vaultLib_) {\r\n        return VAULT_LIB;\r\n    }\r\n\r\n    /// @notice Checks if a contract call is registered\r\n    /// @param _contract The contract of the call to check\r\n    /// @param _selector The selector of the call to check\r\n    /// @return isRegistered_ True if the call is registered\r\n    function isRegisteredVaultCall(address _contract, bytes4 _selector)\r\n        public\r\n        view\r\n        override\r\n        returns (bool isRegistered_)\r\n    {\r\n        return contractToSelectorToIsRegisteredVaultCall[_contract][_selector];\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/utils/IMigrationHookHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IMigrationHookHandler Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IMigrationHookHandler {\r\n    enum MigrationOutHook {PreSignal, PostSignal, PreMigrate, PostMigrate, PostCancel}\r\n\r\n    function invokeMigrationInCancelHook(\r\n        address _vaultProxy,\r\n        address _prevFundDeployer,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib\r\n    ) external;\r\n\r\n    function invokeMigrationOutHook(\r\n        MigrationOutHook _hook,\r\n        address _vaultProxy,\r\n        address _nextFundDeployer,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib\r\n    ) external;\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/PolicyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"../../core/fund/vault/IVault.sol\";\r\nimport \"../utils/ExtensionBase.sol\";\r\nimport \"../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"./IPolicy.sol\";\r\nimport \"./IPolicyManager.sol\";\r\n\r\n/// @title PolicyManager Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Manages policies for funds\r\ncontract PolicyManager is IPolicyManager, ExtensionBase, FundDeployerOwnerMixin {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    event PolicyDeregistered(address indexed policy, string indexed identifier);\r\n\r\n    event PolicyDisabledForFund(address indexed comptrollerProxy, address indexed policy);\r\n\r\n    event PolicyEnabledForFund(\r\n        address indexed comptrollerProxy,\r\n        address indexed policy,\r\n        bytes settingsData\r\n    );\r\n\r\n    event PolicyRegistered(\r\n        address indexed policy,\r\n        string indexed identifier,\r\n        PolicyHook[] implementedHooks\r\n    );\r\n\r\n    EnumerableSet.AddressSet private registeredPolicies;\r\n    mapping(address => mapping(PolicyHook => bool)) private policyToHookToIsImplemented;\r\n    mapping(address => EnumerableSet.AddressSet) private comptrollerProxyToPolicies;\r\n\r\n    modifier onlyBuySharesHooks(address _policy) {\r\n        require(\r\n            !policyImplementsHook(_policy, PolicyHook.PreCallOnIntegration) &&\r\n                !policyImplementsHook(_policy, PolicyHook.PostCallOnIntegration),\r\n            \"onlyBuySharesHooks: Disallowed hook\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabledPolicyForFund(address _comptrollerProxy, address _policy) {\r\n        require(\r\n            policyIsEnabledForFund(_comptrollerProxy, _policy),\r\n            \"onlyEnabledPolicyForFund: Policy not enabled\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Validates and initializes policies as necessary prior to fund activation\r\n    /// @param _isMigratedFund True if the fund is migrating to this release\r\n    /// @dev Caller is expected to be a valid ComptrollerProxy, but there isn't a need to validate.\r\n    function activateForFund(bool _isMigratedFund) external override {\r\n        address vaultProxy = __setValidatedVaultProxy(msg.sender);\r\n\r\n        // Policies must assert that they are congruent with migrated vault state\r\n        if (_isMigratedFund) {\r\n            address[] memory enabledPolicies = getEnabledPoliciesForFund(msg.sender);\r\n            for (uint256 i; i < enabledPolicies.length; i++) {\r\n                __activatePolicyForFund(msg.sender, vaultProxy, enabledPolicies[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Deactivates policies for a fund by destroying storage\r\n    function deactivateForFund() external override {\r\n        delete comptrollerProxyToVaultProxy[msg.sender];\r\n\r\n        for (uint256 i = comptrollerProxyToPolicies[msg.sender].length(); i > 0; i--) {\r\n            comptrollerProxyToPolicies[msg.sender].remove(\r\n                comptrollerProxyToPolicies[msg.sender].at(i - 1)\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Disables a policy for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _policy The policy address to disable\r\n    function disablePolicyForFund(address _comptrollerProxy, address _policy)\r\n        external\r\n        onlyBuySharesHooks(_policy)\r\n        onlyEnabledPolicyForFund(_comptrollerProxy, _policy)\r\n    {\r\n        __validateIsFundOwner(getVaultProxyForFund(_comptrollerProxy), msg.sender);\r\n\r\n        comptrollerProxyToPolicies[_comptrollerProxy].remove(_policy);\r\n\r\n        emit PolicyDisabledForFund(_comptrollerProxy, _policy);\r\n    }\r\n\r\n    /// @notice Enables a policy for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _policy The policy address to enable\r\n    /// @param _settingsData The encoded settings data with which to configure the policy\r\n    /// @dev Disabling a policy does not delete fund config on the policy, so if a policy is\r\n    /// disabled and then enabled again, its initial state will be the previous config. It is the\r\n    /// policy's job to determine how to merge that config with the _settingsData param in this function.\r\n    function enablePolicyForFund(\r\n        address _comptrollerProxy,\r\n        address _policy,\r\n        bytes calldata _settingsData\r\n    ) external onlyBuySharesHooks(_policy) {\r\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\r\n        __validateIsFundOwner(vaultProxy, msg.sender);\r\n\r\n        __enablePolicyForFund(_comptrollerProxy, _policy, _settingsData);\r\n\r\n        __activatePolicyForFund(_comptrollerProxy, vaultProxy, _policy);\r\n    }\r\n\r\n    /// @notice Enable policies for use in a fund\r\n    /// @param _configData Encoded config data\r\n    /// @dev Only called during init() on ComptrollerProxy deployment\r\n    function setConfigForFund(bytes calldata _configData) external override {\r\n        (address[] memory policies, bytes[] memory settingsData) = abi.decode(\r\n            _configData,\r\n            (address[], bytes[])\r\n        );\r\n\r\n        // Sanity check\r\n        require(\r\n            policies.length == settingsData.length,\r\n            \"setConfigForFund: policies and settingsData array lengths unequal\"\r\n        );\r\n\r\n        // Enable each policy with settings\r\n        for (uint256 i; i < policies.length; i++) {\r\n            __enablePolicyForFund(msg.sender, policies[i], settingsData[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Updates policy settings for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _policy The Policy contract to update\r\n    /// @param _settingsData The encoded settings data with which to update the policy config\r\n    function updatePolicySettingsForFund(\r\n        address _comptrollerProxy,\r\n        address _policy,\r\n        bytes calldata _settingsData\r\n    ) external onlyBuySharesHooks(_policy) onlyEnabledPolicyForFund(_comptrollerProxy, _policy) {\r\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\r\n        __validateIsFundOwner(vaultProxy, msg.sender);\r\n\r\n        IPolicy(_policy).updateFundSettings(_comptrollerProxy, vaultProxy, _settingsData);\r\n    }\r\n\r\n    /// @notice Validates all policies that apply to a given hook for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _hook The PolicyHook for which to validate policies\r\n    /// @param _validationData The encoded data with which to validate the filtered policies\r\n    function validatePolicies(\r\n        address _comptrollerProxy,\r\n        PolicyHook _hook,\r\n        bytes calldata _validationData\r\n    ) external override {\r\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\r\n        address[] memory policies = getEnabledPoliciesForFund(_comptrollerProxy);\r\n        for (uint256 i; i < policies.length; i++) {\r\n            if (!policyImplementsHook(policies[i], _hook)) {\r\n                continue;\r\n            }\r\n\r\n            require(\r\n                IPolicy(policies[i]).validateRule(\r\n                    _comptrollerProxy,\r\n                    vaultProxy,\r\n                    _hook,\r\n                    _validationData\r\n                ),\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"Rule evaluated to false: \",\r\n                        IPolicy(policies[i]).identifier()\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to activate a policy for a fund\r\n    function __activatePolicyForFund(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        address _policy\r\n    ) private {\r\n        IPolicy(_policy).activateForFund(_comptrollerProxy, _vaultProxy);\r\n    }\r\n\r\n    /// @dev Helper to set config and enable policies for a fund\r\n    function __enablePolicyForFund(\r\n        address _comptrollerProxy,\r\n        address _policy,\r\n        bytes memory _settingsData\r\n    ) private {\r\n        require(\r\n            !policyIsEnabledForFund(_comptrollerProxy, _policy),\r\n            \"__enablePolicyForFund: policy already enabled\"\r\n        );\r\n        require(policyIsRegistered(_policy), \"__enablePolicyForFund: Policy is not registered\");\r\n\r\n        // Set fund config on policy\r\n        if (_settingsData.length > 0) {\r\n            IPolicy(_policy).addFundSettings(_comptrollerProxy, _settingsData);\r\n        }\r\n\r\n        // Add policy\r\n        comptrollerProxyToPolicies[_comptrollerProxy].add(_policy);\r\n\r\n        emit PolicyEnabledForFund(_comptrollerProxy, _policy, _settingsData);\r\n    }\r\n\r\n    /// @dev Helper to validate fund owner.\r\n    /// Preferred to a modifier because allows gas savings if re-using _vaultProxy.\r\n    function __validateIsFundOwner(address _vaultProxy, address _who) private view {\r\n        require(\r\n            _who == IVault(_vaultProxy).getOwner(),\r\n            \"Only the fund owner can call this function\"\r\n        );\r\n    }\r\n\r\n    ///////////////////////\r\n    // POLICIES REGISTRY //\r\n    ///////////////////////\r\n\r\n    /// @notice Remove policies from the list of registered policies\r\n    /// @param _policies Addresses of policies to be registered\r\n    function deregisterPolicies(address[] calldata _policies) external onlyFundDeployerOwner {\r\n        require(_policies.length > 0, \"deregisterPolicies: _policies cannot be empty\");\r\n\r\n        for (uint256 i; i < _policies.length; i++) {\r\n            require(\r\n                policyIsRegistered(_policies[i]),\r\n                \"deregisterPolicies: policy is not registered\"\r\n            );\r\n\r\n            registeredPolicies.remove(_policies[i]);\r\n\r\n            emit PolicyDeregistered(_policies[i], IPolicy(_policies[i]).identifier());\r\n        }\r\n    }\r\n\r\n    /// @notice Add policies to the list of registered policies\r\n    /// @param _policies Addresses of policies to be registered\r\n    function registerPolicies(address[] calldata _policies) external onlyFundDeployerOwner {\r\n        require(_policies.length > 0, \"registerPolicies: _policies cannot be empty\");\r\n\r\n        for (uint256 i; i < _policies.length; i++) {\r\n            require(\r\n                !policyIsRegistered(_policies[i]),\r\n                \"registerPolicies: policy already registered\"\r\n            );\r\n\r\n            registeredPolicies.add(_policies[i]);\r\n\r\n            // Store the hooks that a policy implements for later use.\r\n            // Fronts the gas for calls to check if a hook is implemented, and guarantees\r\n            // that the implementsHooks return value does not change post-registration.\r\n            IPolicy policyContract = IPolicy(_policies[i]);\r\n            PolicyHook[] memory implementedHooks = policyContract.implementedHooks();\r\n            for (uint256 j; j < implementedHooks.length; j++) {\r\n                policyToHookToIsImplemented[_policies[i]][implementedHooks[j]] = true;\r\n            }\r\n\r\n            emit PolicyRegistered(_policies[i], policyContract.identifier(), implementedHooks);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Get all registered policies\r\n    /// @return registeredPoliciesArray_ A list of all registered policy addresses\r\n    function getRegisteredPolicies()\r\n        external\r\n        view\r\n        returns (address[] memory registeredPoliciesArray_)\r\n    {\r\n        registeredPoliciesArray_ = new address[](registeredPolicies.length());\r\n        for (uint256 i; i < registeredPoliciesArray_.length; i++) {\r\n            registeredPoliciesArray_[i] = registeredPolicies.at(i);\r\n        }\r\n    }\r\n\r\n    /// @notice Get a list of enabled policies for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return enabledPolicies_ An array of enabled policy addresses\r\n    function getEnabledPoliciesForFund(address _comptrollerProxy)\r\n        public\r\n        view\r\n        returns (address[] memory enabledPolicies_)\r\n    {\r\n        enabledPolicies_ = new address[](comptrollerProxyToPolicies[_comptrollerProxy].length());\r\n        for (uint256 i; i < enabledPolicies_.length; i++) {\r\n            enabledPolicies_[i] = comptrollerProxyToPolicies[_comptrollerProxy].at(i);\r\n        }\r\n    }\r\n\r\n    /// @notice Checks if a policy implements a particular hook\r\n    /// @param _policy The address of the policy to check\r\n    /// @param _hook The PolicyHook to check\r\n    /// @return implementsHook_ True if the policy implements the hook\r\n    function policyImplementsHook(address _policy, PolicyHook _hook)\r\n        public\r\n        view\r\n        returns (bool implementsHook_)\r\n    {\r\n        return policyToHookToIsImplemented[_policy][_hook];\r\n    }\r\n\r\n    /// @notice Check if a policy is enabled for the fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund to check\r\n    /// @param _policy The address of the policy to check\r\n    /// @return isEnabled_ True if the policy is enabled for the fund\r\n    function policyIsEnabledForFund(address _comptrollerProxy, address _policy)\r\n        public\r\n        view\r\n        returns (bool isEnabled_)\r\n    {\r\n        return comptrollerProxyToPolicies[_comptrollerProxy].contains(_policy);\r\n    }\r\n\r\n    /// @notice Check whether a policy is registered\r\n    /// @param _policy The address of the policy to check\r\n    /// @return isRegistered_ True if the policy is registered\r\n    function policyIsRegistered(address _policy) public view returns (bool isRegistered_) {\r\n        return registeredPolicies.contains(_policy);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/IPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IPolicyManager.sol\";\r\n\r\n/// @title Policy Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IPolicy {\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\r\n\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings) external;\r\n\r\n    function identifier() external pure returns (string memory identifier_);\r\n\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_);\r\n\r\n    function updateFundSettings(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        bytes calldata _encodedSettings\r\n    ) external;\r\n\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IPolicyManager.PolicyHook _hook,\r\n        bytes calldata _encodedArgs\r\n    ) external returns (bool isValid_);\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/PolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../IPolicy.sol\";\r\n\r\n/// @title PolicyBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Abstract base contract for all policies\r\nabstract contract PolicyBase is IPolicy {\r\n    address internal immutable POLICY_MANAGER;\r\n\r\n    modifier onlyPolicyManager() {\r\n        require(msg.sender == POLICY_MANAGER, \"Only the PolicyManager can make this call\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _policyManager) public {\r\n        POLICY_MANAGER = _policyManager;\r\n    }\r\n\r\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\r\n    /// @dev Unimplemented by default, can be overridden by the policy\r\n    function activateForFund(address, address) external virtual override {\r\n        return;\r\n    }\r\n\r\n    /// @notice Updates the policy settings for a fund\r\n    /// @dev Disallowed by default, can be overridden by the policy\r\n    function updateFundSettings(\r\n        address,\r\n        address,\r\n        bytes calldata\r\n    ) external virtual override {\r\n        revert(\"updateFundSettings: Updates not allowed for this policy\");\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `POLICY_MANAGER` variable value\r\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\r\n    function getPolicyManager() external view returns (address policyManager_) {\r\n        return POLICY_MANAGER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/utils/PostCallOnIntegrationValidatePolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/PolicyBase.sol\";\r\n\r\n/// @title CallOnIntegrationPostValidatePolicyMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract for policies that only implement the PostCallOnIntegration policy hook\r\nabstract contract PostCallOnIntegrationValidatePolicyBase is PolicyBase {\r\n    /// @notice Gets the implemented PolicyHooks for a policy\r\n    /// @return implementedHooks_ The implemented PolicyHooks\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\r\n    {\r\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\r\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostCallOnIntegration;\r\n\r\n        return implementedHooks_;\r\n    }\r\n\r\n    /// @notice Helper to decode rule arguments\r\n    function __decodeRuleArgs(bytes memory _encodedRuleArgs)\r\n        internal\r\n        pure\r\n        returns (\r\n            address adapter_,\r\n            bytes4 selector_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory incomingAssetAmounts_,\r\n            address[] memory outgoingAssets_,\r\n            uint256[] memory outgoingAssetAmounts_\r\n        )\r\n    {\r\n        return\r\n            abi.decode(\r\n                _encodedRuleArgs,\r\n                (address, bytes4, address[], uint256[], address[], uint256[])\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/MaxConcentration.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../../../../core/fund/vault/VaultLib.sol\";\r\nimport \"../../../../infrastructure/value-interpreter/ValueInterpreter.sol\";\r\nimport \"./utils/PostCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title MaxConcentration Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that defines a configurable threshold for the concentration of any one asset\r\n/// in a fund's holdings\r\ncontract MaxConcentration is PostCallOnIntegrationValidatePolicyBase {\r\n    using SafeMath for uint256;\r\n\r\n    event MaxConcentrationSet(address indexed comptrollerProxy, uint256 value);\r\n\r\n    uint256 private constant ONE_HUNDRED_PERCENT = 10**18; // 100%\r\n\r\n    address private immutable VALUE_INTERPRETER;\r\n\r\n    mapping(address => uint256) private comptrollerProxyToMaxConcentration;\r\n\r\n    constructor(address _policyManager, address _valueInterpreter)\r\n        public\r\n        PolicyBase(_policyManager)\r\n    {\r\n        VALUE_INTERPRETER = _valueInterpreter;\r\n    }\r\n\r\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _vaultProxy The fund's VaultProxy address\r\n    /// @dev No need to authenticate access, as there are no state transitions\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        require(\r\n            passesRule(_comptrollerProxy, _vaultProxy, VaultLib(_vaultProxy).getTrackedAssets()),\r\n            \"activateForFund: Max concentration exceeded\"\r\n        );\r\n    }\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        uint256 maxConcentration = abi.decode(_encodedSettings, (uint256));\r\n        require(maxConcentration > 0, \"addFundSettings: maxConcentration must be greater than 0\");\r\n        require(\r\n            maxConcentration <= ONE_HUNDRED_PERCENT,\r\n            \"addFundSettings: maxConcentration cannot exceed 100%\"\r\n        );\r\n\r\n        comptrollerProxyToMaxConcentration[_comptrollerProxy] = maxConcentration;\r\n\r\n        emit MaxConcentrationSet(_comptrollerProxy, maxConcentration);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"MAX_CONCENTRATION\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _vaultProxy The fund's VaultProxy address\r\n    /// @param _assets The assets with which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    /// @dev The fund's denomination asset is exempt from the policy limit.\r\n    function passesRule(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        address[] memory _assets\r\n    ) public returns (bool isValid_) {\r\n        uint256 maxConcentration = comptrollerProxyToMaxConcentration[_comptrollerProxy];\r\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\r\n        address denominationAsset = comptrollerProxyContract.getDenominationAsset();\r\n        // Does not require asset finality, otherwise will fail when incoming asset is a Synth\r\n        (uint256 totalGav, bool gavIsValid) = comptrollerProxyContract.calcGav(false);\r\n        if (!gavIsValid) {\r\n            return false;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _assets.length; i++) {\r\n            address asset = _assets[i];\r\n            if (\r\n                !__rulePassesForAsset(\r\n                    _vaultProxy,\r\n                    denominationAsset,\r\n                    maxConcentration,\r\n                    totalGav,\r\n                    asset\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _vaultProxy The fund's VaultProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address _vaultProxy,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (, , address[] memory incomingAssets, , , ) = __decodeRuleArgs(_encodedArgs);\r\n        if (incomingAssets.length == 0) {\r\n            return true;\r\n        }\r\n\r\n        return passesRule(_comptrollerProxy, _vaultProxy, incomingAssets);\r\n    }\r\n\r\n    /// @dev Helper to check if the rule holds for a particular asset.\r\n    /// Avoids the stack-too-deep error.\r\n    function __rulePassesForAsset(\r\n        address _vaultProxy,\r\n        address _denominationAsset,\r\n        uint256 _maxConcentration,\r\n        uint256 _totalGav,\r\n        address _incomingAsset\r\n    ) private returns (bool isValid_) {\r\n        if (_incomingAsset == _denominationAsset) return true;\r\n\r\n        uint256 assetBalance = ERC20(_incomingAsset).balanceOf(_vaultProxy);\r\n        (uint256 assetGav, bool assetGavIsValid) = ValueInterpreter(VALUE_INTERPRETER)\r\n            .calcLiveAssetValue(_incomingAsset, assetBalance, _denominationAsset);\r\n\r\n        if (\r\n            !assetGavIsValid ||\r\n            assetGav.mul(ONE_HUNDRED_PERCENT).div(_totalGav) > _maxConcentration\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the maxConcentration for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return maxConcentration_ The maxConcentration\r\n    function getMaxConcentrationForFund(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (uint256 maxConcentration_)\r\n    {\r\n        return comptrollerProxyToMaxConcentration[_comptrollerProxy];\r\n    }\r\n\r\n    /// @notice Gets the `VALUE_INTERPRETER` variable\r\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\r\n    function getValueInterpreter() external view returns (address valueInterpreter_) {\r\n        return VALUE_INTERPRETER;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/prices/CentralizedRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../release/infrastructure/value-interpreter/IValueInterpreter.sol\";\r\nimport \"../../release/infrastructure/price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol\";\r\nimport \"../../release/infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol\";\r\n\r\n/// @dev This contract acts as a centralized rate provider for mocks.\r\n/// Suited for a dev environment, it doesn't take into account gas costs.\r\ncontract CentralizedRateProvider is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable WETH;\r\n    uint256 private maxDeviationPerSender;\r\n\r\n    // Addresses are not immutable to facilitate lazy load (they're are not accessible at the mock env).\r\n    address private valueInterpreter;\r\n    address private aggregateDerivativePriceFeed;\r\n    address private primitivePriceFeed;\r\n\r\n    constructor(address _weth, uint256 _maxDeviationPerSender) public {\r\n        maxDeviationPerSender = _maxDeviationPerSender;\r\n        WETH = _weth;\r\n    }\r\n\r\n    /// @dev Calculates the value of a _baseAsset relative to a _quoteAsset.\r\n    /// Label to ValueInterprete's calcLiveAssetValue\r\n    function calcLiveAssetValue(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) public returns (uint256 value_) {\r\n        uint256 baseDecimalsRate = 10**uint256(ERC20(_baseAsset).decimals());\r\n        uint256 quoteDecimalsRate = 10**uint256(ERC20(_quoteAsset).decimals());\r\n\r\n        // 1. Check if quote asset is a primitive. If it is, use ValueInterpreter normally.\r\n        if (IPrimitivePriceFeed(primitivePriceFeed).isSupportedAsset(_quoteAsset)) {\r\n            (value_, ) = IValueInterpreter(valueInterpreter).calcLiveAssetValue(\r\n                _baseAsset,\r\n                _amount,\r\n                _quoteAsset\r\n            );\r\n            return value_;\r\n        }\r\n\r\n        // 2. Otherwise, check if base asset is a primitive, and use inverse rate from Value Interpreter.\r\n        if (IPrimitivePriceFeed(primitivePriceFeed).isSupportedAsset(_baseAsset)) {\r\n            (uint256 inverseRate, ) = IValueInterpreter(valueInterpreter).calcLiveAssetValue(\r\n                _quoteAsset,\r\n                10**uint256(ERC20(_quoteAsset).decimals()),\r\n                _baseAsset\r\n            );\r\n\r\n            uint256 rate = uint256(baseDecimalsRate).mul(quoteDecimalsRate).div(inverseRate);\r\n\r\n            value_ = _amount.mul(rate).div(baseDecimalsRate);\r\n            return value_;\r\n        }\r\n\r\n        // 3. If both assets are derivatives, calculate the rate against ETH.\r\n        (uint256 baseToWeth, ) = IValueInterpreter(valueInterpreter).calcLiveAssetValue(\r\n            _baseAsset,\r\n            baseDecimalsRate,\r\n            WETH\r\n        );\r\n\r\n        (uint256 quoteToWeth, ) = IValueInterpreter(valueInterpreter).calcLiveAssetValue(\r\n            _quoteAsset,\r\n            quoteDecimalsRate,\r\n            WETH\r\n        );\r\n\r\n        value_ = _amount.mul(baseToWeth).mul(quoteDecimalsRate).div(quoteToWeth).div(\r\n            baseDecimalsRate\r\n        );\r\n        return value_;\r\n    }\r\n\r\n    /// @dev Calculates a randomized live value of an asset\r\n    /// Aggregation of two randomization seeds: msg.sender, and by block.number.\r\n    function calcLiveAssetValueRandomized(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset,\r\n        uint256 _maxDeviationPerBlock\r\n    ) external returns (uint256 value_) {\r\n        uint256 liveAssetValue = calcLiveAssetValue(_baseAsset, _amount, _quoteAsset);\r\n\r\n        // Range [liveAssetValue * (1 - _blockNumberDeviation), liveAssetValue * (1 + _blockNumberDeviation)]\r\n        uint256 senderRandomizedValue_ = __calcValueRandomizedByAddress(\r\n            liveAssetValue,\r\n            msg.sender,\r\n            maxDeviationPerSender\r\n        );\r\n\r\n        // Range [liveAssetValue * (1 - _maxDeviationPerBlock - maxDeviationPerSender), liveAssetValue * (1 + _maxDeviationPerBlock + maxDeviationPerSender)]\r\n        value_ = __calcValueRandomizedByUint(\r\n            senderRandomizedValue_,\r\n            block.number,\r\n            _maxDeviationPerBlock\r\n        );\r\n\r\n        return value_;\r\n    }\r\n\r\n    /// @dev Calculates the live value of an asset including a grade of pseudo randomization, using msg.sender as the source of randomness\r\n    function calcLiveAssetValueRandomizedByBlockNumber(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset,\r\n        uint256 _maxDeviationPerBlock\r\n    ) external returns (uint256 value_) {\r\n        uint256 liveAssetValue = calcLiveAssetValue(_baseAsset, _amount, _quoteAsset);\r\n\r\n        value_ = __calcValueRandomizedByUint(liveAssetValue, block.number, _maxDeviationPerBlock);\r\n\r\n        return value_;\r\n    }\r\n\r\n    /// @dev Calculates the live value of an asset including a grade of pseudo-randomization, using `block.number` as the source of randomness\r\n    function calcLiveAssetValueRandomizedBySender(\r\n        address _baseAsset,\r\n        uint256 _amount,\r\n        address _quoteAsset\r\n    ) external returns (uint256 value_) {\r\n        uint256 liveAssetValue = calcLiveAssetValue(_baseAsset, _amount, _quoteAsset);\r\n\r\n        value_ = __calcValueRandomizedByAddress(liveAssetValue, msg.sender, maxDeviationPerSender);\r\n\r\n        return value_;\r\n    }\r\n\r\n    function setMaxDeviationPerSender(uint256 _maxDeviationPerSender) external onlyOwner {\r\n        maxDeviationPerSender = _maxDeviationPerSender;\r\n    }\r\n\r\n    /// @dev Connector from release environment, inject price variables into the provider.\r\n    function setReleasePriceAddresses(\r\n        address _valueInterpreter,\r\n        address _aggregateDerivativePriceFeed,\r\n        address _primitivePriceFeed\r\n    ) external onlyOwner {\r\n        valueInterpreter = _valueInterpreter;\r\n        aggregateDerivativePriceFeed = _aggregateDerivativePriceFeed;\r\n        primitivePriceFeed = _primitivePriceFeed;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Calculates a a pseudo-randomized value as a seed an address\r\n    function __calcValueRandomizedByAddress(\r\n        uint256 _meanValue,\r\n        address _seed,\r\n        uint256 _maxDeviation\r\n    ) private pure returns (uint256 value_) {\r\n        // Value between [0, 100]\r\n        uint256 senderRandomFactor = uint256(uint8(_seed))\r\n            .mul(100)\r\n            .div(256)\r\n            .mul(_maxDeviation)\r\n            .div(100);\r\n\r\n        value_ = __calcDeviatedValue(_meanValue, senderRandomFactor, _maxDeviation);\r\n\r\n        return value_;\r\n    }\r\n\r\n    /// @dev Calculates a a pseudo-randomized value as a seed an uint256\r\n    function __calcValueRandomizedByUint(\r\n        uint256 _meanValue,\r\n        uint256 _seed,\r\n        uint256 _maxDeviation\r\n    ) private pure returns (uint256 value_) {\r\n        // Depending on the _seed number, it will be one of {20, 40, 60, 80, 100}\r\n        uint256 randomFactor = (_seed.mod(2).mul(20))\r\n            .add((_seed.mod(3).mul(40)))\r\n            .mul(_maxDeviation)\r\n            .div(100);\r\n\r\n        value_ = __calcDeviatedValue(_meanValue, randomFactor, _maxDeviation);\r\n\r\n        return value_;\r\n    }\r\n\r\n    /// @dev Given a mean value and a max deviation, returns a value in the spectrum between 0 (_meanValue - maxDeviation) and 100 (_mean + maxDeviation)\r\n    /// TODO: Refactor to use 18 decimal precision\r\n    function __calcDeviatedValue(\r\n        uint256 _meanValue,\r\n        uint256 _offset,\r\n        uint256 _maxDeviation\r\n    ) private pure returns (uint256 value_) {\r\n        return\r\n            _meanValue.add((_meanValue.mul((uint256(2)).mul(_offset)).div(uint256(100)))).sub(\r\n                _meanValue.mul(_maxDeviation).div(uint256(100))\r\n            );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    function getMaxDeviationPerSender() public view returns (uint256 maxDeviationPerSender_) {\r\n        return maxDeviationPerSender;\r\n    }\r\n\r\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\r\n        return valueInterpreter;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/mocks/prices/MockUniswapV2PriceSource.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../release/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../prices/CentralizedRateProvider.sol\";\r\nimport \"../tokens/MockToken.sol\";\r\n\r\n/// @dev This price source mocks the integration with Uniswap Pair\r\n/// Docs of Uniswap Pair implementation: <https://uniswap.org/docs/v2/smart-contracts/pair/>\r\ncontract MockUniswapV2PriceSource is MockToken(\"Uniswap V2\", \"UNI-V2\", 18) {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable TOKEN_0;\r\n    address private immutable TOKEN_1;\r\n    address private immutable CENTRALIZED_RATE_PROVIDER;\r\n\r\n    constructor(\r\n        address _centralizedRateProvider,\r\n        address _token0,\r\n        address _token1\r\n    ) public {\r\n        CENTRALIZED_RATE_PROVIDER = _centralizedRateProvider;\r\n        TOKEN_0 = _token0;\r\n        TOKEN_1 = _token1;\r\n    }\r\n\r\n    /// @dev returns reserves for each token on the Uniswap Pair\r\n    /// Reserves will be used to calculate the pair price\r\n    /// Inherited from IUniswapV2Pair\r\n    function getReserves()\r\n        external\r\n        returns (\r\n            uint112 reserve0_,\r\n            uint112 reserve1_,\r\n            uint32 blockTimestampLast_\r\n        )\r\n    {\r\n        uint256 baseAmount = ERC20(TOKEN_0).balanceOf(address(this));\r\n        reserve0_ = uint112(baseAmount);\r\n        reserve1_ = uint112(\r\n            CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER).calcLiveAssetValue(\r\n                TOKEN_0,\r\n                baseAmount,\r\n                TOKEN_1\r\n            )\r\n        );\r\n\r\n        return (reserve0_, reserve1_, blockTimestampLast_);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @dev Inherited from IUniswapV2Pair\r\n    function token0() public view returns (address) {\r\n        return TOKEN_0;\r\n    }\r\n\r\n    /// @dev Inherited from IUniswapV2Pair\r\n    function token1() public view returns (address) {\r\n        return TOKEN_1;\r\n    }\r\n\r\n    /// @dev Inherited from IUniswapV2Pair\r\n    function kLast() public pure returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/tokens/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract MockToken is ERC20Burnable, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => bool) private addressToIsMinter;\r\n\r\n    modifier onlyMinter() {\r\n        require(\r\n            addressToIsMinter[msg.sender] || owner() == msg.sender,\r\n            \"msg.sender is not owner or minter\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) public ERC20(_name, _symbol) {\r\n        _setupDecimals(_decimals);\r\n        _mint(msg.sender, uint256(100000000).mul(10**uint256(_decimals)));\r\n    }\r\n\r\n    function mintFor(address _who, uint256 _amount) external onlyMinter {\r\n        _mint(_who, _amount);\r\n    }\r\n\r\n    function mint(uint256 _amount) external onlyMinter {\r\n        _mint(msg.sender, _amount);\r\n    }\r\n\r\n    function addMinters(address[] memory _minters) public onlyOwner {\r\n        for (uint256 i = 0; i < _minters.length; i++) {\r\n            addressToIsMinter[_minters[i]] = true;\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/tokens/MockReentrancyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../release/core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"./MockToken.sol\";\r\n\r\n/// @title MockReentrancyToken Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mock ERC20 token implementation that is able to re-entrance redeemShares and buyShares functions\r\ncontract MockReentrancyToken is MockToken(\"Mock Reentrancy Token\", \"MRT\", 18) {\r\n    bool public bad;\r\n    address public comptrollerProxy;\r\n\r\n    function makeItReentracyToken(address _comptrollerProxy) external {\r\n        bad = true;\r\n        comptrollerProxy = _comptrollerProxy;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        if (bad) {\r\n            ComptrollerLib(comptrollerProxy).redeemShares();\r\n        } else {\r\n            _transfer(_msgSender(), recipient, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        if (bad) {\r\n            ComptrollerLib(comptrollerProxy).buyShares(\r\n                new address[](0),\r\n                new uint256[](0),\r\n                new uint256[](0)\r\n            );\r\n        } else {\r\n            _transfer(sender, recipient, amount);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/prices/MockSynthetixPriceSource.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"./../../release/interfaces/ISynthetixExchangeRates.sol\";\r\nimport \"../prices/MockChainlinkPriceSource.sol\";\r\n\r\n/// @dev This price source offers two different options getting prices\r\n/// The first one is getting a fixed rate, which can be useful for tests\r\n/// The second approach calculates dinamically the rate making use of a chainlink price source\r\n/// Mocks the functionality of the folllowing Synthetix contracts: { Exchanger, ExchangeRates }\r\ncontract MockSynthetixPriceSource is Ownable, ISynthetixExchangeRates {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(bytes32 => uint256) private fixedRate;\r\n    mapping(bytes32 => AggregatorInfo) private currencyKeyToAggregator;\r\n\r\n    enum RateAsset {ETH, USD}\r\n\r\n    struct AggregatorInfo {\r\n        address aggregator;\r\n        RateAsset rateAsset;\r\n    }\r\n\r\n    constructor(address _ethUsdAggregator) public {\r\n        currencyKeyToAggregator[bytes32(\"ETH\")] = AggregatorInfo({\r\n            aggregator: _ethUsdAggregator,\r\n            rateAsset: RateAsset.USD\r\n        });\r\n    }\r\n\r\n    function setPriceSourcesForCurrencyKeys(\r\n        bytes32[] calldata _currencyKeys,\r\n        address[] calldata _aggregators,\r\n        RateAsset[] calldata _rateAssets\r\n    ) external onlyOwner {\r\n        require(\r\n            _currencyKeys.length == _aggregators.length &&\r\n                _rateAssets.length == _aggregators.length\r\n        );\r\n        for (uint256 i = 0; i < _currencyKeys.length; i++) {\r\n            currencyKeyToAggregator[_currencyKeys[i]] = AggregatorInfo({\r\n                aggregator: _aggregators[i],\r\n                rateAsset: _rateAssets[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    function setRate(bytes32 _currencyKey, uint256 _rate) external onlyOwner {\r\n        fixedRate[_currencyKey] = _rate;\r\n    }\r\n\r\n    /// @dev Calculates the rate from a currency key against USD\r\n    function rateAndInvalid(bytes32 _currencyKey)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 rate_, bool isInvalid_)\r\n    {\r\n        uint256 storedRate = getFixedRate(_currencyKey);\r\n        if (storedRate != 0) {\r\n            rate_ = storedRate;\r\n        } else {\r\n            AggregatorInfo memory aggregatorInfo = getAggregatorFromCurrencyKey(_currencyKey);\r\n            address aggregator = aggregatorInfo.aggregator;\r\n            if (aggregator == address(0)) {\r\n                rate_ = 0;\r\n                isInvalid_ = true;\r\n                return (rate_, isInvalid_);\r\n            }\r\n            uint256 decimals = MockChainlinkPriceSource(aggregator).decimals();\r\n            rate_ = uint256(MockChainlinkPriceSource(aggregator).latestAnswer()).mul(\r\n                10**(uint256(18).sub(decimals))\r\n            );\r\n\r\n            if (aggregatorInfo.rateAsset == RateAsset.ETH) {\r\n                uint256 ethToUsd = uint256(\r\n                    MockChainlinkPriceSource(\r\n                        getAggregatorFromCurrencyKey(bytes32(\"ETH\"))\r\n                            .aggregator\r\n                    )\r\n                        .latestAnswer()\r\n                );\r\n                rate_ = rate_.mul(ethToUsd).div(10**8);\r\n            }\r\n        }\r\n\r\n        isInvalid_ = (rate_ == 0);\r\n        return (rate_, isInvalid_);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    function getAggregatorFromCurrencyKey(bytes32 _currencyKey)\r\n        public\r\n        view\r\n        returns (AggregatorInfo memory _aggregator)\r\n    {\r\n        return currencyKeyToAggregator[_currencyKey];\r\n    }\r\n\r\n    function getFixedRate(bytes32 _currencyKey) public view returns (uint256) {\r\n        return fixedRate[_currencyKey];\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/prices/MockChainlinkPriceSource.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract MockChainlinkPriceSource {\r\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n\r\n    uint256 public DECIMALS;\r\n\r\n    int256 public latestAnswer;\r\n    uint256 public latestTimestamp;\r\n    uint256 public roundId;\r\n    address public aggregator;\r\n\r\n    constructor(uint256 _decimals) public {\r\n        DECIMALS = _decimals;\r\n        latestAnswer = int256(10**_decimals);\r\n        latestTimestamp = now;\r\n        roundId = 1;\r\n        aggregator = address(this);\r\n    }\r\n\r\n    function setLatestAnswer(int256 _nextAnswer, uint256 _nextTimestamp) external {\r\n        latestAnswer = _nextAnswer;\r\n        latestTimestamp = _nextTimestamp;\r\n        roundId = roundId + 1;\r\n\r\n        emit AnswerUpdated(latestAnswer, roundId, latestTimestamp);\r\n    }\r\n\r\n    function setAggregator(address _nextAggregator) external {\r\n        aggregator = _nextAggregator;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return DECIMALS;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/SynthetixAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol\";\r\nimport \"../../../../interfaces/ISynthetix.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title SynthetixAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with Synthetix\r\ncontract SynthetixAdapter is AdapterBase {\r\n    address private immutable ORIGINATOR;\r\n    address private immutable SYNTHETIX;\r\n    address private immutable SYNTHETIX_PRICE_FEED;\r\n    bytes32 private immutable TRACKING_CODE;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _synthetixPriceFeed,\r\n        address _originator,\r\n        address _synthetix,\r\n        bytes32 _trackingCode\r\n    ) public AdapterBase(_integrationManager) {\r\n        ORIGINATOR = _originator;\r\n        SYNTHETIX = _synthetix;\r\n        SYNTHETIX_PRICE_FEED = _synthetixPriceFeed;\r\n        TRACKING_CODE = _trackingCode;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"SYNTHETIX\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n\r\n        (\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = outgoingAsset;\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Trades assets on Synthetix\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (\r\n            address incomingAsset,\r\n            ,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        address[] memory synths = new address[](2);\r\n        synths[0] = outgoingAsset;\r\n        synths[1] = incomingAsset;\r\n\r\n        bytes32[] memory currencyKeys = SynthetixPriceFeed(SYNTHETIX_PRICE_FEED)\r\n            .getCurrencyKeysForSynths(synths);\r\n\r\n        ISynthetix(SYNTHETIX).exchangeOnBehalfWithTracking(\r\n            _vaultProxy,\r\n            currencyKeys[0],\r\n            outgoingAssetAmount,\r\n            currencyKeys[1],\r\n            ORIGINATOR,\r\n            TRACKING_CODE\r\n        );\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the encoded call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_,\r\n            address outgoingAsset_,\r\n            uint256 outgoingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, address, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `ORIGINATOR` variable\r\n    /// @return originator_ The `ORIGINATOR` variable value\r\n    function getOriginator() external view returns (address originator_) {\r\n        return ORIGINATOR;\r\n    }\r\n\r\n    /// @notice Gets the `SYNTHETIX` variable\r\n    /// @return synthetix_ The `SYNTHETIX` variable value\r\n    function getSynthetix() external view returns (address synthetix_) {\r\n        return SYNTHETIX;\r\n    }\r\n\r\n    /// @notice Gets the `SYNTHETIX_PRICE_FEED` variable\r\n    /// @return synthetixPriceFeed_ The `SYNTHETIX_PRICE_FEED` variable value\r\n    function getSynthetixPriceFeed() external view returns (address synthetixPriceFeed_) {\r\n        return SYNTHETIX_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `TRACKING_CODE` variable\r\n    /// @return trackingCode_ The `TRACKING_CODE` variable value\r\n    function getTrackingCode() external view returns (bytes32 trackingCode_) {\r\n        return TRACKING_CODE;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/tokens/MockSynthetixToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"./../../release/interfaces/ISynthetixProxyERC20.sol\";\r\nimport \"./../../release/interfaces/ISynthetixSynth.sol\";\r\nimport \"./MockToken.sol\";\r\n\r\ncontract MockSynthetixToken is ISynthetixProxyERC20, ISynthetixSynth, MockToken {\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 public override currencyKey;\r\n    uint256 public constant WAITING_PERIOD_SECS = 3 * 60;\r\n\r\n    mapping(address => uint256) public timelockByAccount;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        bytes32 _currencyKey\r\n    ) public MockToken(_name, _symbol, _decimals) {\r\n        currencyKey = _currencyKey;\r\n    }\r\n\r\n    function setCurrencyKey(bytes32 _currencyKey) external onlyOwner {\r\n        currencyKey = _currencyKey;\r\n    }\r\n\r\n    function _isLocked(address account) internal view returns (bool) {\r\n        return timelockByAccount[account] >= now;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address,\r\n        uint256\r\n    ) internal override {\r\n        require(!_isLocked(from), \"Cannot settle during waiting period\");\r\n    }\r\n\r\n    function target() external view override returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function isLocked(address account) external view returns (bool) {\r\n        return _isLocked(account);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public override {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function lock(address account) public {\r\n        timelockByAccount[account] = now.add(WAITING_PERIOD_SECS);\r\n    }\r\n\r\n    function unlock(address account) public {\r\n        timelockByAccount[account] = 0;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/UniswapV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../interfaces/IUniswapV2Factory.sol\";\r\nimport \"../../../../interfaces/IUniswapV2Router2.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title UniswapV2Adapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with Uniswap v2\r\ncontract UniswapV2Adapter is AdapterBase {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable FACTORY;\r\n    address private immutable ROUTER;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _router,\r\n        address _factory\r\n    ) public AdapterBase(_integrationManager) {\r\n        FACTORY = _factory;\r\n        ROUTER = _router;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"UNISWAP_V2\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == LEND_SELECTOR) {\r\n            (\r\n                address[2] memory outgoingAssets,\r\n                uint256[2] memory maxOutgoingAssetAmounts,\r\n                ,\r\n                uint256 minIncomingAssetAmount\r\n            ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n            spendAssets_ = new address[](2);\r\n            spendAssets_[0] = outgoingAssets[0];\r\n            spendAssets_[1] = outgoingAssets[1];\r\n\r\n            spendAssetAmounts_ = new uint256[](2);\r\n            spendAssetAmounts_[0] = maxOutgoingAssetAmounts[0];\r\n            spendAssetAmounts_[1] = maxOutgoingAssetAmounts[1];\r\n\r\n            incomingAssets_ = new address[](1);\r\n            // No need to validate not address(0), this will be caught in IntegrationManager\r\n            incomingAssets_[0] = IUniswapV2Factory(FACTORY).getPair(\r\n                outgoingAssets[0],\r\n                outgoingAssets[1]\r\n            );\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            (\r\n                uint256 outgoingAssetAmount,\r\n                address[2] memory incomingAssets,\r\n                uint256[2] memory minIncomingAssetAmounts\r\n            ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n            spendAssets_ = new address[](1);\r\n            // No need to validate not address(0), this will be caught in IntegrationManager\r\n            spendAssets_[0] = IUniswapV2Factory(FACTORY).getPair(\r\n                incomingAssets[0],\r\n                incomingAssets[1]\r\n            );\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n            incomingAssets_ = new address[](2);\r\n            incomingAssets_[0] = incomingAssets[0];\r\n            incomingAssets_[1] = incomingAssets[1];\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](2);\r\n            minIncomingAssetAmounts_[0] = minIncomingAssetAmounts[0];\r\n            minIncomingAssetAmounts_[1] = minIncomingAssetAmounts[1];\r\n        } else if (_selector == TAKE_ORDER_SELECTOR) {\r\n            (\r\n                address[] memory path,\r\n                uint256 outgoingAssetAmount,\r\n                uint256 minIncomingAssetAmount\r\n            ) = __decodeTakeOrderCallArgs(_encodedCallArgs);\r\n\r\n            require(path.length >= 2, \"parseAssetsForMethod: _path must be >= 2\");\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = path[0];\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = path[path.length - 1];\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n        } else {\r\n            revert(\"parseAssetsForMethod: _selector invalid\");\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for pool tokens on Uniswap\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            address[2] memory outgoingAssets,\r\n            uint256[2] memory maxOutgoingAssetAmounts,\r\n            uint256[2] memory minOutgoingAssetAmounts,\r\n\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __lend(\r\n            _vaultProxy,\r\n            outgoingAssets[0],\r\n            outgoingAssets[1],\r\n            maxOutgoingAssetAmounts[0],\r\n            maxOutgoingAssetAmounts[1],\r\n            minOutgoingAssetAmounts[0],\r\n            minOutgoingAssetAmounts[1]\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems pool tokens on Uniswap\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingAssetAmount,\r\n            address[2] memory incomingAssets,\r\n            uint256[2] memory minIncomingAssetAmounts\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        // More efficient to parse pool token from _encodedAssetTransferArgs than external call\r\n        (, address[] memory spendAssets, , ) = __decodeEncodedAssetTransferArgs(\r\n            _encodedAssetTransferArgs\r\n        );\r\n\r\n        __redeem(\r\n            _vaultProxy,\r\n            spendAssets[0],\r\n            outgoingAssetAmount,\r\n            incomingAssets[0],\r\n            incomingAssets[1],\r\n            minIncomingAssetAmounts[0],\r\n            minIncomingAssetAmounts[1]\r\n        );\r\n    }\r\n\r\n    /// @notice Trades assets on Uniswap\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            address[] memory path,\r\n            uint256 outgoingAssetAmount,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeTakeOrderCallArgs(_encodedCallArgs);\r\n\r\n        __takeOrder(_vaultProxy, outgoingAssetAmount, minIncomingAssetAmount, path);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the lend encoded call arguments\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address[2] memory outgoingAssets_,\r\n            uint256[2] memory maxOutgoingAssetAmounts_,\r\n            uint256[2] memory minOutgoingAssetAmounts_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[2], uint256[2], uint256[2], uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the redeem encoded call arguments\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingAssetAmount_,\r\n            address[2] memory incomingAssets_,\r\n            uint256[2] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, address[2], uint256[2]));\r\n    }\r\n\r\n    /// @dev Helper to decode the take order encoded call arguments\r\n    function __decodeTakeOrderCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address[] memory path_,\r\n            uint256 outgoingAssetAmount_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[], uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to execute lend. Avoids stack-too-deep error.\r\n    function __lend(\r\n        address _vaultProxy,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) private {\r\n        __approveMaxAsNeeded(_tokenA, ROUTER, _amountADesired);\r\n        __approveMaxAsNeeded(_tokenB, ROUTER, _amountBDesired);\r\n\r\n        // Execute lend on Uniswap\r\n        IUniswapV2Router2(ROUTER).addLiquidity(\r\n            _tokenA,\r\n            _tokenB,\r\n            _amountADesired,\r\n            _amountBDesired,\r\n            _amountAMin,\r\n            _amountBMin,\r\n            _vaultProxy,\r\n            block.timestamp.add(1)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to execute redeem. Avoids stack-too-deep error.\r\n    function __redeem(\r\n        address _vaultProxy,\r\n        address _poolToken,\r\n        uint256 _poolTokenAmount,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) private {\r\n        __approveMaxAsNeeded(_poolToken, ROUTER, _poolTokenAmount);\r\n\r\n        // Execute redeem on Uniswap\r\n        IUniswapV2Router2(ROUTER).removeLiquidity(\r\n            _tokenA,\r\n            _tokenB,\r\n            _poolTokenAmount,\r\n            _amountAMin,\r\n            _amountBMin,\r\n            _vaultProxy,\r\n            block.timestamp.add(1)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to execute takeOrder. Avoids stack-too-deep error.\r\n    function __takeOrder(\r\n        address _vaultProxy,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minIncomingAssetAmount,\r\n        address[] memory _path\r\n    ) private {\r\n        __approveMaxAsNeeded(_path[0], ROUTER, _outgoingAssetAmount);\r\n\r\n        // Execute fill\r\n        IUniswapV2Router2(ROUTER).swapExactTokensForTokens(\r\n            _outgoingAssetAmount,\r\n            _minIncomingAssetAmount,\r\n            _path,\r\n            _vaultProxy,\r\n            block.timestamp.add(1)\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `FACTORY` variable\r\n    /// @return factory_ The `FACTORY` variable value\r\n    function getFactory() external view returns (address factory_) {\r\n        return FACTORY;\r\n    }\r\n\r\n    /// @notice Gets the `ROUTER` variable\r\n    /// @return router_ The `ROUTER` variable value\r\n    function getRouter() external view returns (address router_) {\r\n        return ROUTER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IUniswapV2Router2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title UniswapV2Router2 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @dev Minimal interface for our interactions with Uniswap V2's Router2\r\ninterface IUniswapV2Router2 {\r\n    function addLiquidity(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256, uint256);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256,\r\n        uint256,\r\n        address[] calldata,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256[] memory);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/UniswapV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/IUniswapV2Router2.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title UniswapV2ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with Uniswap v2\r\nabstract contract UniswapV2ActionsMixin is AssetHelpers {\r\n    address private immutable UNISWAP_V2_ROUTER2;\r\n\r\n    constructor(address _router) public {\r\n        UNISWAP_V2_ROUTER2 = _router;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @dev Helper to add liquidity\r\n    function __uniswapV2Lend(\r\n        address _recipient,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_tokenA, UNISWAP_V2_ROUTER2, _amountADesired);\r\n        __approveAssetMaxAsNeeded(_tokenB, UNISWAP_V2_ROUTER2, _amountBDesired);\r\n\r\n        // Execute lend on Uniswap\r\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).addLiquidity(\r\n            _tokenA,\r\n            _tokenB,\r\n            _amountADesired,\r\n            _amountBDesired,\r\n            _amountAMin,\r\n            _amountBMin,\r\n            _recipient,\r\n            __uniswapV2GetActionDeadline()\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to remove liquidity\r\n    function __uniswapV2Redeem(\r\n        address _recipient,\r\n        address _poolToken,\r\n        uint256 _poolTokenAmount,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_poolToken, UNISWAP_V2_ROUTER2, _poolTokenAmount);\r\n\r\n        // Execute redeem on Uniswap\r\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).removeLiquidity(\r\n            _tokenA,\r\n            _tokenB,\r\n            _poolTokenAmount,\r\n            _amountAMin,\r\n            _amountBMin,\r\n            _recipient,\r\n            __uniswapV2GetActionDeadline()\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to execute a swap\r\n    function __uniswapV2Swap(\r\n        address _recipient,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minIncomingAssetAmount,\r\n        address[] memory _path\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_path[0], UNISWAP_V2_ROUTER2, _outgoingAssetAmount);\r\n\r\n        // Execute fill\r\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).swapExactTokensForTokens(\r\n            _outgoingAssetAmount,\r\n            _minIncomingAssetAmount,\r\n            _path,\r\n            _recipient,\r\n            __uniswapV2GetActionDeadline()\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to swap many assets to a single target asset.\r\n    /// The intermediary asset will generally be WETH, and though we could make it\r\n    // per-outgoing asset, seems like overkill until there is a need.\r\n    function __uniswapV2SwapManyToOne(\r\n        address _recipient,\r\n        address[] memory _outgoingAssets,\r\n        uint256[] memory _outgoingAssetAmounts,\r\n        address _incomingAsset,\r\n        address _intermediaryAsset\r\n    ) internal {\r\n        bool noIntermediary = _intermediaryAsset == address(0) ||\r\n            _intermediaryAsset == _incomingAsset;\r\n        for (uint256 i; i < _outgoingAssets.length; i++) {\r\n            // Skip cases where outgoing and incoming assets are the same, or\r\n            // there is no specified outgoing asset or amount\r\n            if (\r\n                _outgoingAssetAmounts[i] == 0 ||\r\n                _outgoingAssets[i] == address(0) ||\r\n                _outgoingAssets[i] == _incomingAsset\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            address[] memory uniswapPath;\r\n            if (noIntermediary || _outgoingAssets[i] == _intermediaryAsset) {\r\n                uniswapPath = new address[](2);\r\n                uniswapPath[0] = _outgoingAssets[i];\r\n                uniswapPath[1] = _incomingAsset;\r\n            } else {\r\n                uniswapPath = new address[](3);\r\n                uniswapPath[0] = _outgoingAssets[i];\r\n                uniswapPath[1] = _intermediaryAsset;\r\n                uniswapPath[2] = _incomingAsset;\r\n            }\r\n\r\n            __uniswapV2Swap(_recipient, _outgoingAssetAmounts[i], 1, uniswapPath);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to get the deadline for a Uniswap V2 action in a standardized way\r\n    function __uniswapV2GetActionDeadline() private view returns (uint256 deadline_) {\r\n        return block.timestamp + 1;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `UNISWAP_V2_ROUTER2` variable\r\n    /// @return router_ The `UNISWAP_V2_ROUTER2` variable value\r\n    function getUniswapV2Router2() public view returns (address router_) {\r\n        return UNISWAP_V2_ROUTER2;\r\n    }\r\n}\r\n"
    },
    "contracts/release/utils/AssetHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n\r\n/// @title AssetHelpers Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A util contract for common token actions\r\nabstract contract AssetHelpers {\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Helper to approve a target account with the max amount of an asset.\r\n    /// This is helpful for fully trusted contracts, such as adapters that\r\n    /// interact with external protocol like Uniswap, Compound, etc.\r\n    function __approveAssetMaxAsNeeded(\r\n        address _asset,\r\n        address _target,\r\n        uint256 _neededAmount\r\n    ) internal {\r\n        if (ERC20(_asset).allowance(address(this), _target) < _neededAmount) {\r\n            ERC20(_asset).safeApprove(_target, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to get the balances of specified assets for a target\r\n    function __getAssetBalances(address _target, address[] memory _assets)\r\n        internal\r\n        view\r\n        returns (uint256[] memory balances_)\r\n    {\r\n        balances_ = new uint256[](_assets.length);\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            balances_[i] = ERC20(_assets[i]).balanceOf(_target);\r\n        }\r\n\r\n        return balances_;\r\n    }\r\n\r\n    /// @dev Helper to transfer full asset balances from a target to the current contract.\r\n    /// Requires an adequate allowance for each asset granted to the current contract for the target.\r\n    function __pullFullAssetBalances(address _target, address[] memory _assets)\r\n        internal\r\n        returns (uint256[] memory amountsTransferred_)\r\n    {\r\n        amountsTransferred_ = new uint256[](_assets.length);\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            ERC20 assetContract = ERC20(_assets[i]);\r\n            amountsTransferred_[i] = assetContract.balanceOf(_target);\r\n            if (amountsTransferred_[i] > 0) {\r\n                assetContract.safeTransferFrom(_target, address(this), amountsTransferred_[i]);\r\n            }\r\n        }\r\n\r\n        return amountsTransferred_;\r\n    }\r\n\r\n    /// @dev Helper to transfer partial asset balances from a target to the current contract.\r\n    /// Requires an adequate allowance for each asset granted to the current contract for the target.\r\n    function __pullPartialAssetBalances(\r\n        address _target,\r\n        address[] memory _assets,\r\n        uint256[] memory _amountsToExclude\r\n    ) internal returns (uint256[] memory amountsTransferred_) {\r\n        amountsTransferred_ = new uint256[](_assets.length);\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            ERC20 assetContract = ERC20(_assets[i]);\r\n            amountsTransferred_[i] = assetContract.balanceOf(_target).sub(_amountsToExclude[i]);\r\n            if (amountsTransferred_[i] > 0) {\r\n                assetContract.safeTransferFrom(_target, address(this), amountsTransferred_[i]);\r\n            }\r\n        }\r\n\r\n        return amountsTransferred_;\r\n    }\r\n\r\n    /// @dev Helper to transfer full asset balances from the current contract to a target\r\n    function __pushFullAssetBalances(address _target, address[] memory _assets)\r\n        internal\r\n        returns (uint256[] memory amountsTransferred_)\r\n    {\r\n        amountsTransferred_ = new uint256[](_assets.length);\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            ERC20 assetContract = ERC20(_assets[i]);\r\n            amountsTransferred_[i] = assetContract.balanceOf(address(this));\r\n            if (amountsTransferred_[i] > 0) {\r\n                assetContract.safeTransfer(_target, amountsTransferred_[i]);\r\n            }\r\n        }\r\n\r\n        return amountsTransferred_;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/IdleAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/IdlePriceFeed.sol\";\r\nimport \"../../../../interfaces/IIdleTokenV4.sol\";\r\nimport \"../../../../utils/AddressArrayLib.sol\";\r\nimport \"../utils/actions/IdleV4ActionsMixin.sol\";\r\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title IdleAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for Idle Lending <https://idle.finance/>\r\n/// @dev There are some idiosyncrasies of reward accrual and claiming in IdleTokens that\r\n/// are handled by this adapter:\r\n/// - Rewards accrue to the IdleToken holder, but the accrued\r\n/// amount is passed to the recipient of a transfer.\r\n/// - Claiming rewards cannot be done on behalf of a holder, but must be done directly.\r\n/// - Claiming rewards occurs automatically upon redeeming, but there are situations when\r\n/// it is difficult to know whether to expect incoming rewards (e.g., after a user mints\r\n/// idleTokens and then redeems before any other user has interacted with the protocol,\r\n/// then getGovTokensAmounts() will return 0 balances). Because of this difficulty -\r\n/// and in keeping with how other adapters treat claimed rewards -\r\n/// this adapter does not report claimed rewards as incomingAssets.\r\ncontract IdleAdapter is AdapterBase2, IdleV4ActionsMixin, UniswapV2ActionsMixin {\r\n    using AddressArrayLib for address[];\r\n\r\n    address private immutable IDLE_PRICE_FEED;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _idlePriceFeed,\r\n        address _wethToken,\r\n        address _uniswapV2Router2\r\n    ) public AdapterBase2(_integrationManager) UniswapV2ActionsMixin(_uniswapV2Router2) {\r\n        IDLE_PRICE_FEED = _idlePriceFeed;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"IDLE\";\r\n    }\r\n\r\n    /// @notice Approves assets from the vault to be used by this contract.\r\n    /// @dev No logic necessary. Exists only to grant adapter with necessary approvals from the vault,\r\n    /// which takes place in the IntegrationManager.\r\n    function approveAssets(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external {}\r\n\r\n    /// @notice Claims rewards for a givenIdleToken\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function claimRewards(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (, address idleToken) = __decodeClaimRewardsCallArgs(_encodedCallArgs);\r\n\r\n        __idleV4ClaimRewards(idleToken);\r\n\r\n        __pushFullAssetBalances(_vaultProxy, __idleV4GetRewardsTokens(idleToken));\r\n    }\r\n\r\n    /// @notice Claims rewards and then compounds the rewards tokens back into the idleToken\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    /// If full asset balances are to be used, then this requires the adapter to be granted\r\n    /// an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.\r\n    function claimRewardsAndReinvest(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        // The idleToken is both the spend asset and the incoming asset in this case\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (, address idleToken, , bool useFullBalances) = __decodeClaimRewardsAndReinvestCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        address underlying = __getUnderlyingForIdleToken(idleToken);\r\n        require(underlying != address(0), \"claimRewardsAndReinvest: Unsupported idleToken\");\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __claimRewardsAndPullRewardsTokens(_vaultProxy, idleToken, useFullBalances);\r\n\r\n        // Swap all reward tokens to the idleToken's underlying via UniswapV2,\r\n        // using WETH as the intermediary where necessary\r\n        __uniswapV2SwapManyToOne(\r\n            address(this),\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            underlying,\r\n            WETH_TOKEN\r\n        );\r\n\r\n        // Lend all received underlying asset for the idleToken\r\n        uint256 underlyingBalance = ERC20(underlying).balanceOf(address(this));\r\n        if (underlyingBalance > 0) {\r\n            __idleV4Lend(idleToken, underlying, underlyingBalance);\r\n        }\r\n    }\r\n\r\n    /// @notice Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    /// If full asset balances are to be used, then this requires the adapter to be granted\r\n    /// an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.\r\n    function claimRewardsAndSwap(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            ,\r\n            address idleToken,\r\n            address incomingAsset,\r\n            ,\r\n            bool useFullBalances\r\n        ) = __decodeClaimRewardsAndSwapCallArgs(_encodedCallArgs);\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __claimRewardsAndPullRewardsTokens(_vaultProxy, idleToken, useFullBalances);\r\n\r\n        // Swap all reward tokens to the designated incomingAsset via UniswapV2,\r\n        // using WETH as the intermediary where necessary\r\n        __uniswapV2SwapManyToOne(\r\n            _vaultProxy,\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            incomingAsset,\r\n            WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    /// @notice Lends an amount of a token for idleToken\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        // More efficient to parse all from _encodedAssetTransferArgs\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        __idleV4Lend(incomingAssets[0], spendAssets[0], spendAssetAmounts[0]);\r\n    }\r\n\r\n    /// @notice Redeems an amount of idleToken for its underlying asset\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev This will also pay out any due gov token rewards.\r\n    /// We use the full IdleToken balance of the current contract rather than the user input\r\n    /// for the corner case of a prior balance existing in the current contract, which would\r\n    /// throw off the per-user avg price of the IdleToken used by Idle, and would leave the\r\n    /// initial token balance in the current contract post-tx.\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (address idleToken, , ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __idleV4Redeem(idleToken, ERC20(idleToken).balanceOf(address(this)));\r\n\r\n        __pushFullAssetBalances(_vaultProxy, __idleV4GetRewardsTokens(idleToken));\r\n    }\r\n\r\n    /// @dev Helper to claim rewards and pull rewards tokens from the vault\r\n    /// to the current contract, as needed\r\n    function __claimRewardsAndPullRewardsTokens(\r\n        address _vaultProxy,\r\n        address _idleToken,\r\n        bool _useFullBalances\r\n    )\r\n        private\r\n        returns (address[] memory rewardsTokens_, uint256[] memory rewardsTokenAmountsToUse_)\r\n    {\r\n        __idleV4ClaimRewards(_idleToken);\r\n\r\n        rewardsTokens_ = __idleV4GetRewardsTokens(_idleToken);\r\n        if (_useFullBalances) {\r\n            __pullFullAssetBalances(_vaultProxy, rewardsTokens_);\r\n        }\r\n\r\n        return (rewardsTokens_, __getAssetBalances(address(this), rewardsTokens_));\r\n    }\r\n\r\n    /// @dev Helper to get the underlying for a given IdleToken\r\n    function __getUnderlyingForIdleToken(address _idleToken)\r\n        private\r\n        view\r\n        returns (address underlying_)\r\n    {\r\n        return IdlePriceFeed(IDLE_PRICE_FEED).getUnderlyingForDerivative(_idleToken);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == APPROVE_ASSETS_SELECTOR) {\r\n            return __parseAssetsForApproveAssets(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_SELECTOR) {\r\n            return __parseAssetsForClaimRewards(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_AND_REINVEST_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndReinvest(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_AND_SWAP_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndSwap(_encodedCallArgs);\r\n        } else if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during approveAssets() calls\r\n    function __parseAssetsForApproveAssets(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        address idleToken;\r\n        (idleToken, spendAssets_, spendAssetAmounts_) = __decodeApproveAssetsCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n        require(\r\n            __getUnderlyingForIdleToken(idleToken) != address(0),\r\n            \"__parseAssetsForApproveAssets: Unsupported idleToken\"\r\n        );\r\n        require(\r\n            spendAssets_.length == spendAssetAmounts_.length,\r\n            \"__parseAssetsForApproveAssets: Unequal arrays\"\r\n        );\r\n\r\n        // Validate that only rewards tokens are given allowances\r\n        address[] memory rewardsTokens = __idleV4GetRewardsTokens(idleToken);\r\n        for (uint256 i; i < spendAssets_.length; i++) {\r\n            // Allow revoking approval for any asset\r\n            if (spendAssetAmounts_[i] > 0) {\r\n                require(\r\n                    rewardsTokens.contains(spendAssets_[i]),\r\n                    \"__parseAssetsForApproveAssets: Invalid reward token\"\r\n                );\r\n            }\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Approve,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewards() calls\r\n    function __parseAssetsForClaimRewards(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (address vaultProxy, address idleToken) = __decodeClaimRewardsCallArgs(_encodedCallArgs);\r\n\r\n        require(\r\n            __getUnderlyingForIdleToken(idleToken) != address(0),\r\n            \"__parseAssetsForClaimRewards: Unsupported idleToken\"\r\n        );\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForClaimRewardsCalls(\r\n            vaultProxy,\r\n            idleToken\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndReinvest() calls.\r\n    function __parseAssetsForClaimRewardsAndReinvest(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address vaultProxy,\r\n            address idleToken,\r\n            uint256 minIncomingIdleTokenAmount,\r\n\r\n        ) = __decodeClaimRewardsAndReinvestCallArgs(_encodedCallArgs);\r\n\r\n        // Does not validate idleToken here as we need to do fetch the underlying during the action\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForClaimRewardsCalls(\r\n            vaultProxy,\r\n            idleToken\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = idleToken;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingIdleTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndSwap() calls.\r\n    function __parseAssetsForClaimRewardsAndSwap(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address vaultProxy,\r\n            address idleToken,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount,\r\n\r\n        ) = __decodeClaimRewardsAndSwapCallArgs(_encodedCallArgs);\r\n\r\n        require(\r\n            __getUnderlyingForIdleToken(idleToken) != address(0),\r\n            \"__parseAssetsForClaimRewardsAndSwap: Unsupported idleToken\"\r\n        );\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForClaimRewardsCalls(\r\n            vaultProxy,\r\n            idleToken\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address idleToken,\r\n            uint256 outgoingUnderlyingAmount,\r\n            uint256 minIncomingIdleTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        address underlying = __getUnderlyingForIdleToken(idleToken);\r\n        require(underlying != address(0), \"__parseAssetsForLend: Unsupported idleToken\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = underlying;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingUnderlyingAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = idleToken;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingIdleTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address idleToken,\r\n            uint256 outgoingIdleTokenAmount,\r\n            uint256 minIncomingUnderlyingAmount\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        address underlying = __getUnderlyingForIdleToken(idleToken);\r\n        require(underlying != address(0), \"__parseAssetsForRedeem: Unsupported idleToken\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = idleToken;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingIdleTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = underlying;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingUnderlyingAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for calls to claim rewards\r\n    function __parseSpendAssetsForClaimRewardsCalls(address _vaultProxy, address _idleToken)\r\n        private\r\n        view\r\n        returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_)\r\n    {\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = _idleToken;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = ERC20(_idleToken).balanceOf(_vaultProxy);\r\n\r\n        return (spendAssets_, spendAssetAmounts_);\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode the encoded call arguments for approving asset allowances\r\n    function __decodeApproveAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address idleToken_,\r\n            address[] memory assets_,\r\n            uint256[] memory amounts_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, address[], uint256[]));\r\n    }\r\n\r\n    /// @dev Helper to decode callArgs for claiming rewards tokens\r\n    function __decodeClaimRewardsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address vaultProxy_, address idleToken_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, address));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and reinvesting\r\n    function __decodeClaimRewardsAndReinvestCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address vaultProxy_,\r\n            address idleToken_,\r\n            uint256 minIncomingIdleTokenAmount_,\r\n            bool useFullBalances_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, address, uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and swapping\r\n    function __decodeClaimRewardsAndSwapCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address vaultProxy_,\r\n            address idleToken_,\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_,\r\n            bool useFullBalances_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, address, address, uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode callArgs for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address idleToken_,\r\n            uint256 outgoingUnderlyingAmount_,\r\n            uint256 minIncomingIdleTokenAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode callArgs for redeeming\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address idleToken_,\r\n            uint256 outgoingIdleTokenAmount_,\r\n            uint256 minIncomingUnderlyingAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `IDLE_PRICE_FEED` variable\r\n    /// @return idlePriceFeed_ The `IDLE_PRICE_FEED` variable value\r\n    function getIdlePriceFeed() external view returns (address idlePriceFeed_) {\r\n        return IDLE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/IdlePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../interfaces/IIdleTokenV4.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\nimport \"./utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\r\n\r\n/// @title IdlePriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for IdleTokens\r\ncontract IdlePriceFeed is IDerivativePriceFeed, SingleUnderlyingDerivativeRegistryMixin {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant IDLE_TOKEN_UNIT = 10**18;\r\n\r\n    constructor(address _fundDeployer)\r\n        public\r\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\r\n    {}\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = getUnderlyingForDerivative(_derivative);\r\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\r\n\r\n        underlyingAmounts_ = new uint256[](1);\r\n        underlyingAmounts_[0] = _derivativeAmount.mul(IIdleTokenV4(_derivative).tokenPrice()).div(\r\n            IDLE_TOKEN_UNIT\r\n        );\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\r\n        return getUnderlyingForDerivative(_asset) != address(0);\r\n    }\r\n\r\n    /// @dev Helper to validate the derivative-underlying pair.\r\n    /// Inherited from SingleUnderlyingDerivativeRegistryMixin.\r\n    function __validateDerivative(address _derivative, address _underlying) internal override {\r\n        require(\r\n            IIdleTokenV4(_derivative).token() == _underlying,\r\n            \"__validateDerivative: Invalid underlying for IdleToken\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IIdleTokenV4.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title IIdleTokenV4 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for our interactions with IdleToken (V4) contracts\r\ninterface IIdleTokenV4 {\r\n    function getGovTokensAmounts(address) external view returns (uint256[] calldata);\r\n\r\n    function govTokens(uint256) external view returns (address);\r\n\r\n    function mintIdleToken(\r\n        uint256,\r\n        bool,\r\n        address\r\n    ) external returns (uint256);\r\n\r\n    function redeemIdleToken(uint256) external returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function tokenPrice() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/IdleV4ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/IIdleTokenV4.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title IdleV4ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with Idle tokens (V4)\r\nabstract contract IdleV4ActionsMixin is AssetHelpers {\r\n    address private constant IDLE_V4_REFERRAL_ACCOUNT = 0x1ad1fc9964c551f456238Dd88D6a38344B5319D7;\r\n\r\n    /// @dev Helper to claim gov token rewards for an IdleToken balance.\r\n    /// Requires that the current contract has already been transferred the idleToken balance.\r\n    function __idleV4ClaimRewards(address _idleToken) internal {\r\n        IIdleTokenV4(_idleToken).redeemIdleToken(0);\r\n    }\r\n\r\n    /// @dev Helper to get all rewards tokens for a specified idleToken\r\n    function __idleV4GetRewardsTokens(address _idleToken)\r\n        internal\r\n        view\r\n        returns (address[] memory rewardsTokens_)\r\n    {\r\n        IIdleTokenV4 idleTokenContract = IIdleTokenV4(_idleToken);\r\n\r\n        rewardsTokens_ = new address[](idleTokenContract.getGovTokensAmounts(address(0)).length);\r\n        for (uint256 i; i < rewardsTokens_.length; i++) {\r\n            rewardsTokens_[i] = IIdleTokenV4(idleTokenContract).govTokens(i);\r\n        }\r\n\r\n        return rewardsTokens_;\r\n    }\r\n\r\n    /// @dev Helper to lend underlying for IdleToken\r\n    function __idleV4Lend(\r\n        address _idleToken,\r\n        address _underlying,\r\n        uint256 _underlyingAmount\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_underlying, _idleToken, _underlyingAmount);\r\n        IIdleTokenV4(_idleToken).mintIdleToken(_underlyingAmount, true, IDLE_V4_REFERRAL_ACCOUNT);\r\n    }\r\n\r\n    /// @dev Helper to redeem IdleToken for underlying\r\n    function __idleV4Redeem(address _idleToken, uint256 _idleTokenAmount) internal {\r\n        IIdleTokenV4(_idleToken).redeemIdleToken(_idleTokenAmount);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/AdapterBase2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./AdapterBase.sol\";\r\n\r\n/// @title AdapterBase2 Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A base contract for integration adapters that extends AdapterBase\r\n/// @dev This is a temporary contract that will be merged into AdapterBase with the next release\r\nabstract contract AdapterBase2 is AdapterBase {\r\n    /// @dev Provides a standard implementation for transferring incoming assets and\r\n    /// unspent spend assets from an adapter to a VaultProxy at the end of an adapter action\r\n    modifier postActionAssetsTransferHandler(\r\n        address _vaultProxy,\r\n        bytes memory _encodedAssetTransferArgs\r\n    ) {\r\n        _;\r\n\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            ,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        __transferFullAssetBalances(_vaultProxy, incomingAssets);\r\n        __transferFullAssetBalances(_vaultProxy, spendAssets);\r\n    }\r\n\r\n    /// @dev Provides a standard implementation for transferring incoming assets\r\n    /// from an adapter to a VaultProxy at the end of an adapter action\r\n    modifier postActionIncomingAssetsTransferHandler(\r\n        address _vaultProxy,\r\n        bytes memory _encodedAssetTransferArgs\r\n    ) {\r\n        _;\r\n\r\n        (, , , address[] memory incomingAssets) = __decodeEncodedAssetTransferArgs(\r\n            _encodedAssetTransferArgs\r\n        );\r\n\r\n        __transferFullAssetBalances(_vaultProxy, incomingAssets);\r\n    }\r\n\r\n    /// @dev Provides a standard implementation for transferring unspent spend assets\r\n    /// from an adapter to a VaultProxy at the end of an adapter action\r\n    modifier postActionSpendAssetsTransferHandler(\r\n        address _vaultProxy,\r\n        bytes memory _encodedAssetTransferArgs\r\n    ) {\r\n        _;\r\n\r\n        (, address[] memory spendAssets, , ) = __decodeEncodedAssetTransferArgs(\r\n            _encodedAssetTransferArgs\r\n        );\r\n\r\n        __transferFullAssetBalances(_vaultProxy, spendAssets);\r\n    }\r\n\r\n    constructor(address _integrationManager) public AdapterBase(_integrationManager) {}\r\n\r\n    /// @dev Helper to transfer full asset balances of current contract to the specified target\r\n    function __transferFullAssetBalances(address _target, address[] memory _assets) internal {\r\n        for (uint256 i = 0; i < _assets.length; i++) {\r\n            uint256 balance = ERC20(_assets[i]).balanceOf(address(this));\r\n            if (balance > 0) {\r\n                ERC20(_assets[i]).safeTransfer(_target, balance);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/SingleUnderlyingDerivativeRegistryMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\n\r\n/// @title SingleUnderlyingDerivativeRegistryMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin for derivative price feeds that handle multiple derivatives\r\n/// that each have a single underlying asset\r\nabstract contract SingleUnderlyingDerivativeRegistryMixin is FundDeployerOwnerMixin {\r\n    event DerivativeAdded(address indexed derivative, address indexed underlying);\r\n\r\n    event DerivativeRemoved(address indexed derivative);\r\n\r\n    mapping(address => address) private derivativeToUnderlying;\r\n\r\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\r\n\r\n    /// @notice Adds derivatives with corresponding underlyings to the price feed\r\n    /// @param _derivatives The derivatives to add\r\n    /// @param _underlyings The corresponding underlyings to add\r\n    function addDerivatives(address[] memory _derivatives, address[] memory _underlyings)\r\n        external\r\n        virtual\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(_derivatives.length > 0, \"addDerivatives: Empty _derivatives\");\r\n        require(_derivatives.length == _underlyings.length, \"addDerivatives: Unequal arrays\");\r\n\r\n        for (uint256 i; i < _derivatives.length; i++) {\r\n            require(_derivatives[i] != address(0), \"addDerivatives: Empty derivative\");\r\n            require(_underlyings[i] != address(0), \"addDerivatives: Empty underlying\");\r\n            require(\r\n                getUnderlyingForDerivative(_derivatives[i]) == address(0),\r\n                \"addDerivatives: Value already set\"\r\n            );\r\n\r\n            __validateDerivative(_derivatives[i], _underlyings[i]);\r\n\r\n            derivativeToUnderlying[_derivatives[i]] = _underlyings[i];\r\n\r\n            emit DerivativeAdded(_derivatives[i], _underlyings[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Removes derivatives from the price feed\r\n    /// @param _derivatives The derivatives to remove\r\n    function removeDerivatives(address[] memory _derivatives) external onlyFundDeployerOwner {\r\n        require(_derivatives.length > 0, \"removeDerivatives: Empty _derivatives\");\r\n\r\n        for (uint256 i; i < _derivatives.length; i++) {\r\n            require(\r\n                getUnderlyingForDerivative(_derivatives[i]) != address(0),\r\n                \"removeDerivatives: Value not set\"\r\n            );\r\n\r\n            delete derivativeToUnderlying[_derivatives[i]];\r\n\r\n            emit DerivativeRemoved(_derivatives[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Optionally allow the inheriting price feed to validate the derivative-underlying pair\r\n    function __validateDerivative(address, address) internal virtual {\r\n        // UNIMPLEMENTED\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the underlying asset for a given derivative\r\n    /// @param _derivative The derivative for which to get the underlying asset\r\n    /// @return underlying_ The underlying asset\r\n    function getUnderlyingForDerivative(address _derivative)\r\n        public\r\n        view\r\n        returns (address underlying_)\r\n    {\r\n        return derivativeToUnderlying[_derivative];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/YearnVaultV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/YearnVaultV2PriceFeed.sol\";\r\nimport \"../utils/actions/YearnVaultV2ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title YearnVaultV2Adapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with Yearn v2 vaults\r\ncontract YearnVaultV2Adapter is AdapterBase2, YearnVaultV2ActionsMixin {\r\n    address private immutable YEARN_VAULT_V2_PRICE_FEED;\r\n\r\n    constructor(address _integrationManager, address _yearnVaultV2PriceFeed)\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n    {\r\n        YEARN_VAULT_V2_PRICE_FEED = _yearnVaultV2PriceFeed;\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"YEARN_VAULT_V2\";\r\n    }\r\n\r\n    /// @notice Deposits an amount of an underlying asset into its corresponding yVault\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev Using postActionSpendAssetsTransferHandler is probably overkill, but since new\r\n    /// yVault v2 contracts can update logic, this protects against a future implementation in\r\n    /// which a partial underlying deposit amount is used if the desired amount exceeds the\r\n    /// deposit limit, for example.\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        // More efficient to parse all from _encodedAssetTransferArgs\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        __yearnVaultV2Lend(_vaultProxy, incomingAssets[0], spendAssets[0], spendAssetAmounts[0]);\r\n    }\r\n\r\n    /// @notice Redeems an amount of yVault shares for its underlying asset\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev The amount of yVault shares to be redeemed can be adjusted in yVault.withdraw()\r\n    /// depending on the available underlying balance, so we must send unredeemed yVault shares\r\n    /// back to the _vaultProxy\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            address yVault,\r\n            uint256 maxOutgoingYVaultSharesAmount,\r\n            ,\r\n            uint256 slippageToleranceBps\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __yearnVaultV2Redeem(\r\n            _vaultProxy,\r\n            yVault,\r\n            maxOutgoingYVaultSharesAmount,\r\n            slippageToleranceBps\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to get the underlying for a given Yearn Vault\r\n    function __getUnderlyingForYVault(address _yVault) private view returns (address underlying_) {\r\n        return\r\n            YearnVaultV2PriceFeed(getYearnVaultV2PriceFeed()).getUnderlyingForDerivative(_yVault);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address yVault,\r\n            uint256 outgoingUnderlyingAmount,\r\n            uint256 minIncomingYVaultSharesAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        address underlying = __getUnderlyingForYVault(yVault);\r\n        require(underlying != address(0), \"__parseAssetsForLend: Unsupported yVault\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = underlying;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingUnderlyingAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = yVault;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingYVaultSharesAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address yVault,\r\n            uint256 maxOutgoingYVaultSharesAmount,\r\n            uint256 minIncomingUnderlyingAmount,\r\n\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        address underlying = __getUnderlyingForYVault(yVault);\r\n        require(underlying != address(0), \"__parseAssetsForRedeem: Unsupported yVault\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = yVault;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = maxOutgoingYVaultSharesAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = underlying;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingUnderlyingAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode callArgs for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address yVault_,\r\n            uint256 outgoingUnderlyingAmount_,\r\n            uint256 minIncomingYVaultSharesAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode callArgs for redeeming\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address yVault_,\r\n            uint256 maxOutgoingYVaultSharesAmount_,\r\n            uint256 minIncomingUnderlyingAmount_,\r\n            uint256 slippageToleranceBps_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, uint256, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `YEARN_VAULT_V2_PRICE_FEED` variable\r\n    /// @return yearnVaultV2PriceFeed_ The `YEARN_VAULT_V2_PRICE_FEED` variable value\r\n    function getYearnVaultV2PriceFeed() public view returns (address yearnVaultV2PriceFeed_) {\r\n        return YEARN_VAULT_V2_PRICE_FEED;\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/YearnVaultV2PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../interfaces/IYearnVaultV2.sol\";\r\nimport \"../../../../interfaces/IYearnVaultV2Registry.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\nimport \"./utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\r\n\r\n/// @title YearnVaultV2PriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Yearn Vault V2 shares\r\ncontract YearnVaultV2PriceFeed is IDerivativePriceFeed, SingleUnderlyingDerivativeRegistryMixin {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable YEARN_VAULT_V2_REGISTRY;\r\n\r\n    constructor(address _fundDeployer, address _yearnVaultV2Registry)\r\n        public\r\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\r\n    {\r\n        YEARN_VAULT_V2_REGISTRY = _yearnVaultV2Registry;\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = getUnderlyingForDerivative(_derivative);\r\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\r\n\r\n        underlyingAmounts_ = new uint256[](1);\r\n        underlyingAmounts_[0] = _derivativeAmount\r\n            .mul(IYearnVaultV2(_derivative).pricePerShare())\r\n            .div(10**uint256(ERC20(_derivative).decimals()));\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\r\n        return getUnderlyingForDerivative(_asset) != address(0);\r\n    }\r\n\r\n    /// @dev Helper to validate the derivative-underlying pair.\r\n    /// Inherited from SingleUnderlyingDerivativeRegistryMixin.\r\n    function __validateDerivative(address _derivative, address _underlying) internal override {\r\n        // Only validate that the _derivative is a valid yVault using the V2 contract,\r\n        // not that it is the latest vault for a particular _underlying\r\n        bool isValidYearnVaultV2;\r\n        IYearnVaultV2Registry yearnRegistryContract = IYearnVaultV2Registry(\r\n            getYearnVaultV2Registry()\r\n        );\r\n        for (uint256 i; i < yearnRegistryContract.numVaults(_underlying); i++) {\r\n            if (yearnRegistryContract.vaults(_underlying, i) == _derivative) {\r\n                isValidYearnVaultV2 = true;\r\n                break;\r\n            }\r\n        }\r\n        require(isValidYearnVaultV2, \"__validateDerivative: Invalid yVault for underlying\");\r\n\r\n        // Validates our assumption that yVaults and underlyings will have the same decimals\r\n        require(\r\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\r\n            \"__validateDerivative: Incongruent decimals\"\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `YEARN_VAULT_V2_REGISTRY` variable\r\n    /// @return yearnVaultV2Registry_ The `YEARN_VAULT_V2_REGISTRY` variable value\r\n    function getYearnVaultV2Registry() public view returns (address yearnVaultV2Registry_) {\r\n        return YEARN_VAULT_V2_REGISTRY;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/YearnVaultV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/IYearnVaultV2.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title YearnVaultV2ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with Yearn v2 vaults\r\nabstract contract YearnVaultV2ActionsMixin is AssetHelpers {\r\n    /// @dev Helper to lend underlying for yVault shares\r\n    function __yearnVaultV2Lend(\r\n        address _recipient,\r\n        address _yVault,\r\n        address _underlying,\r\n        uint256 _underlyingAmount\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_underlying, _yVault, _underlyingAmount);\r\n        IYearnVaultV2(_yVault).deposit(_underlyingAmount, _recipient);\r\n    }\r\n\r\n    /// @dev Helper to redeem yVault shares for underlying\r\n    function __yearnVaultV2Redeem(\r\n        address _recipient,\r\n        address _yVault,\r\n        uint256 _yVaultSharesAmount,\r\n        uint256 _slippageToleranceBps\r\n    ) internal {\r\n        IYearnVaultV2(_yVault).withdraw(_yVaultSharesAmount, _recipient, _slippageToleranceBps);\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IYearnVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IYearnVaultV2 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for our interactions with Yearn Vault V2 contracts\r\ninterface IYearnVaultV2 {\r\n    function deposit(uint256, address) external returns (uint256);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function withdraw(\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/interfaces/IYearnVaultV2Registry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IYearnVaultV2Registry Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for our interactions with the Yearn Vault V2 registry\r\ninterface IYearnVaultV2Registry {\r\n    function numVaults(address) external view returns (uint256);\r\n\r\n    function vaults(address, uint256) external view returns (address);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/UniswapV3ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../../../../../interfaces/IUniswapV3SwapRouter.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title UniswapV3ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with Uniswap v3\r\nabstract contract UniswapV3ActionsMixin is AssetHelpers {\r\n    address private immutable UNISWAP_V3_ROUTER;\r\n\r\n    constructor(address _router) public {\r\n        UNISWAP_V3_ROUTER = _router;\r\n    }\r\n\r\n    /// @dev Helper to execute a swap\r\n    // UniswapV3 paths are packed encoded as (address(_pathAddresses[i]), uint24(_pathFees[i]), address(_pathAddresses[i + 1]), [...])\r\n    // _pathFees[i] represents the fee for the pool between _pathAddresses(i) and _pathAddresses(i+1)\r\n    function __uniswapV3Swap(\r\n        address _recipient,\r\n        address[] memory _pathAddresses,\r\n        uint24[] memory _pathFees,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minIncomingAssetAmount\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_pathAddresses[0], UNISWAP_V3_ROUTER, _outgoingAssetAmount);\r\n\r\n        bytes memory encodedPath;\r\n\r\n        for (uint256 i; i < _pathAddresses.length; i++) {\r\n            if (i != _pathAddresses.length - 1) {\r\n                encodedPath = abi.encodePacked(encodedPath, _pathAddresses[i], _pathFees[i]);\r\n            } else {\r\n                encodedPath = abi.encodePacked(encodedPath, _pathAddresses[i]);\r\n            }\r\n        }\r\n\r\n        IUniswapV3SwapRouter.ExactInputParams memory input = IUniswapV3SwapRouter\r\n            .ExactInputParams({\r\n            path: encodedPath,\r\n            recipient: _recipient,\r\n            deadline: block.timestamp + 1,\r\n            amountIn: _outgoingAssetAmount,\r\n            amountOutMinimum: _minIncomingAssetAmount\r\n        });\r\n\r\n        // Execute fill\r\n        IUniswapV3SwapRouter(UNISWAP_V3_ROUTER).exactInput(input);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `UNISWAP_V3_ROUTER` variable\r\n    /// @return router_ The `UNISWAP_V3_ROUTER` variable value\r\n    function getUniswapV3Router() public view returns (address router_) {\r\n        return UNISWAP_V3_ROUTER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IUniswapV3SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title IUniswapV3Router Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @dev Minimal interface for our interactions with Uniswap V3's Router\r\ninterface IUniswapV3SwapRouter {\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata) external payable returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/UniswapV3Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../utils/actions/UniswapV3ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title UniswapV3SwapAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with UniswapV3 swaps\r\ncontract UniswapV3Adapter is AdapterBase2, UniswapV3ActionsMixin {\r\n    constructor(address _integrationManager, address _router)\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        UniswapV3ActionsMixin(_router)\r\n    {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"UNISWAP_V3\";\r\n    }\r\n\r\n    /// @notice Trades assets on UniswapV3\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (\r\n            address[] memory pathAddresses,\r\n            uint24[] memory pathFees,\r\n            uint256 outgoingAssetAmount,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        __uniswapV3Swap(\r\n            _vaultProxy,\r\n            pathAddresses,\r\n            pathFees,\r\n            outgoingAssetAmount,\r\n            minIncomingAssetAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n\r\n        (\r\n            address[] memory pathAddresses,\r\n            uint24[] memory pathFees,\r\n            uint256 outgoingAssetAmount,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        require(pathAddresses.length >= 2, \"parseAssetsForMethod: pathAddresses must be >= 2\");\r\n        require(\r\n            pathAddresses.length == pathFees.length + 1,\r\n            \"parseAssetsForMethod: incorrect pathAddresses or pathFees length\"\r\n        );\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = pathAddresses[0];\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = pathAddresses[pathAddresses.length - 1];\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded callOnIntegration call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address[] memory pathAddresses,\r\n            uint24[] memory pathFees,\r\n            uint256 outgoingAssetAmount,\r\n            uint256 minIncomingAssetAmount\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[], uint24[], uint256, uint256));\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/ParaSwapV4ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/IParaSwapV4AugustusSwapper.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title ParaSwapV4ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with ParaSwap (v4)\r\nabstract contract ParaSwapV4ActionsMixin is AssetHelpers {\r\n    string private constant REFERRER = \"enzyme\";\r\n\r\n    address private immutable PARA_SWAP_V4_AUGUSTUS_SWAPPER;\r\n    address private immutable PARA_SWAP_V4_TOKEN_TRANSFER_PROXY;\r\n\r\n    constructor(address _augustusSwapper, address _tokenTransferProxy) public {\r\n        PARA_SWAP_V4_AUGUSTUS_SWAPPER = _augustusSwapper;\r\n        PARA_SWAP_V4_TOKEN_TRANSFER_PROXY = _tokenTransferProxy;\r\n    }\r\n\r\n    /// @dev Helper to execute a multiSwap() order\r\n    function __paraSwapV4MultiSwap(\r\n        address _fromToken,\r\n        uint256 _fromAmount,\r\n        uint256 _toAmount,\r\n        uint256 _expectedAmount,\r\n        address payable _beneficiary,\r\n        IParaSwapV4AugustusSwapper.Path[] memory _path\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_fromToken, PARA_SWAP_V4_TOKEN_TRANSFER_PROXY, _fromAmount);\r\n\r\n        IParaSwapV4AugustusSwapper.SellData memory sellData = IParaSwapV4AugustusSwapper.SellData({\r\n            fromToken: _fromToken,\r\n            fromAmount: _fromAmount,\r\n            toAmount: _toAmount,\r\n            expectedAmount: _expectedAmount,\r\n            beneficiary: _beneficiary,\r\n            referrer: REFERRER,\r\n            useReduxToken: false,\r\n            path: _path\r\n        });\r\n\r\n        IParaSwapV4AugustusSwapper(PARA_SWAP_V4_AUGUSTUS_SWAPPER).multiSwap(sellData);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `PARA_SWAP_V4_AUGUSTUS_SWAPPER` variable\r\n    /// @return augustusSwapper_ The `PARA_SWAP_V4_AUGUSTUS_SWAPPER` variable value\r\n    function getParaSwapV4AugustusSwapper() public view returns (address augustusSwapper_) {\r\n        return PARA_SWAP_V4_AUGUSTUS_SWAPPER;\r\n    }\r\n\r\n    /// @notice Gets the `PARA_SWAP_V4_TOKEN_TRANSFER_PROXY` variable\r\n    /// @return tokenTransferProxy_ The `PARA_SWAP_V4_TOKEN_TRANSFER_PROXY` variable value\r\n    function getParaSwapV4TokenTransferProxy() public view returns (address tokenTransferProxy_) {\r\n        return PARA_SWAP_V4_TOKEN_TRANSFER_PROXY;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IParaSwapV4AugustusSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title ParaSwap V4 IAugustusSwapper interface\r\ninterface IParaSwapV4AugustusSwapper {\r\n    struct Route {\r\n        address payable exchange;\r\n        address targetExchange;\r\n        uint256 percent;\r\n        bytes payload;\r\n        uint256 networkFee;\r\n    }\r\n\r\n    struct Path {\r\n        address to;\r\n        uint256 totalNetworkFee;\r\n        Route[] routes;\r\n    }\r\n\r\n    struct SellData {\r\n        address fromToken;\r\n        uint256 fromAmount;\r\n        uint256 toAmount;\r\n        uint256 expectedAmount;\r\n        address payable beneficiary;\r\n        string referrer;\r\n        bool useReduxToken;\r\n        Path[] path;\r\n    }\r\n\r\n    function multiSwap(SellData calldata) external payable returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/ParaSwapV4Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../utils/actions/ParaSwapV4ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title ParaSwapV4Adapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with ParaSwap (v4)\r\n/// @dev Does not allow any protocol that collects protocol fees in ETH, e.g., 0x v3\r\ncontract ParaSwapV4Adapter is AdapterBase2, ParaSwapV4ActionsMixin {\r\n    using SafeMath for uint256;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _augustusSwapper,\r\n        address _tokenTransferProxy\r\n    )\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        ParaSwapV4ActionsMixin(_augustusSwapper, _tokenTransferProxy)\r\n    {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"PARA_SWAP_V4\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n\r\n        (\r\n            uint256 minIncomingAssetAmount,\r\n            ,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount,\r\n            IParaSwapV4AugustusSwapper.Path[] memory paths\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = outgoingAsset;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = paths[paths.length - 1].to;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Trades assets on ParaSwap\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev ParaSwap v4 completely uses entire outgoing asset balance and incoming asset\r\n    /// is sent directly to the beneficiary (the _vaultProxy)\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (\r\n            uint256 minIncomingAssetAmount,\r\n            uint256 expectedIncomingAssetAmount,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount,\r\n            IParaSwapV4AugustusSwapper.Path[] memory paths\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        __paraSwapV4MultiSwap(\r\n            outgoingAsset,\r\n            outgoingAssetAmount,\r\n            minIncomingAssetAmount,\r\n            expectedIncomingAssetAmount,\r\n            payable(_vaultProxy),\r\n            paths\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded callOnIntegration call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 minIncomingAssetAmount_,\r\n            uint256 expectedIncomingAssetAmount_, // Passed as a courtesy to ParaSwap for analytics\r\n            address outgoingAsset_,\r\n            uint256 outgoingAssetAmount_,\r\n            IParaSwapV4AugustusSwapper.Path[] memory paths_\r\n        )\r\n    {\r\n        return\r\n            abi.decode(\r\n                _encodedCallArgs,\r\n                (uint256, uint256, address, uint256, IParaSwapV4AugustusSwapper.Path[])\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity ^0.6.12;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title ICERC20 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for interactions with Compound tokens (cTokens)\r\ninterface ICERC20 is IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function mint(uint256) external returns (uint256);\r\n\r\n    function redeem(uint256) external returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    function underlying() external returns (address);\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/CompoundPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../../../../interfaces/ICERC20.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title CompoundPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Compound Tokens (cTokens)\r\ncontract CompoundPriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\r\n    using SafeMath for uint256;\r\n\r\n    event CTokenAdded(address indexed cToken, address indexed token);\r\n\r\n    uint256 private constant CTOKEN_RATE_DIVISOR = 10**18;\r\n\r\n    mapping(address => address) private cTokenToToken;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address _weth,\r\n        address _ceth,\r\n        address[] memory cERC20Tokens\r\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\r\n        // Set cEth\r\n        cTokenToToken[_ceth] = _weth;\r\n        emit CTokenAdded(_ceth, _weth);\r\n\r\n        // Set any other cTokens\r\n        if (cERC20Tokens.length > 0) {\r\n            __addCERC20Tokens(cERC20Tokens);\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = cTokenToToken[_derivative];\r\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\r\n\r\n        underlyingAmounts_ = new uint256[](1);\r\n        // Returns a rate scaled to 10^18\r\n        underlyingAmounts_[0] = _derivativeAmount\r\n            .mul(ICERC20(_derivative).exchangeRateStored())\r\n            .div(CTOKEN_RATE_DIVISOR);\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\r\n        return cTokenToToken[_asset] != address(0);\r\n    }\r\n\r\n    //////////////////////\r\n    // CTOKENS REGISTRY //\r\n    //////////////////////\r\n\r\n    /// @notice Adds cTokens to the price feed\r\n    /// @param _cTokens cTokens to add\r\n    /// @dev Only allows CERC20 tokens. CEther is set in the constructor.\r\n    function addCTokens(address[] calldata _cTokens) external onlyFundDeployerOwner {\r\n        __addCERC20Tokens(_cTokens);\r\n    }\r\n\r\n    /// @dev Helper to add cTokens\r\n    function __addCERC20Tokens(address[] memory _cTokens) private {\r\n        require(_cTokens.length > 0, \"__addCTokens: Empty _cTokens\");\r\n\r\n        for (uint256 i; i < _cTokens.length; i++) {\r\n            require(cTokenToToken[_cTokens[i]] == address(0), \"__addCTokens: Value already set\");\r\n\r\n            address token = ICERC20(_cTokens[i]).underlying();\r\n            cTokenToToken[_cTokens[i]] = token;\r\n\r\n            emit CTokenAdded(_cTokens[i], token);\r\n        }\r\n    }\r\n\r\n    ////////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Returns the underlying asset of a given cToken\r\n    /// @param _cToken The cToken for which to get the underlying asset\r\n    /// @return token_ The underlying token\r\n    function getTokenFromCToken(address _cToken) public view returns (address token_) {\r\n        return cTokenToToken[_cToken];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CompoundAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/CompoundPriceFeed.sol\";\r\nimport \"../../../../interfaces/ICERC20.sol\";\r\nimport \"../../../../interfaces/ICEther.sol\";\r\nimport \"../../../../interfaces/IWETH.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title CompoundAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for Compound <https://compound.finance/>\r\ncontract CompoundAdapter is AdapterBase {\r\n    address private immutable COMPOUND_PRICE_FEED;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _compoundPriceFeed,\r\n        address _wethToken\r\n    ) public AdapterBase(_integrationManager) {\r\n        COMPOUND_PRICE_FEED = _compoundPriceFeed;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @dev Needed to receive ETH during cEther lend/redeem\r\n    receive() external payable {}\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"COMPOUND\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == LEND_SELECTOR) {\r\n            (address cToken, uint256 tokenAmount, uint256 minCTokenAmount) = __decodeCallArgs(\r\n                _encodedCallArgs\r\n            );\r\n            address token = CompoundPriceFeed(COMPOUND_PRICE_FEED).getTokenFromCToken(cToken);\r\n            require(token != address(0), \"parseAssetsForMethod: Unsupported cToken\");\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = token;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = tokenAmount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = cToken;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minCTokenAmount;\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            (address cToken, uint256 cTokenAmount, uint256 minTokenAmount) = __decodeCallArgs(\r\n                _encodedCallArgs\r\n            );\r\n            address token = CompoundPriceFeed(COMPOUND_PRICE_FEED).getTokenFromCToken(cToken);\r\n            require(token != address(0), \"parseAssetsForMethod: Unsupported cToken\");\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = cToken;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = cTokenAmount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = token;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minTokenAmount;\r\n        } else {\r\n            revert(\"parseAssetsForMethod: _selector invalid\");\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Lends an amount of a token to Compound\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        // More efficient to parse all from _encodedAssetTransferArgs\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        if (spendAssets[0] == WETH_TOKEN) {\r\n            IWETH(WETH_TOKEN).withdraw(spendAssetAmounts[0]);\r\n            ICEther(incomingAssets[0]).mint{value: spendAssetAmounts[0]}();\r\n        } else {\r\n            __approveMaxAsNeeded(spendAssets[0], incomingAssets[0], spendAssetAmounts[0]);\r\n            ICERC20(incomingAssets[0]).mint(spendAssetAmounts[0]);\r\n        }\r\n    }\r\n\r\n    /// @notice Redeems an amount of cTokens from Compound\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        // More efficient to parse all from _encodedAssetTransferArgs\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        ICERC20(spendAssets[0]).redeem(spendAssetAmounts[0]);\r\n\r\n        if (incomingAssets[0] == WETH_TOKEN) {\r\n            IWETH(payable(WETH_TOKEN)).deposit{value: payable(address(this)).balance}();\r\n        }\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode callArgs for lend and redeem\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address cToken_,\r\n            uint256 outgoingAssetAmount_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `COMPOUND_PRICE_FEED` variable\r\n    /// @return compoundPriceFeed_ The `COMPOUND_PRICE_FEED` variable value\r\n    function getCompoundPriceFeed() external view returns (address compoundPriceFeed_) {\r\n        return COMPOUND_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICEther.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/// @title ICEther Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Minimal interface for interactions with Compound Ether\r\ninterface ICEther {\r\n    function mint() external payable;\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/KyberAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../interfaces/IKyberNetworkProxy.sol\";\r\nimport \"../../../../interfaces/IWETH.sol\";\r\nimport \"../../../../utils/MathHelpers.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title KyberAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for interacting with Kyber Network\r\ncontract KyberAdapter is AdapterBase, MathHelpers {\r\n    address private immutable EXCHANGE;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _exchange,\r\n        address _wethToken\r\n    ) public AdapterBase(_integrationManager) {\r\n        EXCHANGE = _exchange;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @dev Needed to receive ETH from swap\r\n    receive() external payable {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"KYBER_NETWORK\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n\r\n        (\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        require(\r\n            incomingAsset != outgoingAsset,\r\n            \"parseAssetsForMethod: incomingAsset and outgoingAsset asset cannot be the same\"\r\n        );\r\n        require(outgoingAssetAmount > 0, \"parseAssetsForMethod: outgoingAssetAmount must be >0\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = outgoingAsset;\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Trades assets on Kyber\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        uint256 minExpectedRate = __calcNormalizedRate(\r\n            ERC20(outgoingAsset).decimals(),\r\n            outgoingAssetAmount,\r\n            ERC20(incomingAsset).decimals(),\r\n            minIncomingAssetAmount\r\n        );\r\n\r\n        if (outgoingAsset == WETH_TOKEN) {\r\n            __swapNativeAssetToToken(incomingAsset, outgoingAssetAmount, minExpectedRate);\r\n        } else if (incomingAsset == WETH_TOKEN) {\r\n            __swapTokenToNativeAsset(outgoingAsset, outgoingAssetAmount, minExpectedRate);\r\n        } else {\r\n            __swapTokenToToken(incomingAsset, outgoingAsset, outgoingAssetAmount, minExpectedRate);\r\n        }\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the encoded call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_,\r\n            address outgoingAsset_,\r\n            uint256 outgoingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256, address, uint256));\r\n    }\r\n\r\n    /// @dev Executes a swap of ETH to ERC20\r\n    function __swapNativeAssetToToken(\r\n        address _incomingAsset,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minExpectedRate\r\n    ) private {\r\n        IWETH(payable(WETH_TOKEN)).withdraw(_outgoingAssetAmount);\r\n\r\n        IKyberNetworkProxy(EXCHANGE).swapEtherToToken{value: _outgoingAssetAmount}(\r\n            _incomingAsset,\r\n            _minExpectedRate\r\n        );\r\n    }\r\n\r\n    /// @dev Executes a swap of ERC20 to ETH\r\n    function __swapTokenToNativeAsset(\r\n        address _outgoingAsset,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minExpectedRate\r\n    ) private {\r\n        __approveMaxAsNeeded(_outgoingAsset, EXCHANGE, _outgoingAssetAmount);\r\n\r\n        IKyberNetworkProxy(EXCHANGE).swapTokenToEther(\r\n            _outgoingAsset,\r\n            _outgoingAssetAmount,\r\n            _minExpectedRate\r\n        );\r\n\r\n        IWETH(payable(WETH_TOKEN)).deposit{value: payable(address(this)).balance}();\r\n    }\r\n\r\n    /// @dev Executes a swap of ERC20 to ERC20\r\n    function __swapTokenToToken(\r\n        address _incomingAsset,\r\n        address _outgoingAsset,\r\n        uint256 _outgoingAssetAmount,\r\n        uint256 _minExpectedRate\r\n    ) private {\r\n        __approveMaxAsNeeded(_outgoingAsset, EXCHANGE, _outgoingAssetAmount);\r\n\r\n        IKyberNetworkProxy(EXCHANGE).swapTokenToToken(\r\n            _outgoingAsset,\r\n            _outgoingAssetAmount,\r\n            _incomingAsset,\r\n            _minExpectedRate\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `EXCHANGE` variable\r\n    /// @return exchange_ The `EXCHANGE` variable value\r\n    function getExchange() external view returns (address exchange_) {\r\n        return EXCHANGE;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IKyberNetworkProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Kyber Network interface\r\ninterface IKyberNetworkProxy {\r\n    function swapEtherToToken(address, uint256) external payable returns (uint256);\r\n\r\n    function swapTokenToEther(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256);\r\n\r\n    function swapTokenToToken(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/mocks/integratees/MockKyberIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../release/utils/MathHelpers.sol\";\r\nimport \"../prices/CentralizedRateProvider.sol\";\r\nimport \"../utils/SwapperBase.sol\";\r\n\r\ncontract MockKyberIntegratee is SwapperBase, Ownable, MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable CENTRALIZED_RATE_PROVIDER;\r\n    address private immutable WETH;\r\n\r\n    uint256 private constant PRECISION = 18;\r\n\r\n    // Deviation set in % defines the MAX deviation per block from the mean rate\r\n    uint256 private blockNumberDeviation;\r\n\r\n    constructor(\r\n        address _centralizedRateProvider,\r\n        address _weth,\r\n        uint256 _blockNumberDeviation\r\n    ) public {\r\n        CENTRALIZED_RATE_PROVIDER = _centralizedRateProvider;\r\n        WETH = _weth;\r\n        blockNumberDeviation = _blockNumberDeviation;\r\n    }\r\n\r\n    function swapEtherToToken(address _destToken, uint256) external payable returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomized(WETH, msg.value, _destToken, blockNumberDeviation);\r\n\r\n        __swapAssets(msg.sender, ETH_ADDRESS, msg.value, _destToken, destAmount);\r\n        return msg.value;\r\n    }\r\n\r\n    function swapTokenToEther(\r\n        address _srcToken,\r\n        uint256 _srcAmount,\r\n        uint256\r\n    ) external returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomized(_srcToken, _srcAmount, WETH, blockNumberDeviation);\r\n\r\n        __swapAssets(msg.sender, _srcToken, _srcAmount, ETH_ADDRESS, destAmount);\r\n        return _srcAmount;\r\n    }\r\n\r\n    function swapTokenToToken(\r\n        address _srcToken,\r\n        uint256 _srcAmount,\r\n        address _destToken,\r\n        uint256\r\n    ) external returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomized(_srcToken, _srcAmount, _destToken, blockNumberDeviation);\r\n\r\n        __swapAssets(msg.sender, _srcToken, _srcAmount, _destToken, destAmount);\r\n        return _srcAmount;\r\n    }\r\n\r\n    function setBlockNumberDeviation(uint256 _deviationPct) external onlyOwner {\r\n        blockNumberDeviation = _deviationPct;\r\n    }\r\n\r\n    function getExpectedRate(\r\n        address _srcToken,\r\n        address _destToken,\r\n        uint256 _amount\r\n    ) external returns (uint256 rate_, uint256 worstRate_) {\r\n        if (_srcToken == ETH_ADDRESS) {\r\n            _srcToken = WETH;\r\n        }\r\n        if (_destToken == ETH_ADDRESS) {\r\n            _destToken = WETH;\r\n        }\r\n\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomizedBySender(_srcToken, _amount, _destToken);\r\n        rate_ = __calcNormalizedRate(\r\n            ERC20(_srcToken).decimals(),\r\n            _amount,\r\n            ERC20(_destToken).decimals(),\r\n            destAmount\r\n        );\r\n        worstRate_ = rate_.mul(uint256(100).sub(blockNumberDeviation)).div(100);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    function getCentralizedRateProvider() public view returns (address) {\r\n        return CENTRALIZED_RATE_PROVIDER;\r\n    }\r\n\r\n    function getWeth() public view returns (address) {\r\n        return WETH;\r\n    }\r\n\r\n    function getBlockNumberDeviation() public view returns (uint256) {\r\n        return blockNumberDeviation;\r\n    }\r\n\r\n    function getPrecision() public pure returns (uint256) {\r\n        return PRECISION;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/utils/SwapperBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./EthConstantMixin.sol\";\r\n\r\nabstract contract SwapperBase is EthConstantMixin {\r\n    receive() external payable {}\r\n\r\n    function __swapAssets(\r\n        address payable _trader,\r\n        address _srcToken,\r\n        uint256 _srcAmount,\r\n        address _destToken,\r\n        uint256 _actualRate\r\n    ) internal returns (uint256 destAmount_) {\r\n        address[] memory assetsToIntegratee = new address[](1);\r\n        assetsToIntegratee[0] = _srcToken;\r\n        uint256[] memory assetsToIntegrateeAmounts = new uint256[](1);\r\n        assetsToIntegrateeAmounts[0] = _srcAmount;\r\n\r\n        address[] memory assetsFromIntegratee = new address[](1);\r\n        assetsFromIntegratee[0] = _destToken;\r\n        uint256[] memory assetsFromIntegrateeAmounts = new uint256[](1);\r\n        assetsFromIntegrateeAmounts[0] = _actualRate;\r\n        __swap(\r\n            _trader,\r\n            assetsToIntegratee,\r\n            assetsToIntegrateeAmounts,\r\n            assetsFromIntegratee,\r\n            assetsFromIntegrateeAmounts\r\n        );\r\n\r\n        return assetsFromIntegrateeAmounts[0];\r\n    }\r\n\r\n    function __swap(\r\n        address payable _trader,\r\n        address[] memory _assetsToIntegratee,\r\n        uint256[] memory _assetsToIntegrateeAmounts,\r\n        address[] memory _assetsFromIntegratee,\r\n        uint256[] memory _assetsFromIntegrateeAmounts\r\n    ) internal {\r\n        // Take custody of incoming assets\r\n        for (uint256 i = 0; i < _assetsToIntegratee.length; i++) {\r\n            address asset = _assetsToIntegratee[i];\r\n            uint256 amount = _assetsToIntegrateeAmounts[i];\r\n            require(asset != address(0), \"__swap: empty value in _assetsToIntegratee\");\r\n            require(amount > 0, \"__swap: empty value in _assetsToIntegrateeAmounts\");\r\n            // Incoming ETH amounts can be ignored\r\n            if (asset == ETH_ADDRESS) {\r\n                continue;\r\n            }\r\n            ERC20(asset).transferFrom(_trader, address(this), amount);\r\n        }\r\n\r\n        // Distribute outgoing assets\r\n        for (uint256 i = 0; i < _assetsFromIntegratee.length; i++) {\r\n            address asset = _assetsFromIntegratee[i];\r\n            uint256 amount = _assetsFromIntegrateeAmounts[i];\r\n            require(asset != address(0), \"__swap: empty value in _assetsFromIntegratee\");\r\n            require(amount > 0, \"__swap: empty value in _assetsFromIntegrateeAmounts\");\r\n            if (asset == ETH_ADDRESS) {\r\n                _trader.transfer(amount);\r\n            } else {\r\n                ERC20(asset).transfer(_trader, amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/utils/EthConstantMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nabstract contract EthConstantMixin {\r\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n}\r\n"
    },
    "contracts/mocks/integratees/utils/MockIntegrateeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/NormalizedRateProviderBase.sol\";\r\nimport \"../../utils/SwapperBase.sol\";\r\n\r\nabstract contract MockIntegrateeBase is NormalizedRateProviderBase, SwapperBase {\r\n    constructor(\r\n        address[] memory _defaultRateAssets,\r\n        address[] memory _specialAssets,\r\n        uint8[] memory _specialAssetDecimals,\r\n        uint256 _ratePrecision\r\n    )\r\n        public\r\n        NormalizedRateProviderBase(\r\n            _defaultRateAssets,\r\n            _specialAssets,\r\n            _specialAssetDecimals,\r\n            _ratePrecision\r\n        )\r\n    {}\r\n\r\n    function __getRate(address _baseAsset, address _quoteAsset)\r\n        internal\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        // 1. Return constant if base asset is quote asset\r\n        if (_baseAsset == _quoteAsset) {\r\n            return 10**RATE_PRECISION;\r\n        }\r\n\r\n        // 2. Check for a direct rate\r\n        uint256 directRate = assetToAssetRate[_baseAsset][_quoteAsset];\r\n        if (directRate > 0) {\r\n            return directRate;\r\n        }\r\n\r\n        // 3. Check for inverse direct rate\r\n        uint256 iDirectRate = assetToAssetRate[_quoteAsset][_baseAsset];\r\n        if (iDirectRate > 0) {\r\n            return 10**(RATE_PRECISION.mul(2)).div(iDirectRate);\r\n        }\r\n\r\n        // 4. Else return 1\r\n        return 10**RATE_PRECISION;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/utils/NormalizedRateProviderBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"./RateProviderBase.sol\";\r\n\r\nabstract contract NormalizedRateProviderBase is RateProviderBase {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public immutable RATE_PRECISION;\r\n\r\n    constructor(\r\n        address[] memory _defaultRateAssets,\r\n        address[] memory _specialAssets,\r\n        uint8[] memory _specialAssetDecimals,\r\n        uint256 _ratePrecision\r\n    ) public RateProviderBase(_specialAssets, _specialAssetDecimals) {\r\n        RATE_PRECISION = _ratePrecision;\r\n\r\n        for (uint256 i = 0; i < _defaultRateAssets.length; i++) {\r\n            for (uint256 j = i + 1; j < _defaultRateAssets.length; j++) {\r\n                assetToAssetRate[_defaultRateAssets[i]][_defaultRateAssets[j]] =\r\n                    10**_ratePrecision;\r\n                assetToAssetRate[_defaultRateAssets[j]][_defaultRateAssets[i]] =\r\n                    10**_ratePrecision;\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: move to main contracts' utils for use with prices\r\n    function __calcDenormalizedQuoteAssetAmount(\r\n        uint256 _baseAssetDecimals,\r\n        uint256 _baseAssetAmount,\r\n        uint256 _quoteAssetDecimals,\r\n        uint256 _rate\r\n    ) internal view returns (uint256) {\r\n        return\r\n            _rate.mul(_baseAssetAmount).mul(10**_quoteAssetDecimals).div(\r\n                10**(RATE_PRECISION.add(_baseAssetDecimals))\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/utils/RateProviderBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./EthConstantMixin.sol\";\r\n\r\nabstract contract RateProviderBase is EthConstantMixin {\r\n    mapping(address => mapping(address => uint256)) public assetToAssetRate;\r\n\r\n    // Handles non-ERC20 compliant assets like ETH and USD\r\n    mapping(address => uint8) public specialAssetToDecimals;\r\n\r\n    constructor(address[] memory _specialAssets, uint8[] memory _specialAssetDecimals) public {\r\n        require(\r\n            _specialAssets.length == _specialAssetDecimals.length,\r\n            \"constructor: _specialAssets and _specialAssetDecimals are uneven lengths\"\r\n        );\r\n        for (uint256 i = 0; i < _specialAssets.length; i++) {\r\n            specialAssetToDecimals[_specialAssets[i]] = _specialAssetDecimals[i];\r\n        }\r\n\r\n        specialAssetToDecimals[ETH_ADDRESS] = 18;\r\n    }\r\n\r\n    function __getDecimalsForAsset(address _asset) internal view returns (uint256) {\r\n        uint256 decimals = specialAssetToDecimals[_asset];\r\n        if (decimals == 0) {\r\n            decimals = uint256(ERC20(_asset).decimals());\r\n        }\r\n\r\n        return decimals;\r\n    }\r\n\r\n    function __getRate(address _baseAsset, address _quoteAsset)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return assetToAssetRate[_baseAsset][_quoteAsset];\r\n    }\r\n\r\n    function setRates(\r\n        address[] calldata _baseAssets,\r\n        address[] calldata _quoteAssets,\r\n        uint256[] calldata _rates\r\n    ) external {\r\n        require(\r\n            _baseAssets.length == _quoteAssets.length,\r\n            \"setRates: _baseAssets and _quoteAssets are uneven lengths\"\r\n        );\r\n        require(\r\n            _baseAssets.length == _rates.length,\r\n            \"setRates: _baseAssets and _rates are uneven lengths\"\r\n        );\r\n        for (uint256 i = 0; i < _baseAssets.length; i++) {\r\n            assetToAssetRate[_baseAssets[i]][_quoteAssets[i]] = _rates[i];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/utils/AssetUnitCacheMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/// @title AssetUnitCacheMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin to store a cache of asset units\r\nabstract contract AssetUnitCacheMixin {\r\n    event AssetUnitCached(address indexed asset, uint256 prevUnit, uint256 nextUnit);\r\n\r\n    mapping(address => uint256) private assetToUnit;\r\n\r\n    /// @notice Caches the decimal-relative unit for a given asset\r\n    /// @param _asset The asset for which to cache the decimal-relative unit\r\n    /// @dev Callable by any account\r\n    function cacheAssetUnit(address _asset) public {\r\n        uint256 prevUnit = getCachedUnitForAsset(_asset);\r\n        uint256 nextUnit = 10**uint256(ERC20(_asset).decimals());\r\n        if (nextUnit != prevUnit) {\r\n            assetToUnit[_asset] = nextUnit;\r\n            emit AssetUnitCached(_asset, prevUnit, nextUnit);\r\n        }\r\n    }\r\n\r\n    /// @notice Caches the decimal-relative units for multiple given assets\r\n    /// @param _assets The assets for which to cache the decimal-relative units\r\n    /// @dev Callable by any account\r\n    function cacheAssetUnits(address[] memory _assets) public {\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            cacheAssetUnit(_assets[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the cached decimal-relative unit for a given asset\r\n    /// @param _asset The asset for which to get the cached decimal-relative unit\r\n    /// @return unit_ The cached decimal-relative unit\r\n    function getCachedUnitForAsset(address _asset) public view returns (uint256 unit_) {\r\n        return assetToUnit[_asset];\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/SinglePeggedDerivativePriceFeedBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../IDerivativePriceFeed.sol\";\r\n\r\n/// @title SinglePeggedDerivativePriceFeedBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price feed base for any single derivative that is pegged 1:1 to its underlying\r\nabstract contract SinglePeggedDerivativePriceFeedBase is IDerivativePriceFeed {\r\n    address private immutable DERIVATIVE;\r\n    address private immutable UNDERLYING;\r\n\r\n    constructor(address _derivative, address _underlying) public {\r\n        require(\r\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\r\n            \"constructor: Unequal decimals\"\r\n        );\r\n\r\n        DERIVATIVE = _derivative;\r\n        UNDERLYING = _underlying;\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        require(isSupportedAsset(_derivative), \"calcUnderlyingValues: Not a supported derivative\");\r\n\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = UNDERLYING;\r\n        underlyingAmounts_ = new uint256[](1);\r\n        underlyingAmounts_[0] = _derivativeAmount;\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return _asset == DERIVATIVE;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `DERIVATIVE` variable value\r\n    /// @return derivative_ The `DERIVATIVE` variable value\r\n    function getDerivative() external view returns (address derivative_) {\r\n        return DERIVATIVE;\r\n    }\r\n\r\n    /// @notice Gets the `UNDERLYING` variable value\r\n    /// @return underlying_ The `UNDERLYING` variable value\r\n    function getUnderlying() external view returns (address underlying_) {\r\n        return UNDERLYING;\r\n    }\r\n}\r\n"
    },
    "contracts/test/TestSinglePeggedDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/SinglePeggedDerivativePriceFeedBase.sol\";\r\n\r\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A test implementation of SinglePeggedDerivativePriceFeedBase\r\ncontract TestSinglePeggedDerivativePriceFeed is SinglePeggedDerivativePriceFeedBase {\r\n    constructor(address _derivative, address _underlying)\r\n        public\r\n        SinglePeggedDerivativePriceFeedBase(_derivative, _underlying)\r\n    {}\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/StakehoundEthPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./utils/SinglePeggedDerivativePriceFeedBase.sol\";\r\n\r\n/// @title StakehoundEthPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Stakehound stETH, which maps 1:1 with ETH\r\ncontract StakehoundEthPriceFeed is SinglePeggedDerivativePriceFeedBase {\r\n    constructor(address _steth, address _weth)\r\n        public\r\n        SinglePeggedDerivativePriceFeedBase(_steth, _weth)\r\n    {}\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/LidoStethPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./utils/SinglePeggedDerivativePriceFeedBase.sol\";\r\n\r\n/// @title LidoStethPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Lido stETH, which maps 1:1 with ETH (https://lido.fi/)\r\ncontract LidoStethPriceFeed is SinglePeggedDerivativePriceFeedBase {\r\n    constructor(address _steth, address _weth)\r\n        public\r\n        SinglePeggedDerivativePriceFeedBase(_steth, _weth)\r\n    {}\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/CurvePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../../../../interfaces/ICurveAddressProvider.sol\";\r\nimport \"../../../../interfaces/ICurveLiquidityGaugeToken.sol\";\r\nimport \"../../../../interfaces/ICurveLiquidityPool.sol\";\r\nimport \"../../../../interfaces/ICurveRegistry.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title CurvePriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price feed for Curve pool tokens\r\ncontract CurvePriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\r\n    using SafeMath for uint256;\r\n\r\n    event DerivativeAdded(\r\n        address indexed derivative,\r\n        address indexed pool,\r\n        address indexed invariantProxyAsset,\r\n        uint256 invariantProxyAssetDecimals\r\n    );\r\n\r\n    event DerivativeRemoved(address indexed derivative);\r\n\r\n    // Both pool tokens and liquidity gauge tokens are treated the same for pricing purposes.\r\n    // We take one asset as representative of the pool's invariant, e.g., WETH for ETH-based pools.\r\n    struct DerivativeInfo {\r\n        address pool;\r\n        address invariantProxyAsset;\r\n        uint256 invariantProxyAssetDecimals;\r\n    }\r\n\r\n    uint256 private constant VIRTUAL_PRICE_UNIT = 10**18;\r\n\r\n    address private immutable ADDRESS_PROVIDER;\r\n\r\n    mapping(address => DerivativeInfo) private derivativeToInfo;\r\n\r\n    constructor(address _fundDeployer, address _addressProvider)\r\n        public\r\n        FundDeployerOwnerMixin(_fundDeployer)\r\n    {\r\n        ADDRESS_PROVIDER = _addressProvider;\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        public\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        DerivativeInfo memory derivativeInfo = derivativeToInfo[_derivative];\r\n        require(\r\n            derivativeInfo.pool != address(0),\r\n            \"calcUnderlyingValues: _derivative is not supported\"\r\n        );\r\n\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = derivativeInfo.invariantProxyAsset;\r\n\r\n        underlyingAmounts_ = new uint256[](1);\r\n        if (derivativeInfo.invariantProxyAssetDecimals == 18) {\r\n            underlyingAmounts_[0] = _derivativeAmount\r\n                .mul(ICurveLiquidityPool(derivativeInfo.pool).get_virtual_price())\r\n                .div(VIRTUAL_PRICE_UNIT);\r\n        } else {\r\n            underlyingAmounts_[0] = _derivativeAmount\r\n                .mul(ICurveLiquidityPool(derivativeInfo.pool).get_virtual_price())\r\n                .mul(10**derivativeInfo.invariantProxyAssetDecimals)\r\n                .div(VIRTUAL_PRICE_UNIT)\r\n                .div(VIRTUAL_PRICE_UNIT);\r\n        }\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return derivativeToInfo[_asset].pool != address(0);\r\n    }\r\n\r\n    //////////////////////////\r\n    // DERIVATIVES REGISTRY //\r\n    //////////////////////////\r\n\r\n    /// @notice Adds Curve LP and/or liquidity gauge tokens to the price feed\r\n    /// @param _derivatives Curve LP and/or liquidity gauge tokens to add\r\n    /// @param _invariantProxyAssets The ordered assets that act as proxies to the pool invariants,\r\n    /// corresponding to each item in _derivatives, e.g., WETH for ETH-based pools\r\n    function addDerivatives(\r\n        address[] calldata _derivatives,\r\n        address[] calldata _invariantProxyAssets\r\n    ) external onlyFundDeployerOwner {\r\n        require(_derivatives.length > 0, \"addDerivatives: Empty _derivatives\");\r\n        require(\r\n            _derivatives.length == _invariantProxyAssets.length,\r\n            \"addDerivatives: Unequal arrays\"\r\n        );\r\n\r\n        ICurveRegistry curveRegistryContract = ICurveRegistry(\r\n            ICurveAddressProvider(ADDRESS_PROVIDER).get_registry()\r\n        );\r\n\r\n        for (uint256 i; i < _derivatives.length; i++) {\r\n            require(_derivatives[i] != address(0), \"addDerivatives: Empty derivative\");\r\n            require(\r\n                _invariantProxyAssets[i] != address(0),\r\n                \"addDerivatives: Empty invariantProxyAsset\"\r\n            );\r\n            require(!isSupportedAsset(_derivatives[i]), \"addDerivatives: Value already set\");\r\n\r\n            // First, try assuming that the derivative is an LP token\r\n            address pool = curveRegistryContract.get_pool_from_lp_token(_derivatives[i]);\r\n\r\n            // If the derivative is not a valid LP token, try to treat it as a liquidity gauge token\r\n            if (pool == address(0)) {\r\n                // We cannot confirm whether a liquidity gauge token is a valid token\r\n                // for a particular liquidity gauge, due to some pools using\r\n                // old liquidity gauge contracts that did not incorporate a token\r\n                pool = curveRegistryContract.get_pool_from_lp_token(\r\n                    ICurveLiquidityGaugeToken(_derivatives[i]).lp_token()\r\n                );\r\n\r\n                // Likely unreachable as above calls will revert on Curve, but doesn't hurt\r\n                require(\r\n                    pool != address(0),\r\n                    \"addDerivatives: Not a valid LP token or liquidity gauge token\"\r\n                );\r\n            }\r\n\r\n            uint256 invariantProxyAssetDecimals = ERC20(_invariantProxyAssets[i]).decimals();\r\n            derivativeToInfo[_derivatives[i]] = DerivativeInfo({\r\n                pool: pool,\r\n                invariantProxyAsset: _invariantProxyAssets[i],\r\n                invariantProxyAssetDecimals: invariantProxyAssetDecimals\r\n            });\r\n\r\n            // Confirm that a non-zero price can be returned for the registered derivative\r\n            (, uint256[] memory underlyingAmounts) = calcUnderlyingValues(\r\n                _derivatives[i],\r\n                1 ether\r\n            );\r\n            require(underlyingAmounts[0] > 0, \"addDerivatives: could not calculate valid price\");\r\n\r\n            emit DerivativeAdded(\r\n                _derivatives[i],\r\n                pool,\r\n                _invariantProxyAssets[i],\r\n                invariantProxyAssetDecimals\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Removes Curve LP and/or liquidity gauge tokens from the price feed\r\n    /// @param _derivatives Curve LP and/or liquidity gauge tokens to add\r\n    function removeDerivatives(address[] calldata _derivatives) external onlyFundDeployerOwner {\r\n        require(_derivatives.length > 0, \"removeDerivatives: Empty _derivatives\");\r\n        for (uint256 i; i < _derivatives.length; i++) {\r\n            require(_derivatives[i] != address(0), \"removeDerivatives: Empty derivative\");\r\n            require(isSupportedAsset(_derivatives[i]), \"removeDerivatives: Value is not set\");\r\n\r\n            delete derivativeToInfo[_derivatives[i]];\r\n\r\n            emit DerivativeRemoved(_derivatives[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `ADDRESS_PROVIDER` variable\r\n    /// @return addressProvider_ The `ADDRESS_PROVIDER` variable value\r\n    function getAddressProvider() external view returns (address addressProvider_) {\r\n        return ADDRESS_PROVIDER;\r\n    }\r\n\r\n    /// @notice Gets the `DerivativeInfo` for a given derivative\r\n    /// @param _derivative The derivative for which to get the `DerivativeInfo`\r\n    /// @return derivativeInfo_ The `DerivativeInfo` value\r\n    function getDerivativeInfo(address _derivative)\r\n        external\r\n        view\r\n        returns (DerivativeInfo memory derivativeInfo_)\r\n    {\r\n        return derivativeToInfo[_derivative];\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveAddressProvider interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveAddressProvider {\r\n    function get_address(uint256) external view returns (address);\r\n\r\n    function get_registry() external view returns (address);\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveLiquidityGaugeToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveLiquidityGaugeToken interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Common interface functions for all Curve liquidity gauge token contracts\r\ninterface ICurveLiquidityGaugeToken {\r\n    function lp_token() external view returns (address);\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveLiquidityPool interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveLiquidityPool {\r\n    function coins(uint256) external view returns (address);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveRegistry interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveRegistry {\r\n    function get_gauges(address) external view returns (address[10] memory, int128[10] memory);\r\n\r\n    function get_lp_token(address) external view returns (address);\r\n\r\n    function get_pool_from_lp_token(address) external view returns (address);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../../../interfaces/ICurveAddressProvider.sol\";\r\nimport \"../../../../interfaces/ICurveSwapsERC20.sol\";\r\nimport \"../../../../interfaces/ICurveSwapsEther.sol\";\r\nimport \"../../../../interfaces/IWETH.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title CurveExchangeAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for swapping assets on Curve <https://www.curve.fi/>\r\ncontract CurveExchangeAdapter is AdapterBase {\r\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    address private immutable ADDRESS_PROVIDER;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _addressProvider,\r\n        address _wethToken\r\n    ) public AdapterBase(_integrationManager) {\r\n        ADDRESS_PROVIDER = _addressProvider;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @dev Needed to receive ETH from swap and to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"CURVE_EXCHANGE\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForMethod: _selector invalid\");\r\n        (\r\n            address pool,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        require(pool != address(0), \"parseAssetsForMethod: No pool address provided\");\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = outgoingAsset;\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingAssetAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Trades assets on Curve\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    function takeOrder(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (\r\n            address pool,\r\n            address outgoingAsset,\r\n            uint256 outgoingAssetAmount,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        address swaps = ICurveAddressProvider(ADDRESS_PROVIDER).get_address(2);\r\n\r\n        __takeOrder(\r\n            _vaultProxy,\r\n            swaps,\r\n            pool,\r\n            outgoingAsset,\r\n            outgoingAssetAmount,\r\n            incomingAsset,\r\n            minIncomingAssetAmount\r\n        );\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the take order encoded call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address pool_,\r\n            address outgoingAsset_,\r\n            uint256 outgoingAssetAmount_,\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, address, uint256, address, uint256));\r\n    }\r\n\r\n    /// @dev Helper to execute takeOrder. Avoids stack-too-deep error.\r\n    function __takeOrder(\r\n        address _vaultProxy,\r\n        address _swaps,\r\n        address _pool,\r\n        address _outgoingAsset,\r\n        uint256 _outgoingAssetAmount,\r\n        address _incomingAsset,\r\n        uint256 _minIncomingAssetAmount\r\n    ) private {\r\n        if (_outgoingAsset == WETH_TOKEN) {\r\n            IWETH(WETH_TOKEN).withdraw(_outgoingAssetAmount);\r\n\r\n            ICurveSwapsEther(_swaps).exchange{value: _outgoingAssetAmount}(\r\n                _pool,\r\n                ETH_ADDRESS,\r\n                _incomingAsset,\r\n                _outgoingAssetAmount,\r\n                _minIncomingAssetAmount,\r\n                _vaultProxy\r\n            );\r\n        } else if (_incomingAsset == WETH_TOKEN) {\r\n            __approveMaxAsNeeded(_outgoingAsset, _swaps, _outgoingAssetAmount);\r\n\r\n            ICurveSwapsERC20(_swaps).exchange(\r\n                _pool,\r\n                _outgoingAsset,\r\n                ETH_ADDRESS,\r\n                _outgoingAssetAmount,\r\n                _minIncomingAssetAmount,\r\n                address(this)\r\n            );\r\n\r\n            // wrap received ETH and send back to the vault\r\n            uint256 receivedAmount = payable(address(this)).balance;\r\n            IWETH(payable(WETH_TOKEN)).deposit{value: receivedAmount}();\r\n            ERC20(WETH_TOKEN).safeTransfer(_vaultProxy, receivedAmount);\r\n        } else {\r\n            __approveMaxAsNeeded(_outgoingAsset, _swaps, _outgoingAssetAmount);\r\n\r\n            ICurveSwapsERC20(_swaps).exchange(\r\n                _pool,\r\n                _outgoingAsset,\r\n                _incomingAsset,\r\n                _outgoingAssetAmount,\r\n                _minIncomingAssetAmount,\r\n                _vaultProxy\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `ADDRESS_PROVIDER` variable\r\n    /// @return addressProvider_ The `ADDRESS_PROVIDER` variable value\r\n    function getAddressProvider() external view returns (address addressProvider_) {\r\n        return ADDRESS_PROVIDER;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveSwapsERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveSwapsERC20 Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveSwapsERC20 {\r\n    function exchange(\r\n        address,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveSwapsEther.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveSwapsEther Interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveSwapsEther {\r\n    function exchange(\r\n        address,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) external payable returns (uint256);\r\n}\r\n"
    },
    "contracts/test/TestSingleUnderlyingDerivativeRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\r\n\r\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A test implementation of SingleUnderlyingDerivativeRegistryMixin\r\ncontract TestSingleUnderlyingDerivativeRegistry is SingleUnderlyingDerivativeRegistryMixin {\r\n    constructor(address _dispatcher) public SingleUnderlyingDerivativeRegistryMixin(_dispatcher) {}\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/PeggedDerivativesPriceFeedBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../../IDerivativePriceFeed.sol\";\r\nimport \"./SingleUnderlyingDerivativeRegistryMixin.sol\";\r\n\r\n/// @title PeggedDerivativesPriceFeedBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price feed base for multiple derivatives that are pegged 1:1 to their underlyings,\r\n/// and have the same decimals as their underlying\r\nabstract contract PeggedDerivativesPriceFeedBase is\r\n    IDerivativePriceFeed,\r\n    SingleUnderlyingDerivativeRegistryMixin\r\n{\r\n    constructor(address _fundDeployer)\r\n        public\r\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\r\n    {}\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        address underlying = getUnderlyingForDerivative(_derivative);\r\n        require(underlying != address(0), \"calcUnderlyingValues: Not a supported derivative\");\r\n\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = underlying;\r\n\r\n        underlyingAmounts_ = new uint256[](1);\r\n        underlyingAmounts_[0] = _derivativeAmount;\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\r\n        return getUnderlyingForDerivative(_asset) != address(0);\r\n    }\r\n\r\n    /// @dev Provides validation that the derivative and underlying have the same decimals.\r\n    /// Can be overrode by the inheriting price feed using super() to implement further validation.\r\n    function __validateDerivative(address _derivative, address _underlying)\r\n        internal\r\n        virtual\r\n        override\r\n    {\r\n        require(\r\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\r\n            \"__validateDerivative: Unequal decimals\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/test/TestPeggedDerivativesPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/PeggedDerivativesPriceFeedBase.sol\";\r\n\r\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A test implementation of PeggedDerivativesPriceFeedBase\r\ncontract TestPeggedDerivativesPriceFeed is PeggedDerivativesPriceFeedBase {\r\n    constructor(address _dispatcher) public PeggedDerivativesPriceFeedBase(_dispatcher) {}\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/AavePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../interfaces/IAaveProtocolDataProvider.sol\";\r\nimport \"./utils/PeggedDerivativesPriceFeedBase.sol\";\r\n\r\n/// @title AavePriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Aave\r\ncontract AavePriceFeed is PeggedDerivativesPriceFeedBase {\r\n    address private immutable PROTOCOL_DATA_PROVIDER;\r\n\r\n    constructor(address _fundDeployer, address _protocolDataProvider)\r\n        public\r\n        PeggedDerivativesPriceFeedBase(_fundDeployer)\r\n    {\r\n        PROTOCOL_DATA_PROVIDER = _protocolDataProvider;\r\n    }\r\n\r\n    function __validateDerivative(address _derivative, address _underlying) internal override {\r\n        super.__validateDerivative(_derivative, _underlying);\r\n\r\n        (address aTokenAddress, , ) = IAaveProtocolDataProvider(PROTOCOL_DATA_PROVIDER)\r\n            .getReserveTokensAddresses(_underlying);\r\n\r\n        require(\r\n            aTokenAddress == _derivative,\r\n            \"__validateDerivative: Invalid aToken or token provided\"\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `PROTOCOL_DATA_PROVIDER` variable value\r\n    /// @return protocolDataProvider_ The `PROTOCOL_DATA_PROVIDER` variable value\r\n    function getProtocolDataProvider() external view returns (address protocolDataProvider_) {\r\n        return PROTOCOL_DATA_PROVIDER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IAaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IAaveProtocolDataProvider interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAaveProtocolDataProvider {\r\n    function getReserveTokensAddresses(address)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address,\r\n            address\r\n        );\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/AaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/AavePriceFeed.sol\";\r\nimport \"../../../../interfaces/IAaveLendingPool.sol\";\r\nimport \"../../../../interfaces/IAaveLendingPoolAddressProvider.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title AaveAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for Aave Lending <https://aave.com/>\r\n/// @dev When lending and redeeming, a small `ROUNDING_BUFFER` is subtracted from the expected\r\n/// `aToken` values. This is a workaround for problematic quirks in `aToken` balance rounding\r\n/// (due to RayMath and rebasing logic), which sometimes leads to tx failures due to strict\r\n/// validation in the IntegrationManager of the incoming and outgoing asset amounts used in the tx.\r\n/// Due to this workaround, an `aToken` value <= the `ROUNDING_BUFFER` is not usable in this adapter,\r\n/// which is fine because those values would not make sense (gas-wise) to lend or redeem.\r\ncontract AaveAdapter is AdapterBase2 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant ROUNDING_BUFFER = 2;\r\n    uint16 private constant REFERRAL_CODE = 158;\r\n\r\n    address private immutable AAVE_PRICE_FEED;\r\n    address private immutable LENDING_POOL_ADDRESS_PROVIDER;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _lendingPoolAddressProvider,\r\n        address _aavePriceFeed\r\n    ) public AdapterBase2(_integrationManager) {\r\n        LENDING_POOL_ADDRESS_PROVIDER = _lendingPoolAddressProvider;\r\n        AAVE_PRICE_FEED = _aavePriceFeed;\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"AAVE\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == LEND_SELECTOR) {\r\n            (address aToken, uint256 amount) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n            // Prevent from invalid token/aToken combination\r\n            address token = AavePriceFeed(AAVE_PRICE_FEED).getUnderlyingForDerivative(aToken);\r\n            require(token != address(0), \"parseAssetsForMethod: Unsupported aToken\");\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = token;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = amount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = aToken;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            // See file @dev tag explanation of `ROUNDING_BUFFER`\r\n            minIncomingAssetAmounts_[0] = amount.sub(ROUNDING_BUFFER);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            (address aToken, uint256 amount) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n            // Prevent from invalid token/aToken combination\r\n            address token = AavePriceFeed(AAVE_PRICE_FEED).getUnderlyingForDerivative(aToken);\r\n            require(token != address(0), \"parseAssetsForMethod: Unsupported aToken\");\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = aToken;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = amount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = token;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            // See file @dev tag explanation of `ROUNDING_BUFFER`.\r\n            // Since `ROUNDING_BUFFER` is subtracted from spendAssetAmounts_[0]\r\n            // in redeem(), we must also subtract it from the min incoming amount.\r\n            // The extra `1` added to the buffer is just extra cautious.\r\n            minIncomingAssetAmounts_[0] = amount.sub(ROUNDING_BUFFER + 1);\r\n        } else {\r\n            revert(\"parseAssetsForMethod: _selector invalid\");\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Lends an amount of a token to AAVE\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    ) external onlyIntegrationManager {\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        address lendingPoolAddress = IAaveLendingPoolAddressProvider(LENDING_POOL_ADDRESS_PROVIDER)\r\n            .getLendingPool();\r\n\r\n        __approveMaxAsNeeded(spendAssets[0], lendingPoolAddress, spendAssetAmounts[0]);\r\n\r\n        IAaveLendingPool(lendingPoolAddress).deposit(\r\n            spendAssets[0],\r\n            spendAssetAmounts[0],\r\n            _vaultProxy,\r\n            REFERRAL_CODE\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems an amount of aTokens from AAVE\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionSpendAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            ,\r\n            address[] memory spendAssets,\r\n            uint256[] memory spendAssetAmounts,\r\n            address[] memory incomingAssets\r\n        ) = __decodeEncodedAssetTransferArgs(_encodedAssetTransferArgs);\r\n\r\n        address lendingPoolAddress = IAaveLendingPoolAddressProvider(LENDING_POOL_ADDRESS_PROVIDER)\r\n            .getLendingPool();\r\n\r\n        // See file @dev tag explanation of `ROUNDING_BUFFER`.\r\n        // The surplus amount of the spendAsset `aToken` is sent back to the _vaultProxy\r\n        // via `postActionSpendAssetsTransferHandler` to ensure that the IntegrationManager\r\n        // validation of spendAssetAmounts passes.\r\n        uint256 actualSpendAmount = spendAssetAmounts[0].sub(ROUNDING_BUFFER);\r\n\r\n        __approveMaxAsNeeded(spendAssets[0], lendingPoolAddress, actualSpendAmount);\r\n\r\n        IAaveLendingPool(lendingPoolAddress).withdraw(\r\n            incomingAssets[0],\r\n            actualSpendAmount,\r\n            _vaultProxy\r\n        );\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode callArgs for lend and redeem\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address aToken, uint256 amount)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `AAVE_PRICE_FEED` variable\r\n    /// @return aavePriceFeed_ The `AAVE_PRICE_FEED` variable value\r\n    function getAavePriceFeed() external view returns (address aavePriceFeed_) {\r\n        return AAVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `LENDING_POOL_ADDRESS_PROVIDER` variable\r\n    /// @return lendingPoolAddressProvider_ The `LENDING_POOL_ADDRESS_PROVIDER` variable value\r\n    function getLendingPoolAddressProvider()\r\n        external\r\n        view\r\n        returns (address lendingPoolAddressProvider_)\r\n    {\r\n        return LENDING_POOL_ADDRESS_PROVIDER;\r\n    }\r\n\r\n    /// @notice Gets the `REFERRAL_CODE` variable\r\n    /// @return referralCode_ The `REFERRAL_CODE` variable value\r\n    function getReferralCode() external pure returns (uint16 referralCode_) {\r\n        return REFERRAL_CODE;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IAaveLendingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IAaveLendingPool interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAaveLendingPool {\r\n    function deposit(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint16\r\n    ) external;\r\n\r\n    function withdraw(\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/interfaces/IAaveLendingPoolAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IAaveLendingPoolAddressProvider interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAaveLendingPoolAddressProvider {\r\n    function getLendingPool() external view returns (address);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveStethLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../../interfaces/ICurveStableSwapSteth.sol\";\r\nimport \"../../../../../interfaces/IWETH.sol\";\r\n\r\n/// @title CurveStethLiquidityActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with the Curve steth pool's liquidity functions\r\n/// @dev Inheriting contract must have a receive() function\r\nabstract contract CurveStethLiquidityActionsMixin {\r\n    using SafeERC20 for ERC20;\r\n\r\n    int128 private constant CURVE_STETH_POOL_INDEX_ETH = 0;\r\n    int128 private constant CURVE_STETH_POOL_INDEX_STETH = 1;\r\n\r\n    address private immutable CURVE_STETH_LIQUIDITY_POOL;\r\n    address private immutable CURVE_STETH_LIQUIDITY_WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _pool,\r\n        address _stethToken,\r\n        address _wethToken\r\n    ) public {\r\n        CURVE_STETH_LIQUIDITY_POOL = _pool;\r\n        CURVE_STETH_LIQUIDITY_WETH_TOKEN = _wethToken;\r\n\r\n        // Pre-approve pool to use max of steth token\r\n        ERC20(_stethToken).safeApprove(_pool, type(uint256).max);\r\n    }\r\n\r\n    /// @dev Helper to add liquidity to the pool\r\n    function __curveStethLend(\r\n        uint256 _outgoingWethAmount,\r\n        uint256 _outgoingStethAmount,\r\n        uint256 _minIncomingLPTokenAmount\r\n    ) internal {\r\n        if (_outgoingWethAmount > 0) {\r\n            IWETH((CURVE_STETH_LIQUIDITY_WETH_TOKEN)).withdraw(_outgoingWethAmount);\r\n        }\r\n\r\n        ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).add_liquidity{\r\n            value: _outgoingWethAmount\r\n        }([_outgoingWethAmount, _outgoingStethAmount], _minIncomingLPTokenAmount);\r\n    }\r\n\r\n    /// @dev Helper to remove liquidity from the pool.\r\n    // Assumes that if _redeemSingleAsset is true, then\r\n    // \"_minIncomingWethAmount > 0 XOR _minIncomingStethAmount > 0\" has already been validated.\r\n    function __curveStethRedeem(\r\n        uint256 _outgoingLPTokenAmount,\r\n        uint256 _minIncomingWethAmount,\r\n        uint256 _minIncomingStethAmount,\r\n        bool _redeemSingleAsset\r\n    ) internal {\r\n        if (_redeemSingleAsset) {\r\n            if (_minIncomingWethAmount > 0) {\r\n                ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_STETH_POOL_INDEX_ETH,\r\n                    _minIncomingWethAmount\r\n                );\r\n\r\n                IWETH(payable(CURVE_STETH_LIQUIDITY_WETH_TOKEN)).deposit{\r\n                    value: payable(address(this)).balance\r\n                }();\r\n            } else {\r\n                ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_STETH_POOL_INDEX_STETH,\r\n                    _minIncomingStethAmount\r\n                );\r\n            }\r\n        } else {\r\n            ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity(\r\n                _outgoingLPTokenAmount,\r\n                [_minIncomingWethAmount, _minIncomingStethAmount]\r\n            );\r\n\r\n            IWETH(payable(CURVE_STETH_LIQUIDITY_WETH_TOKEN)).deposit{\r\n                value: payable(address(this)).balance\r\n            }();\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `CURVE_STETH_LIQUIDITY_POOL` variable\r\n    /// @return pool_ The `CURVE_STETH_LIQUIDITY_POOL` variable value\r\n    function getCurveStethLiquidityPool() public view returns (address pool_) {\r\n        return CURVE_STETH_LIQUIDITY_POOL;\r\n    }\r\n\r\n    /// @notice Gets the `CURVE_STETH_LIQUIDITY_WETH_TOKEN` variable\r\n    /// @return wethToken_ The `CURVE_STETH_LIQUIDITY_WETH_TOKEN` variable value\r\n    function getCurveStethLiquidityWethToken() public view returns (address wethToken_) {\r\n        return CURVE_STETH_LIQUIDITY_WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveStableSwapSteth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveStableSwapSteth interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveStableSwapSteth {\r\n    function add_liquidity(uint256[2] calldata, uint256) external payable returns (uint256);\r\n\r\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256,\r\n        int128,\r\n        uint256\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveSethLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../../interfaces/ICurveStableSwapSeth.sol\";\r\nimport \"../../../../../interfaces/IWETH.sol\";\r\n\r\n/// @title CurveSethLiquidityActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with the Curve seth pool's liquidity functions\r\n/// @dev Inheriting contract must have a receive() function\r\nabstract contract CurveSethLiquidityActionsMixin {\r\n    using SafeERC20 for ERC20;\r\n\r\n    int128 private constant CURVE_SETH_POOL_INDEX_ETH = 0;\r\n    int128 private constant CURVE_SETH_POOL_INDEX_SETH = 1;\r\n\r\n    address private immutable CURVE_SETH_LIQUIDITY_POOL;\r\n    address private immutable CURVE_SETH_LIQUIDITY_WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _pool,\r\n        address _sethToken,\r\n        address _wethToken\r\n    ) public {\r\n        CURVE_SETH_LIQUIDITY_POOL = _pool;\r\n        CURVE_SETH_LIQUIDITY_WETH_TOKEN = _wethToken;\r\n\r\n        // Pre-approve pool to use max of seth token\r\n        ERC20(_sethToken).safeApprove(_pool, type(uint256).max);\r\n    }\r\n\r\n    /// @dev Helper to add liquidity to the pool\r\n    function __curveSethLend(\r\n        uint256 _outgoingWethAmount,\r\n        uint256 _outgoingSethAmount,\r\n        uint256 _minIncomingLPTokenAmount\r\n    ) internal {\r\n        if (_outgoingWethAmount > 0) {\r\n            IWETH((CURVE_SETH_LIQUIDITY_WETH_TOKEN)).withdraw(_outgoingWethAmount);\r\n        }\r\n\r\n        ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).add_liquidity{value: _outgoingWethAmount}(\r\n            [_outgoingWethAmount, _outgoingSethAmount],\r\n            _minIncomingLPTokenAmount\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to remove liquidity from the pool.\r\n    // Assumes that if _redeemSingleAsset is true, then\r\n    // \"_minIncomingWethAmount > 0 XOR _minIncomingSethAmount > 0\" has already been validated.\r\n    function __curveSethRedeem(\r\n        uint256 _outgoingLPTokenAmount,\r\n        uint256 _minIncomingWethAmount,\r\n        uint256 _minIncomingSethAmount,\r\n        bool _redeemSingleAsset\r\n    ) internal {\r\n        if (_redeemSingleAsset) {\r\n            if (_minIncomingWethAmount > 0) {\r\n                ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_SETH_POOL_INDEX_ETH,\r\n                    _minIncomingWethAmount\r\n                );\r\n\r\n                IWETH(payable(CURVE_SETH_LIQUIDITY_WETH_TOKEN)).deposit{\r\n                    value: payable(address(this)).balance\r\n                }();\r\n            } else {\r\n                ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_SETH_POOL_INDEX_SETH,\r\n                    _minIncomingSethAmount\r\n                );\r\n            }\r\n        } else {\r\n            ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity(\r\n                _outgoingLPTokenAmount,\r\n                [_minIncomingWethAmount, _minIncomingSethAmount]\r\n            );\r\n\r\n            IWETH(payable(CURVE_SETH_LIQUIDITY_WETH_TOKEN)).deposit{\r\n                value: payable(address(this)).balance\r\n            }();\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `CURVE_SETH_LIQUIDITY_POOL` variable\r\n    /// @return pool_ The `CURVE_SETH_LIQUIDITY_POOL` variable value\r\n    function getCurveSethLiquidityPool() public view returns (address pool_) {\r\n        return CURVE_SETH_LIQUIDITY_POOL;\r\n    }\r\n\r\n    /// @notice Gets the `CURVE_SETH_LIQUIDITY_WETH_TOKEN` variable\r\n    /// @return wethToken_ The `CURVE_SETH_LIQUIDITY_WETH_TOKEN` variable value\r\n    function getCurveSethLiquidityWethToken() public view returns (address wethToken_) {\r\n        return CURVE_SETH_LIQUIDITY_WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveStableSwapSeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveStableSwapSeth interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveStableSwapSeth {\r\n    function add_liquidity(uint256[2] calldata, uint256) external payable returns (uint256);\r\n\r\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256,\r\n        int128,\r\n        uint256\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquiditySethAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\r\nimport \"../utils/actions/CurveSethLiquidityActionsMixin.sol\";\r\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title CurveLiquiditySethAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for liquidity provision in Curve's seth pool (https://www.curve.fi/seth)\r\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\r\n/// or claimRewardsAndReinvest(). Rationale:\r\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\r\n/// to enforce policy management or emit an event\r\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\r\n/// This adapter will need to be re-deployed if UniswapV2 low liquidity becomes\r\n/// a concern for rewards tokens when using claimRewardsAndReinvest().\r\ncontract CurveLiquiditySethAdapter is\r\n    AdapterBase2,\r\n    CurveGaugeV2RewardsHandlerBase,\r\n    CurveSethLiquidityActionsMixin,\r\n    UniswapV2ActionsMixin\r\n{\r\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\r\n    address private immutable LP_TOKEN;\r\n    address private immutable SETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _liquidityGaugeToken,\r\n        address _lpToken,\r\n        address _minter,\r\n        address _pool,\r\n        address _crvToken,\r\n        address _sethToken,\r\n        address _wethToken,\r\n        address _uniswapV2Router2\r\n    )\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\r\n        CurveSethLiquidityActionsMixin(_pool, _sethToken, _wethToken)\r\n        UniswapV2ActionsMixin(_uniswapV2Router2)\r\n    {\r\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\r\n        LP_TOKEN = _lpToken;\r\n        SETH_TOKEN = _sethToken;\r\n\r\n        // Max approve contracts to spend relevant tokens\r\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\r\n    }\r\n\r\n    /// @dev Needed to receive ETH from redemption and to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"CURVE_LIQUIDITY_SETH\";\r\n    }\r\n\r\n    /// @notice Approves assets from the vault to be used by this contract.\r\n    /// @dev No logic necessary. Exists only to grant adapter with necessary approvals from the vault,\r\n    /// which takes place in the IntegrationManager.\r\n    function approveAssets(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external {}\r\n\r\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    function claimRewards(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\r\n    }\r\n\r\n    /// @notice Claims rewards and then compounds the rewards tokens back into the staked LP token\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndReinvest(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            bool useFullBalances,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeClaimRewardsAndReinvestCallArgs(_encodedCallArgs);\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        // Swap all reward tokens to WETH via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            address(this),\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            getCurveSethLiquidityWethToken(),\r\n            address(0)\r\n        );\r\n\r\n        // Lend all received WETH for staked LP tokens\r\n        uint256 wethBalance = ERC20(getCurveSethLiquidityWethToken()).balanceOf(address(this));\r\n        if (wethBalance > 0) {\r\n            __curveSethLend(wethBalance, 0, minIncomingLiquidityGaugeTokenAmount);\r\n            __curveGaugeV2Stake(\r\n                LIQUIDITY_GAUGE_TOKEN,\r\n                LP_TOKEN,\r\n                ERC20(LP_TOKEN).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndSwap(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (bool useFullBalances, address incomingAsset, ) = __decodeClaimRewardsAndSwapCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        // Swap all reward tokens to the designated incomingAsset via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            _vaultProxy,\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            incomingAsset,\r\n            getCurveSethLiquidityWethToken()\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for seth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingSethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveSethLend(\r\n            outgoingWethAmount,\r\n            outgoingSethAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for seth LP tokens, then stakes the received LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lendAndStake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingSethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveSethLend(\r\n            outgoingWethAmount,\r\n            outgoingSethAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n        __curveGaugeV2Stake(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            LP_TOKEN,\r\n            ERC20(LP_TOKEN).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems seth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingSethAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveSethRedeem(\r\n            outgoingLpTokenAmount,\r\n            minIncomingWethAmount,\r\n            minIncomingSethAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /// @notice Stakes seth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function stake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Stake(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            LP_TOKEN,\r\n            __decodeStakeCallArgs(_encodedCallArgs)\r\n        );\r\n    }\r\n\r\n    /// @notice Unstakes seth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, __decodeUnstakeCallArgs(_encodedCallArgs));\r\n    }\r\n\r\n    /// @notice Unstakes seth LP tokens, then redeems them\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstakeAndRedeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingSethAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\r\n        __curveSethRedeem(\r\n            outgoingLiquidityGaugeTokenAmount,\r\n            minIncomingWethAmount,\r\n            minIncomingSethAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == APPROVE_ASSETS_SELECTOR) {\r\n            return __parseAssetsForApproveAssets(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_SELECTOR) {\r\n            return __parseAssetsForClaimRewards();\r\n        } else if (_selector == CLAIM_REWARDS_AND_REINVEST_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndReinvest(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_AND_SWAP_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndSwap(_encodedCallArgs);\r\n        } else if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\r\n            return __parseAssetsForLendAndStake(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        } else if (_selector == STAKE_SELECTOR) {\r\n            return __parseAssetsForStake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_SELECTOR) {\r\n            return __parseAssetsForUnstake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\r\n            return __parseAssetsForUnstakeAndRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during approveAssets() calls\r\n    function __parseAssetsForApproveAssets(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (spendAssets_, spendAssetAmounts_) = __decodeApproveAssetsCallArgs(_encodedCallArgs);\r\n        require(\r\n            spendAssets_.length == spendAssetAmounts_.length,\r\n            \"__parseAssetsForApproveAssets: Unequal arrays\"\r\n        );\r\n\r\n        // Validate that only rewards tokens are given allowances\r\n        address[] memory rewardsTokens = __curveGaugeV2GetRewardsTokensWithCrv(\r\n            LIQUIDITY_GAUGE_TOKEN\r\n        );\r\n        for (uint256 i; i < spendAssets_.length; i++) {\r\n            // Allow revoking approval for any asset\r\n            if (spendAssetAmounts_[i] > 0) {\r\n                require(\r\n                    rewardsTokens.contains(spendAssets_[i]),\r\n                    \"__parseAssetsForApproveAssets: Invalid reward token\"\r\n                );\r\n            }\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Approve,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewards() calls.\r\n    /// No action required, all values empty.\r\n    function __parseAssetsForClaimRewards()\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndReinvest() calls.\r\n    function __parseAssetsForClaimRewardsAndReinvest(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (, uint256 minIncomingLiquidityGaugeTokenAmount) = __decodeClaimRewardsAndReinvestCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndSwap() calls.\r\n    function __parseAssetsForClaimRewardsAndSwap(bytes calldata _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            ,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeClaimRewardsAndSwapCallArgs(_encodedCallArgs);\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingSethAmount,\r\n            uint256 minIncomingLpTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingWethAmount,\r\n            outgoingSethAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lendAndStake() calls\r\n    function __parseAssetsForLendAndStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingSethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingWethAmount,\r\n            outgoingSethAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingSethAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingWethAmount,\r\n            minIncomingSethAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during stake() calls\r\n    function __parseAssetsForStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstake() calls\r\n    function __parseAssetsForUnstake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstakeAndRedeem() calls\r\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingSethAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingWethAmount,\r\n            minIncomingSethAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\r\n    function __parseIncomingAssetsForRedemptionCalls(\r\n        uint256 _minIncomingWethAmount,\r\n        uint256 _minIncomingSethAmount,\r\n        bool _receiveSingleAsset\r\n    )\r\n        private\r\n        view\r\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\r\n    {\r\n        if (_receiveSingleAsset) {\r\n            incomingAssets_ = new address[](1);\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n\r\n            if (_minIncomingWethAmount == 0) {\r\n                require(\r\n                    _minIncomingSethAmount > 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\r\n                );\r\n                incomingAssets_[0] = SETH_TOKEN;\r\n                minIncomingAssetAmounts_[0] = _minIncomingSethAmount;\r\n            } else {\r\n                require(\r\n                    _minIncomingSethAmount == 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\r\n                );\r\n                incomingAssets_[0] = getCurveSethLiquidityWethToken();\r\n                minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\r\n            }\r\n        } else {\r\n            incomingAssets_ = new address[](2);\r\n            incomingAssets_[0] = getCurveSethLiquidityWethToken();\r\n            incomingAssets_[1] = SETH_TOKEN;\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](2);\r\n            minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\r\n            minIncomingAssetAmounts_[1] = _minIncomingSethAmount;\r\n        }\r\n\r\n        return (incomingAssets_, minIncomingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\r\n    function __parseSpendAssetsForLendingCalls(\r\n        uint256 _outgoingWethAmount,\r\n        uint256 _outgoingSethAmount\r\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\r\n        if (_outgoingWethAmount > 0 && _outgoingSethAmount > 0) {\r\n            spendAssets_ = new address[](2);\r\n            spendAssets_[0] = getCurveSethLiquidityWethToken();\r\n            spendAssets_[1] = SETH_TOKEN;\r\n\r\n            spendAssetAmounts_ = new uint256[](2);\r\n            spendAssetAmounts_[0] = _outgoingWethAmount;\r\n            spendAssetAmounts_[1] = _outgoingSethAmount;\r\n        } else if (_outgoingWethAmount > 0) {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = getCurveSethLiquidityWethToken();\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingWethAmount;\r\n        } else {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = SETH_TOKEN;\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingSethAmount;\r\n        }\r\n\r\n        return (spendAssets_, spendAssetAmounts_);\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode the encoded call arguments for approving asset allowances\r\n    function __decodeApproveAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address[] memory assets_, uint256[] memory amounts_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[], uint256[]));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards\r\n    function __decodeClaimRewardsAndReinvestCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (bool useFullBalances_, uint256 minIncomingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and swapping\r\n    function __decodeClaimRewardsAndSwapCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            bool useFullBalances_,\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, address, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingWethAmount_,\r\n            uint256 outgoingSethAmount_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for redeeming.\r\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\r\n    /// `minIncomingWethAmount_` and `minIncomingSethAmount_` must be >0\r\n    /// to indicate which asset is to be received.\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingAssetAmount_,\r\n            uint256 minIncomingWethAmount_,\r\n            uint256 minIncomingSethAmount_,\r\n            bool receiveSingleAsset_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for staking\r\n    function __decodeStakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLpTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for unstaking\r\n    function __decodeUnstakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\r\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\r\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\r\n        return LIQUIDITY_GAUGE_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `LP_TOKEN` variable\r\n    /// @return lpToken_ The `LP_TOKEN` variable value\r\n    function getLpToken() external view returns (address lpToken_) {\r\n        return LP_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `SETH_TOKEN` variable\r\n    /// @return sethToken_ The `SETH_TOKEN` variable value\r\n    function getSethToken() external view returns (address sethToken_) {\r\n        return SETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveGaugeV2RewardsHandlerBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/ICurveMinter.sol\";\r\nimport \"../../../../../utils/AddressArrayLib.sol\";\r\nimport \"./CurveGaugeV2ActionsMixin.sol\";\r\n\r\n/// @title CurveGaugeV2RewardsHandlerBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Base contract for handling claiming and reinvesting rewards for a Curve pool\r\n/// that uses the LiquidityGaugeV2 contract\r\nabstract contract CurveGaugeV2RewardsHandlerBase is CurveGaugeV2ActionsMixin {\r\n    using AddressArrayLib for address[];\r\n\r\n    address private immutable CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN;\r\n    address private immutable CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER;\r\n\r\n    constructor(address _minter, address _crvToken) public {\r\n        CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN = _crvToken;\r\n        CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER = _minter;\r\n    }\r\n\r\n    /// @dev Helper to claim all rewards (CRV and pool-specific).\r\n    /// Requires contract to be approved to use mint_for().\r\n    function __curveGaugeV2ClaimAllRewards(address _gauge, address _target) internal {\r\n        // Claim owed $CRV\r\n        ICurveMinter(CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER).mint_for(_gauge, _target);\r\n\r\n        // Claim owed pool-specific rewards\r\n        __curveGaugeV2ClaimRewards(_gauge, _target);\r\n    }\r\n\r\n    /// @dev Helper to claim all rewards, then pull either the newly claimed balances only,\r\n    /// or full vault balances into the current contract\r\n    function __curveGaugeV2ClaimRewardsAndPullBalances(\r\n        address _gauge,\r\n        address _target,\r\n        bool _useFullBalances\r\n    )\r\n        internal\r\n        returns (address[] memory rewardsTokens_, uint256[] memory rewardsTokenAmountsPulled_)\r\n    {\r\n        if (_useFullBalances) {\r\n            return __curveGaugeV2ClaimRewardsAndPullFullBalances(_gauge, _target);\r\n        }\r\n\r\n        return __curveGaugeV2ClaimRewardsAndPullClaimedBalances(_gauge, _target);\r\n    }\r\n\r\n    /// @dev Helper to claim all rewards, then pull only the newly claimed balances\r\n    /// of all rewards tokens into the current contract\r\n    function __curveGaugeV2ClaimRewardsAndPullClaimedBalances(address _gauge, address _target)\r\n        internal\r\n        returns (address[] memory rewardsTokens_, uint256[] memory rewardsTokenAmountsPulled_)\r\n    {\r\n        rewardsTokens_ = __curveGaugeV2GetRewardsTokensWithCrv(_gauge);\r\n\r\n        uint256[] memory rewardsTokenPreClaimBalances = new uint256[](rewardsTokens_.length);\r\n        for (uint256 i; i < rewardsTokens_.length; i++) {\r\n            rewardsTokenPreClaimBalances[i] = ERC20(rewardsTokens_[i]).balanceOf(_target);\r\n        }\r\n\r\n        __curveGaugeV2ClaimAllRewards(_gauge, _target);\r\n\r\n        rewardsTokenAmountsPulled_ = __pullPartialAssetBalances(\r\n            _target,\r\n            rewardsTokens_,\r\n            rewardsTokenPreClaimBalances\r\n        );\r\n\r\n        return (rewardsTokens_, rewardsTokenAmountsPulled_);\r\n    }\r\n\r\n    /// @dev Helper to claim all rewards, then pull the full balances of all rewards tokens\r\n    /// in the target into the current contract\r\n    function __curveGaugeV2ClaimRewardsAndPullFullBalances(address _gauge, address _target)\r\n        internal\r\n        returns (address[] memory rewardsTokens_, uint256[] memory rewardsTokenAmountsPulled_)\r\n    {\r\n        __curveGaugeV2ClaimAllRewards(_gauge, _target);\r\n\r\n        rewardsTokens_ = __curveGaugeV2GetRewardsTokensWithCrv(_gauge);\r\n        rewardsTokenAmountsPulled_ = __pullFullAssetBalances(_target, rewardsTokens_);\r\n\r\n        return (rewardsTokens_, rewardsTokenAmountsPulled_);\r\n    }\r\n\r\n    /// @dev Helper to get all rewards tokens for staking LP tokens\r\n    function __curveGaugeV2GetRewardsTokensWithCrv(address _gauge)\r\n        internal\r\n        view\r\n        returns (address[] memory rewardsTokens_)\r\n    {\r\n        return\r\n            __curveGaugeV2GetRewardsTokens(_gauge).addUniqueItem(\r\n                CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN\r\n            );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN` variable\r\n    /// @return crvToken_ The `CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN` variable value\r\n    function getCurveGaugeV2RewardsHandlerCrvToken() public view returns (address crvToken_) {\r\n        return CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER` variable\r\n    /// @return minter_ The `CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER` variable value\r\n    function getCurveGaugeV2RewardsHandlerMinter() public view returns (address minter_) {\r\n        return CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveMinter interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveMinter {\r\n    function mint_for(address, address) external;\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveGaugeV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../../interfaces/ICurveLiquidityGaugeV2.sol\";\r\nimport \"../../../../../utils/AssetHelpers.sol\";\r\n\r\n/// @title CurveGaugeV2ActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with any Curve LiquidityGaugeV2 contract\r\nabstract contract CurveGaugeV2ActionsMixin is AssetHelpers {\r\n    uint256 private constant CURVE_GAUGE_V2_MAX_REWARDS = 8;\r\n\r\n    /// @dev Helper to claim pool-specific rewards\r\n    function __curveGaugeV2ClaimRewards(address _gauge, address _target) internal {\r\n        ICurveLiquidityGaugeV2(_gauge).claim_rewards(_target);\r\n    }\r\n\r\n    /// @dev Helper to get list of pool-specific rewards tokens\r\n    function __curveGaugeV2GetRewardsTokens(address _gauge)\r\n        internal\r\n        view\r\n        returns (address[] memory rewardsTokens_)\r\n    {\r\n        address[] memory lpRewardsTokensWithEmpties = new address[](CURVE_GAUGE_V2_MAX_REWARDS);\r\n        uint256 rewardsTokensCount;\r\n        for (uint256 i; i < CURVE_GAUGE_V2_MAX_REWARDS; i++) {\r\n            address rewardToken = ICurveLiquidityGaugeV2(_gauge).reward_tokens(i);\r\n            if (rewardToken != address(0)) {\r\n                lpRewardsTokensWithEmpties[i] = rewardToken;\r\n                rewardsTokensCount++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        rewardsTokens_ = new address[](rewardsTokensCount);\r\n        for (uint256 i; i < rewardsTokensCount; i++) {\r\n            rewardsTokens_[i] = lpRewardsTokensWithEmpties[i];\r\n        }\r\n\r\n        return rewardsTokens_;\r\n    }\r\n\r\n    /// @dev Helper to stake LP tokens\r\n    function __curveGaugeV2Stake(\r\n        address _gauge,\r\n        address _lpToken,\r\n        uint256 _amount\r\n    ) internal {\r\n        __approveAssetMaxAsNeeded(_lpToken, _gauge, _amount);\r\n        ICurveLiquidityGaugeV2(_gauge).deposit(_amount, address(this));\r\n    }\r\n\r\n    /// @dev Helper to unstake LP tokens\r\n    function __curveGaugeV2Unstake(address _gauge, uint256 _amount) internal {\r\n        ICurveLiquidityGaugeV2(_gauge).withdraw(_amount);\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveLiquidityGaugeV2 interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveLiquidityGaugeV2 {\r\n    function claim_rewards(address) external;\r\n\r\n    function deposit(uint256, address) external;\r\n\r\n    function reward_tokens(uint256) external view returns (address);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityStethAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\r\nimport \"../utils/actions/CurveStethLiquidityActionsMixin.sol\";\r\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title CurveLiquidityStethAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for liquidity provision in Curve's steth pool (https://www.curve.fi/steth)\r\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\r\n/// or claimRewardsAndReinvest(). Rationale:\r\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\r\n/// to enforce policy management or emit an event\r\n/// - rewards tokens can be outside of the asset universe, e.g., $LDO, in which case\r\n/// they cannot be tracked\r\n/// This adapter will need to be re-deployed if UniswapV2 low liquidity becomes\r\n/// a concern for rewards tokens when using claimRewardsAndReinvest().\r\ncontract CurveLiquidityStethAdapter is\r\n    AdapterBase2,\r\n    CurveGaugeV2RewardsHandlerBase,\r\n    CurveStethLiquidityActionsMixin,\r\n    UniswapV2ActionsMixin\r\n{\r\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\r\n    address private immutable LP_TOKEN;\r\n    address private immutable STETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _liquidityGaugeToken,\r\n        address _lpToken,\r\n        address _minter,\r\n        address _pool,\r\n        address _crvToken,\r\n        address _stethToken,\r\n        address _wethToken,\r\n        address _uniswapV2Router2\r\n    )\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\r\n        CurveStethLiquidityActionsMixin(_pool, _stethToken, _wethToken)\r\n        UniswapV2ActionsMixin(_uniswapV2Router2)\r\n    {\r\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\r\n        LP_TOKEN = _lpToken;\r\n        STETH_TOKEN = _stethToken;\r\n\r\n        // Max approve contracts to spend relevant tokens\r\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\r\n    }\r\n\r\n    /// @dev Needed to receive ETH from redemption and to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"CURVE_LIQUIDITY_STETH\";\r\n    }\r\n\r\n    /// @notice Approves assets from the vault to be used by this contract.\r\n    /// @dev No logic necessary. Exists only to grant adapter with necessary approvals from the vault,\r\n    /// which takes place in the IntegrationManager.\r\n    function approveAssets(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external {}\r\n\r\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    function claimRewards(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\r\n    }\r\n\r\n    /// @notice Claims rewards and then compounds the rewards tokens back into the staked LP token\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndReinvest(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            bool useFullBalances,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeClaimRewardsAndReinvestCallArgs(_encodedCallArgs);\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        // Swap all reward tokens to WETH via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            address(this),\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            getCurveStethLiquidityWethToken(),\r\n            address(0)\r\n        );\r\n\r\n        // Lend all received WETH for staked LP tokens\r\n        uint256 wethBalance = ERC20(getCurveStethLiquidityWethToken()).balanceOf(address(this));\r\n        if (wethBalance > 0) {\r\n            __curveStethLend(wethBalance, 0, minIncomingLiquidityGaugeTokenAmount);\r\n            __curveGaugeV2Stake(\r\n                LIQUIDITY_GAUGE_TOKEN,\r\n                LP_TOKEN,\r\n                ERC20(LP_TOKEN).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndSwap(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (bool useFullBalances, address incomingAsset, ) = __decodeClaimRewardsAndSwapCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        // Swap all reward tokens to the designated incomingAsset via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            _vaultProxy,\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            incomingAsset,\r\n            getCurveStethLiquidityWethToken()\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for steth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingStethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveStethLend(\r\n            outgoingWethAmount,\r\n            outgoingStethAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for steth LP tokens, then stakes the received LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lendAndStake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingStethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveStethLend(\r\n            outgoingWethAmount,\r\n            outgoingStethAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n        __curveGaugeV2Stake(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            LP_TOKEN,\r\n            ERC20(LP_TOKEN).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems steth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingStethAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveStethRedeem(\r\n            outgoingLpTokenAmount,\r\n            minIncomingWethAmount,\r\n            minIncomingStethAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /// @notice Stakes steth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function stake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Stake(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            LP_TOKEN,\r\n            __decodeStakeCallArgs(_encodedCallArgs)\r\n        );\r\n    }\r\n\r\n    /// @notice Unstakes steth LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, __decodeUnstakeCallArgs(_encodedCallArgs));\r\n    }\r\n\r\n    /// @notice Unstakes steth LP tokens, then redeems them\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstakeAndRedeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingStethAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\r\n        __curveStethRedeem(\r\n            outgoingLiquidityGaugeTokenAmount,\r\n            minIncomingWethAmount,\r\n            minIncomingStethAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == APPROVE_ASSETS_SELECTOR) {\r\n            return __parseAssetsForApproveAssets(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_SELECTOR) {\r\n            return __parseAssetsForClaimRewards();\r\n        } else if (_selector == CLAIM_REWARDS_AND_REINVEST_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndReinvest(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_AND_SWAP_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndSwap(_encodedCallArgs);\r\n        } else if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\r\n            return __parseAssetsForLendAndStake(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        } else if (_selector == STAKE_SELECTOR) {\r\n            return __parseAssetsForStake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_SELECTOR) {\r\n            return __parseAssetsForUnstake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\r\n            return __parseAssetsForUnstakeAndRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during approveAssets() calls\r\n    function __parseAssetsForApproveAssets(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (spendAssets_, spendAssetAmounts_) = __decodeApproveAssetsCallArgs(_encodedCallArgs);\r\n        require(\r\n            spendAssets_.length == spendAssetAmounts_.length,\r\n            \"__parseAssetsForApproveAssets: Unequal arrays\"\r\n        );\r\n\r\n        // Validate that only rewards tokens are given allowances\r\n        address[] memory rewardsTokens = __curveGaugeV2GetRewardsTokensWithCrv(\r\n            LIQUIDITY_GAUGE_TOKEN\r\n        );\r\n        for (uint256 i; i < spendAssets_.length; i++) {\r\n            // Allow revoking approval for any asset\r\n            if (spendAssetAmounts_[i] > 0) {\r\n                require(\r\n                    rewardsTokens.contains(spendAssets_[i]),\r\n                    \"__parseAssetsForApproveAssets: Invalid reward token\"\r\n                );\r\n            }\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Approve,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewards() calls.\r\n    /// No action required, all values empty.\r\n    function __parseAssetsForClaimRewards()\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndReinvest() calls.\r\n    function __parseAssetsForClaimRewardsAndReinvest(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (, uint256 minIncomingLiquidityGaugeTokenAmount) = __decodeClaimRewardsAndReinvestCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndSwap() calls.\r\n    function __parseAssetsForClaimRewardsAndSwap(bytes calldata _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            ,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeClaimRewardsAndSwapCallArgs(_encodedCallArgs);\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingStethAmount,\r\n            uint256 minIncomingLpTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingWethAmount,\r\n            outgoingStethAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lendAndStake() calls\r\n    function __parseAssetsForLendAndStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingWethAmount,\r\n            uint256 outgoingStethAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingWethAmount,\r\n            outgoingStethAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingStethAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingWethAmount,\r\n            minIncomingStethAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during stake() calls\r\n    function __parseAssetsForStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstake() calls\r\n    function __parseAssetsForUnstake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstakeAndRedeem() calls\r\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingWethAmount,\r\n            uint256 minIncomingStethAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingWethAmount,\r\n            minIncomingStethAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\r\n    function __parseIncomingAssetsForRedemptionCalls(\r\n        uint256 _minIncomingWethAmount,\r\n        uint256 _minIncomingStethAmount,\r\n        bool _receiveSingleAsset\r\n    )\r\n        private\r\n        view\r\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\r\n    {\r\n        if (_receiveSingleAsset) {\r\n            incomingAssets_ = new address[](1);\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n\r\n            if (_minIncomingWethAmount == 0) {\r\n                require(\r\n                    _minIncomingStethAmount > 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\r\n                );\r\n                incomingAssets_[0] = STETH_TOKEN;\r\n                minIncomingAssetAmounts_[0] = _minIncomingStethAmount;\r\n            } else {\r\n                require(\r\n                    _minIncomingStethAmount == 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\r\n                );\r\n                incomingAssets_[0] = getCurveStethLiquidityWethToken();\r\n                minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\r\n            }\r\n        } else {\r\n            incomingAssets_ = new address[](2);\r\n            incomingAssets_[0] = getCurveStethLiquidityWethToken();\r\n            incomingAssets_[1] = STETH_TOKEN;\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](2);\r\n            minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\r\n            minIncomingAssetAmounts_[1] = _minIncomingStethAmount;\r\n        }\r\n\r\n        return (incomingAssets_, minIncomingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\r\n    function __parseSpendAssetsForLendingCalls(\r\n        uint256 _outgoingWethAmount,\r\n        uint256 _outgoingStethAmount\r\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\r\n        if (_outgoingWethAmount > 0 && _outgoingStethAmount > 0) {\r\n            spendAssets_ = new address[](2);\r\n            spendAssets_[0] = getCurveStethLiquidityWethToken();\r\n            spendAssets_[1] = STETH_TOKEN;\r\n\r\n            spendAssetAmounts_ = new uint256[](2);\r\n            spendAssetAmounts_[0] = _outgoingWethAmount;\r\n            spendAssetAmounts_[1] = _outgoingStethAmount;\r\n        } else if (_outgoingWethAmount > 0) {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = getCurveStethLiquidityWethToken();\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingWethAmount;\r\n        } else {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = STETH_TOKEN;\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingStethAmount;\r\n        }\r\n\r\n        return (spendAssets_, spendAssetAmounts_);\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode the encoded call arguments for approving asset allowances\r\n    function __decodeApproveAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address[] memory assets_, uint256[] memory amounts_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[], uint256[]));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards\r\n    function __decodeClaimRewardsAndReinvestCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (bool useFullBalances_, uint256 minIncomingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and swapping\r\n    function __decodeClaimRewardsAndSwapCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            bool useFullBalances_,\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, address, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingWethAmount_,\r\n            uint256 outgoingStethAmount_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for redeeming.\r\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\r\n    /// `minIncomingWethAmount_` and `minIncomingStethAmount_` must be >0\r\n    /// to indicate which asset is to be received.\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingAssetAmount_,\r\n            uint256 minIncomingWethAmount_,\r\n            uint256 minIncomingStethAmount_,\r\n            bool receiveSingleAsset_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for staking\r\n    function __decodeStakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLpTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for unstaking\r\n    function __decodeUnstakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\r\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\r\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\r\n        return LIQUIDITY_GAUGE_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `LP_TOKEN` variable\r\n    /// @return lpToken_ The `LP_TOKEN` variable value\r\n    function getLpToken() external view returns (address lpToken_) {\r\n        return LP_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `STETH_TOKEN` variable\r\n    /// @return stethToken_ The `STETH_TOKEN` variable value\r\n    function getStethToken() external view returns (address stethToken_) {\r\n        return STETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityEursAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\r\nimport \"../utils/actions/CurveEursLiquidityActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title CurveLiquidityEursAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for liquidity provision in Curve's eurs pool (https://www.curve.fi/eurs)\r\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\r\n/// Rationale:\r\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\r\n/// to enforce policy management or emit an event\r\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\r\ncontract CurveLiquidityEursAdapter is\r\n    AdapterBase2,\r\n    CurveGaugeV2RewardsHandlerBase,\r\n    CurveEursLiquidityActionsMixin\r\n{\r\n    address private immutable EURS_TOKEN;\r\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\r\n    address private immutable LP_TOKEN;\r\n    address private immutable SEUR_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _liquidityGaugeToken,\r\n        address _lpToken,\r\n        address _minter,\r\n        address _pool,\r\n        address _crvToken,\r\n        address _eursToken,\r\n        address _seurToken\r\n    )\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\r\n        CurveEursLiquidityActionsMixin(_pool, _eursToken, _seurToken)\r\n    {\r\n        EURS_TOKEN = _eursToken;\r\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\r\n        LP_TOKEN = _lpToken;\r\n        SEUR_TOKEN = _seurToken;\r\n\r\n        // Max approve contracts to spend relevant tokens\r\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"CURVE_LIQUIDITY_EURS\";\r\n    }\r\n\r\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    function claimRewards(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        __curveGaugeV2ClaimAllRewards(getLiquidityGaugeToken(), _vaultProxy);\r\n    }\r\n\r\n    /// @notice Lends assets for eurs LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingEursAmount,\r\n            uint256 outgoingSeurAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveEursLend(\r\n            outgoingEursAmount,\r\n            outgoingSeurAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for eurs LP tokens, then stakes the received LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lendAndStake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingEursAmount,\r\n            uint256 outgoingSeurAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveEursLend(\r\n            outgoingEursAmount,\r\n            outgoingSeurAmount,\r\n            minIncomingLiquidityGaugeTokenAmount\r\n        );\r\n        __curveGaugeV2Stake(\r\n            getLiquidityGaugeToken(),\r\n            getLpToken(),\r\n            ERC20(getLpToken()).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems eurs LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingEursAmount,\r\n            uint256 minIncomingSeurAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveEursRedeem(\r\n            outgoingLpTokenAmount,\r\n            minIncomingEursAmount,\r\n            minIncomingSeurAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /// @notice Stakes eurs LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function stake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Stake(\r\n            getLiquidityGaugeToken(),\r\n            getLpToken(),\r\n            __decodeStakeCallArgs(_encodedCallArgs)\r\n        );\r\n    }\r\n\r\n    /// @notice Unstakes eurs LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        __curveGaugeV2Unstake(getLiquidityGaugeToken(), __decodeUnstakeCallArgs(_encodedCallArgs));\r\n    }\r\n\r\n    /// @notice Unstakes eurs LP tokens, then redeems them\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstakeAndRedeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingEursAmount,\r\n            uint256 minIncomingSeurAmount,\r\n            bool redeemSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Unstake(getLiquidityGaugeToken(), outgoingLiquidityGaugeTokenAmount);\r\n        __curveEursRedeem(\r\n            outgoingLiquidityGaugeTokenAmount,\r\n            minIncomingEursAmount,\r\n            minIncomingSeurAmount,\r\n            redeemSingleAsset\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\r\n            return __parseAssetsForClaimRewards();\r\n        } else if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\r\n            return __parseAssetsForLendAndStake(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        } else if (_selector == STAKE_SELECTOR) {\r\n            return __parseAssetsForStake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_SELECTOR) {\r\n            return __parseAssetsForUnstake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\r\n            return __parseAssetsForUnstakeAndRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewards() calls.\r\n    /// No action required, all values empty.\r\n    function __parseAssetsForClaimRewards()\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingEursAmount,\r\n            uint256 outgoingSeurAmount,\r\n            uint256 minIncomingLpTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingEursAmount,\r\n            outgoingSeurAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = getLpToken();\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lendAndStake() calls\r\n    function __parseAssetsForLendAndStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingEursAmount,\r\n            uint256 outgoingSeurAmount,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            outgoingEursAmount,\r\n            outgoingSeurAmount\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = getLiquidityGaugeToken();\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256 minIncomingEursAmount,\r\n            uint256 minIncomingSeurAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = getLpToken();\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingEursAmount,\r\n            minIncomingSeurAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during stake() calls\r\n    function __parseAssetsForStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = getLpToken();\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = getLiquidityGaugeToken();\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstake() calls\r\n    function __parseAssetsForUnstake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = getLiquidityGaugeToken();\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = getLpToken();\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstakeAndRedeem() calls\r\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256 minIncomingEursAmount,\r\n            uint256 minIncomingSeurAmount,\r\n            bool receiveSingleAsset\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = getLiquidityGaugeToken();\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            minIncomingEursAmount,\r\n            minIncomingSeurAmount,\r\n            receiveSingleAsset\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\r\n    function __parseIncomingAssetsForRedemptionCalls(\r\n        uint256 _minIncomingEursAmount,\r\n        uint256 _minIncomingSeurAmount,\r\n        bool _receiveSingleAsset\r\n    )\r\n        private\r\n        view\r\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\r\n    {\r\n        if (_receiveSingleAsset) {\r\n            incomingAssets_ = new address[](1);\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n\r\n            if (_minIncomingEursAmount == 0) {\r\n                require(\r\n                    _minIncomingSeurAmount > 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\r\n                );\r\n                incomingAssets_[0] = getSeurToken();\r\n                minIncomingAssetAmounts_[0] = _minIncomingSeurAmount;\r\n            } else {\r\n                require(\r\n                    _minIncomingSeurAmount == 0,\r\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\r\n                );\r\n                incomingAssets_[0] = getEursToken();\r\n                minIncomingAssetAmounts_[0] = _minIncomingEursAmount;\r\n            }\r\n        } else {\r\n            incomingAssets_ = new address[](2);\r\n            incomingAssets_[0] = getEursToken();\r\n            incomingAssets_[1] = getSeurToken();\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](2);\r\n            minIncomingAssetAmounts_[0] = _minIncomingEursAmount;\r\n            minIncomingAssetAmounts_[1] = _minIncomingSeurAmount;\r\n        }\r\n\r\n        return (incomingAssets_, minIncomingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\r\n    function __parseSpendAssetsForLendingCalls(\r\n        uint256 _outgoingEursAmount,\r\n        uint256 _outgoingSeurAmount\r\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\r\n        if (_outgoingEursAmount > 0 && _outgoingSeurAmount > 0) {\r\n            spendAssets_ = new address[](2);\r\n            spendAssets_[0] = getEursToken();\r\n            spendAssets_[1] = getSeurToken();\r\n\r\n            spendAssetAmounts_ = new uint256[](2);\r\n            spendAssetAmounts_[0] = _outgoingEursAmount;\r\n            spendAssetAmounts_[1] = _outgoingSeurAmount;\r\n        } else if (_outgoingEursAmount > 0) {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = getEursToken();\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingEursAmount;\r\n        } else {\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = getSeurToken();\r\n\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = _outgoingSeurAmount;\r\n        }\r\n\r\n        return (spendAssets_, spendAssetAmounts_);\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode the encoded call arguments for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingEursAmount_,\r\n            uint256 outgoingSeurAmount_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for redeeming.\r\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\r\n    /// `minIncomingEursAmount_` and `minIncomingSeurAmount_` must be >0\r\n    /// to indicate which asset is to be received.\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingAssetAmount_,\r\n            uint256 minIncomingEursAmount_,\r\n            uint256 minIncomingSeurAmount_,\r\n            bool receiveSingleAsset_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256, uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for staking\r\n    function __decodeStakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLpTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for unstaking\r\n    function __decodeUnstakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `EURS_TOKEN` variable\r\n    /// @return eursToken_ The `EURS_TOKEN` variable value\r\n    function getEursToken() public view returns (address eursToken_) {\r\n        return EURS_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\r\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\r\n    function getLiquidityGaugeToken() public view returns (address liquidityGaugeToken_) {\r\n        return LIQUIDITY_GAUGE_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `LP_TOKEN` variable\r\n    /// @return lpToken_ The `LP_TOKEN` variable value\r\n    function getLpToken() public view returns (address lpToken_) {\r\n        return LP_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `SEUR_TOKEN` variable\r\n    /// @return seurToken_ The `SEUR_TOKEN` variable value\r\n    function getSeurToken() public view returns (address seurToken_) {\r\n        return SEUR_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveEursLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../../interfaces/ICurveStableSwapEurs.sol\";\r\n\r\n/// @title CurveEursLiquidityActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with the Curve eurs pool's liquidity functions\r\n/// @dev Inheriting contract must have a receive() function\r\nabstract contract CurveEursLiquidityActionsMixin {\r\n    using SafeERC20 for ERC20;\r\n\r\n    int128 private constant CURVE_EURS_POOL_INDEX_EURS = 0;\r\n    int128 private constant CURVE_EURS_POOL_INDEX_SEUR = 1;\r\n\r\n    address private immutable CURVE_EURS_LIQUIDITY_POOL;\r\n\r\n    constructor(\r\n        address _pool,\r\n        address _eursToken,\r\n        address _seurToken\r\n    ) public {\r\n        CURVE_EURS_LIQUIDITY_POOL = _pool;\r\n\r\n        // Pre-approve pool to use max of both tokens\r\n        ERC20(_eursToken).safeApprove(_pool, type(uint256).max);\r\n        ERC20(_seurToken).safeApprove(_pool, type(uint256).max);\r\n    }\r\n\r\n    /// @dev Helper to add liquidity to the pool\r\n    function __curveEursLend(\r\n        uint256 _outgoingEursAmount,\r\n        uint256 _outgoingSeurAmount,\r\n        uint256 _minIncomingLPTokenAmount\r\n    ) internal {\r\n        ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).add_liquidity(\r\n            [_outgoingEursAmount, _outgoingSeurAmount],\r\n            _minIncomingLPTokenAmount\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to remove liquidity from the pool.\r\n    // Assumes that if _redeemSingleAsset is true, then\r\n    // \"_minIncomingEursAmount > 0 XOR _minIncomingSeurAmount > 0\" has already been validated.\r\n    function __curveEursRedeem(\r\n        uint256 _outgoingLPTokenAmount,\r\n        uint256 _minIncomingEursAmount,\r\n        uint256 _minIncomingSeurAmount,\r\n        bool _redeemSingleAsset\r\n    ) internal {\r\n        if (_redeemSingleAsset) {\r\n            if (_minIncomingEursAmount > 0) {\r\n                ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_EURS_POOL_INDEX_EURS,\r\n                    _minIncomingEursAmount\r\n                );\r\n            } else {\r\n                ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                    _outgoingLPTokenAmount,\r\n                    CURVE_EURS_POOL_INDEX_SEUR,\r\n                    _minIncomingSeurAmount\r\n                );\r\n            }\r\n        } else {\r\n            ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity(\r\n                _outgoingLPTokenAmount,\r\n                [_minIncomingEursAmount, _minIncomingSeurAmount]\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `CURVE_EURS_LIQUIDITY_POOL` variable\r\n    /// @return pool_ The `CURVE_EURS_LIQUIDITY_POOL` variable value\r\n    function getCurveEursLiquidityPool() public view returns (address pool_) {\r\n        return CURVE_EURS_LIQUIDITY_POOL;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveStableSwapEurs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveStableSwapEurs interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveStableSwapEurs {\r\n    function add_liquidity(uint256[2] calldata, uint256) external returns (uint256);\r\n\r\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256,\r\n        int128,\r\n        uint256\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/AssetWhitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../../../../core/fund/vault/VaultLib.sol\";\r\nimport \"../../../../utils/AddressArrayLib.sol\";\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/PostCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title AssetWhitelist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that only allows a configurable whitelist of assets in a fund's holdings\r\ncontract AssetWhitelist is PostCallOnIntegrationValidatePolicyBase, AddressListPolicyMixin {\r\n    using AddressArrayLib for address[];\r\n\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _vaultProxy The fund's VaultProxy address\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        require(\r\n            passesRule(_comptrollerProxy, VaultLib(_vaultProxy).getTrackedAssets()),\r\n            \"activateForFund: Non-whitelisted asset detected\"\r\n        );\r\n    }\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        address[] memory assets = abi.decode(_encodedSettings, (address[]));\r\n        require(\r\n            assets.contains(ComptrollerLib(_comptrollerProxy).getDenominationAsset()),\r\n            \"addFundSettings: Must whitelist denominationAsset\"\r\n        );\r\n\r\n        __addToList(_comptrollerProxy, abi.decode(_encodedSettings, (address[])));\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ASSET_WHITELIST\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _assets The assets with which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address[] memory _assets)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            if (!isInList(_comptrollerProxy, _assets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (, , address[] memory incomingAssets, , , ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, incomingAssets);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/AddressListPolicyMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\n/// @title AddressListPolicyMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice An abstract mixin contract for policies that use an address list\r\nabstract contract AddressListPolicyMixin {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    event AddressesAdded(address indexed comptrollerProxy, address[] items);\r\n\r\n    event AddressesRemoved(address indexed comptrollerProxy, address[] items);\r\n\r\n    mapping(address => EnumerableSet.AddressSet) private comptrollerProxyToList;\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Get all addresses in a fund's list\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @return list_ The addresses in the fund's list\r\n    function getList(address _comptrollerProxy) external view returns (address[] memory list_) {\r\n        list_ = new address[](comptrollerProxyToList[_comptrollerProxy].length());\r\n        for (uint256 i = 0; i < list_.length; i++) {\r\n            list_[i] = comptrollerProxyToList[_comptrollerProxy].at(i);\r\n        }\r\n        return list_;\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Check if an address is in a fund's list\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _item The address to check against the list\r\n    /// @return isInList_ True if the address is in the list\r\n    function isInList(address _comptrollerProxy, address _item)\r\n        public\r\n        view\r\n        returns (bool isInList_)\r\n    {\r\n        return comptrollerProxyToList[_comptrollerProxy].contains(_item);\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Helper to add addresses to the calling fund's list\r\n    function __addToList(address _comptrollerProxy, address[] memory _items) internal {\r\n        require(_items.length > 0, \"__addToList: No addresses provided\");\r\n\r\n        for (uint256 i = 0; i < _items.length; i++) {\r\n            require(\r\n                comptrollerProxyToList[_comptrollerProxy].add(_items[i]),\r\n                \"__addToList: Address already exists in list\"\r\n            );\r\n        }\r\n\r\n        emit AddressesAdded(_comptrollerProxy, _items);\r\n    }\r\n\r\n    /// @dev Helper to remove addresses from the calling fund's list\r\n    function __removeFromList(address _comptrollerProxy, address[] memory _items) internal {\r\n        require(_items.length > 0, \"__removeFromList: No addresses provided\");\r\n\r\n        for (uint256 i = 0; i < _items.length; i++) {\r\n            require(\r\n                comptrollerProxyToList[_comptrollerProxy].remove(_items[i]),\r\n                \"__removeFromList: Address does not exist in list\"\r\n            );\r\n        }\r\n\r\n        emit AddressesRemoved(_comptrollerProxy, _items);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/AssetBlacklist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\r\nimport \"../../../../core/fund/vault/VaultLib.sol\";\r\nimport \"../../../../utils/AddressArrayLib.sol\";\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/PostCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title AssetBlacklist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that disallows a configurable blacklist of assets in a fund's holdings\r\ncontract AssetBlacklist is PostCallOnIntegrationValidatePolicyBase, AddressListPolicyMixin {\r\n    using AddressArrayLib for address[];\r\n\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _vaultProxy The fund's VaultProxy address\r\n    function activateForFund(address _comptrollerProxy, address _vaultProxy)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        require(\r\n            passesRule(_comptrollerProxy, VaultLib(_vaultProxy).getTrackedAssets()),\r\n            \"activateForFund: Blacklisted asset detected\"\r\n        );\r\n    }\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        address[] memory assets = abi.decode(_encodedSettings, (address[]));\r\n        require(\r\n            !assets.contains(ComptrollerLib(_comptrollerProxy).getDenominationAsset()),\r\n            \"addFundSettings: Cannot blacklist denominationAsset\"\r\n        );\r\n\r\n        __addToList(_comptrollerProxy, assets);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ASSET_BLACKLIST\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _assets The assets with which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address[] memory _assets)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        for (uint256 i; i < _assets.length; i++) {\r\n            if (isInList(_comptrollerProxy, _assets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (, , address[] memory incomingAssets, , , ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, incomingAssets);\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/vault/VaultProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./utils/ProxiableVaultLib.sol\";\r\n\r\n/// @title VaultProxy Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A proxy contract for all VaultProxy instances, slightly modified from EIP-1822\r\n/// @dev Adapted from the recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\r\n/// and using the EIP-1967 storage slot for the proxiable implementation.\r\n/// i.e., `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`, which is\r\n/// \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\r\n/// See: https://eips.ethereum.org/EIPS/eip-1822\r\ncontract VaultProxy {\r\n    constructor(bytes memory _constructData, address _vaultLib) public {\r\n        // \"0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5\" corresponds to\r\n        // `bytes32(keccak256('mln.proxiable.vaultlib'))`\r\n        require(\r\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\r\n                ProxiableVaultLib(_vaultLib).proxiableUUID(),\r\n            \"constructor: _vaultLib not compatible\"\r\n        );\r\n\r\n        assembly {\r\n            // solium-disable-line\r\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _vaultLib)\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = _vaultLib.delegatecall(_constructData); // solium-disable-line\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    fallback() external payable {\r\n        assembly {\r\n            // solium-disable-line\r\n            let contractLogic := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(\r\n                sub(gas(), 10000),\r\n                contractLogic,\r\n                0x0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n                case 0 {\r\n                    revert(0, retSz)\r\n                }\r\n                default {\r\n                    return(0, retSz)\r\n                }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/persistent/dispatcher/Dispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/IMigrationHookHandler.sol\";\r\nimport \"../utils/IMigratableVault.sol\";\r\nimport \"../vault/VaultProxy.sol\";\r\nimport \"./IDispatcher.sol\";\r\n\r\n/// @title Dispatcher Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice The top-level contract linking multiple releases.\r\n/// It handles the deployment of new VaultProxy instances,\r\n/// and the regulation of fund migration from a previous release to the current one.\r\n/// It can also be referred to for access-control based on this contract's owner.\r\n/// @dev DO NOT EDIT CONTRACT\r\ncontract Dispatcher is IDispatcher {\r\n    event CurrentFundDeployerSet(address prevFundDeployer, address nextFundDeployer);\r\n\r\n    event MigrationCancelled(\r\n        address indexed vaultProxy,\r\n        address indexed prevFundDeployer,\r\n        address indexed nextFundDeployer,\r\n        address nextVaultAccessor,\r\n        address nextVaultLib,\r\n        uint256 executableTimestamp\r\n    );\r\n\r\n    event MigrationExecuted(\r\n        address indexed vaultProxy,\r\n        address indexed prevFundDeployer,\r\n        address indexed nextFundDeployer,\r\n        address nextVaultAccessor,\r\n        address nextVaultLib,\r\n        uint256 executableTimestamp\r\n    );\r\n\r\n    event MigrationSignaled(\r\n        address indexed vaultProxy,\r\n        address indexed prevFundDeployer,\r\n        address indexed nextFundDeployer,\r\n        address nextVaultAccessor,\r\n        address nextVaultLib,\r\n        uint256 executableTimestamp\r\n    );\r\n\r\n    event MigrationTimelockSet(uint256 prevTimelock, uint256 nextTimelock);\r\n\r\n    event NominatedOwnerSet(address indexed nominatedOwner);\r\n\r\n    event NominatedOwnerRemoved(address indexed nominatedOwner);\r\n\r\n    event OwnershipTransferred(address indexed prevOwner, address indexed nextOwner);\r\n\r\n    event MigrationInCancelHookFailed(\r\n        bytes failureReturnData,\r\n        address indexed vaultProxy,\r\n        address indexed prevFundDeployer,\r\n        address indexed nextFundDeployer,\r\n        address nextVaultAccessor,\r\n        address nextVaultLib\r\n    );\r\n\r\n    event MigrationOutHookFailed(\r\n        bytes failureReturnData,\r\n        IMigrationHookHandler.MigrationOutHook hook,\r\n        address indexed vaultProxy,\r\n        address indexed prevFundDeployer,\r\n        address indexed nextFundDeployer,\r\n        address nextVaultAccessor,\r\n        address nextVaultLib\r\n    );\r\n\r\n    event SharesTokenSymbolSet(string _nextSymbol);\r\n\r\n    event VaultProxyDeployed(\r\n        address indexed fundDeployer,\r\n        address indexed owner,\r\n        address vaultProxy,\r\n        address indexed vaultLib,\r\n        address vaultAccessor,\r\n        string fundName\r\n    );\r\n\r\n    struct MigrationRequest {\r\n        address nextFundDeployer;\r\n        address nextVaultAccessor;\r\n        address nextVaultLib;\r\n        uint256 executableTimestamp;\r\n    }\r\n\r\n    address private currentFundDeployer;\r\n    address private nominatedOwner;\r\n    address private owner;\r\n    uint256 private migrationTimelock;\r\n    string private sharesTokenSymbol;\r\n    mapping(address => address) private vaultProxyToFundDeployer;\r\n    mapping(address => MigrationRequest) private vaultProxyToMigrationRequest;\r\n\r\n    modifier onlyCurrentFundDeployer() {\r\n        require(\r\n            msg.sender == currentFundDeployer,\r\n            \"Only the current FundDeployer can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the contract owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        migrationTimelock = 2 days;\r\n        owner = msg.sender;\r\n        sharesTokenSymbol = \"ENZF\";\r\n    }\r\n\r\n    /////////////\r\n    // GENERAL //\r\n    /////////////\r\n\r\n    /// @notice Sets a new `symbol` value for VaultProxy instances\r\n    /// @param _nextSymbol The symbol value to set\r\n    function setSharesTokenSymbol(string calldata _nextSymbol) external override onlyOwner {\r\n        sharesTokenSymbol = _nextSymbol;\r\n\r\n        emit SharesTokenSymbolSet(_nextSymbol);\r\n    }\r\n\r\n    ////////////////////\r\n    // ACCESS CONTROL //\r\n    ////////////////////\r\n\r\n    /// @notice Claim ownership of the contract\r\n    function claimOwnership() external override {\r\n        address nextOwner = nominatedOwner;\r\n        require(\r\n            msg.sender == nextOwner,\r\n            \"claimOwnership: Only the nominatedOwner can call this function\"\r\n        );\r\n\r\n        delete nominatedOwner;\r\n\r\n        address prevOwner = owner;\r\n        owner = nextOwner;\r\n\r\n        emit OwnershipTransferred(prevOwner, nextOwner);\r\n    }\r\n\r\n    /// @notice Revoke the nomination of a new contract owner\r\n    function removeNominatedOwner() external override onlyOwner {\r\n        address removedNominatedOwner = nominatedOwner;\r\n        require(\r\n            removedNominatedOwner != address(0),\r\n            \"removeNominatedOwner: There is no nominated owner\"\r\n        );\r\n\r\n        delete nominatedOwner;\r\n\r\n        emit NominatedOwnerRemoved(removedNominatedOwner);\r\n    }\r\n\r\n    /// @notice Set a new FundDeployer for use within the contract\r\n    /// @param _nextFundDeployer The address of the FundDeployer contract\r\n    function setCurrentFundDeployer(address _nextFundDeployer) external override onlyOwner {\r\n        require(\r\n            _nextFundDeployer != address(0),\r\n            \"setCurrentFundDeployer: _nextFundDeployer cannot be empty\"\r\n        );\r\n        require(\r\n            __isContract(_nextFundDeployer),\r\n            \"setCurrentFundDeployer: Non-contract _nextFundDeployer\"\r\n        );\r\n\r\n        address prevFundDeployer = currentFundDeployer;\r\n        require(\r\n            _nextFundDeployer != prevFundDeployer,\r\n            \"setCurrentFundDeployer: _nextFundDeployer is already currentFundDeployer\"\r\n        );\r\n\r\n        currentFundDeployer = _nextFundDeployer;\r\n\r\n        emit CurrentFundDeployerSet(prevFundDeployer, _nextFundDeployer);\r\n    }\r\n\r\n    /// @notice Nominate a new contract owner\r\n    /// @param _nextNominatedOwner The account to nominate\r\n    /// @dev Does not prohibit overwriting the current nominatedOwner\r\n    function setNominatedOwner(address _nextNominatedOwner) external override onlyOwner {\r\n        require(\r\n            _nextNominatedOwner != address(0),\r\n            \"setNominatedOwner: _nextNominatedOwner cannot be empty\"\r\n        );\r\n        require(\r\n            _nextNominatedOwner != owner,\r\n            \"setNominatedOwner: _nextNominatedOwner is already the owner\"\r\n        );\r\n        require(\r\n            _nextNominatedOwner != nominatedOwner,\r\n            \"setNominatedOwner: _nextNominatedOwner is already nominated\"\r\n        );\r\n\r\n        nominatedOwner = _nextNominatedOwner;\r\n\r\n        emit NominatedOwnerSet(_nextNominatedOwner);\r\n    }\r\n\r\n    /// @dev Helper to check whether an address is a deployed contract\r\n    function __isContract(address _who) private view returns (bool isContract_) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_who)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n\r\n    ////////////////\r\n    // DEPLOYMENT //\r\n    ////////////////\r\n\r\n    /// @notice Deploys a VaultProxy\r\n    /// @param _vaultLib The VaultLib library with which to instantiate the VaultProxy\r\n    /// @param _owner The account to set as the VaultProxy's owner\r\n    /// @param _vaultAccessor The account to set as the VaultProxy's permissioned accessor\r\n    /// @param _fundName The name of the fund\r\n    /// @dev Input validation should be handled by the VaultProxy during deployment\r\n    function deployVaultProxy(\r\n        address _vaultLib,\r\n        address _owner,\r\n        address _vaultAccessor,\r\n        string calldata _fundName\r\n    ) external override onlyCurrentFundDeployer returns (address vaultProxy_) {\r\n        require(__isContract(_vaultAccessor), \"deployVaultProxy: Non-contract _vaultAccessor\");\r\n\r\n        bytes memory constructData = abi.encodeWithSelector(\r\n            IMigratableVault.init.selector,\r\n            _owner,\r\n            _vaultAccessor,\r\n            _fundName\r\n        );\r\n        vaultProxy_ = address(new VaultProxy(constructData, _vaultLib));\r\n\r\n        address fundDeployer = msg.sender;\r\n        vaultProxyToFundDeployer[vaultProxy_] = fundDeployer;\r\n\r\n        emit VaultProxyDeployed(\r\n            fundDeployer,\r\n            _owner,\r\n            vaultProxy_,\r\n            _vaultLib,\r\n            _vaultAccessor,\r\n            _fundName\r\n        );\r\n\r\n        return vaultProxy_;\r\n    }\r\n\r\n    ////////////////\r\n    // MIGRATIONS //\r\n    ////////////////\r\n\r\n    /// @notice Cancels a pending migration request\r\n    /// @param _vaultProxy The VaultProxy contract for which to cancel the migration request\r\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\r\n    /// @dev Because this function must also be callable by a permissioned migrator, it has an\r\n    /// extra migration hook to the nextFundDeployer for the case where cancelMigration()\r\n    /// is called directly (rather than via the nextFundDeployer).\r\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external override {\r\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\r\n        address nextFundDeployer = request.nextFundDeployer;\r\n        require(nextFundDeployer != address(0), \"cancelMigration: No migration request exists\");\r\n\r\n        // TODO: confirm that if canMigrate() does not exist but the caller is a valid FundDeployer, this still works.\r\n        require(\r\n            msg.sender == nextFundDeployer || IMigratableVault(_vaultProxy).canMigrate(msg.sender),\r\n            \"cancelMigration: Not an allowed caller\"\r\n        );\r\n\r\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\r\n        address nextVaultAccessor = request.nextVaultAccessor;\r\n        address nextVaultLib = request.nextVaultLib;\r\n        uint256 executableTimestamp = request.executableTimestamp;\r\n\r\n        delete vaultProxyToMigrationRequest[_vaultProxy];\r\n\r\n        __invokeMigrationOutHook(\r\n            IMigrationHookHandler.MigrationOutHook.PostCancel,\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n        __invokeMigrationInCancelHook(\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n\r\n        emit MigrationCancelled(\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            executableTimestamp\r\n        );\r\n    }\r\n\r\n    /// @notice Executes a pending migration request\r\n    /// @param _vaultProxy The VaultProxy contract for which to execute the migration request\r\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\r\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external override {\r\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\r\n        address nextFundDeployer = request.nextFundDeployer;\r\n        require(\r\n            nextFundDeployer != address(0),\r\n            \"executeMigration: No migration request exists for _vaultProxy\"\r\n        );\r\n        require(\r\n            msg.sender == nextFundDeployer,\r\n            \"executeMigration: Only the target FundDeployer can call this function\"\r\n        );\r\n        require(\r\n            nextFundDeployer == currentFundDeployer,\r\n            \"executeMigration: The target FundDeployer is no longer the current FundDeployer\"\r\n        );\r\n        uint256 executableTimestamp = request.executableTimestamp;\r\n        require(\r\n            block.timestamp >= executableTimestamp,\r\n            \"executeMigration: The migration timelock has not elapsed\"\r\n        );\r\n\r\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\r\n        address nextVaultAccessor = request.nextVaultAccessor;\r\n        address nextVaultLib = request.nextVaultLib;\r\n\r\n        __invokeMigrationOutHook(\r\n            IMigrationHookHandler.MigrationOutHook.PreMigrate,\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n\r\n        // Upgrade the VaultProxy to a new VaultLib and update the accessor via the new VaultLib\r\n        IMigratableVault(_vaultProxy).setVaultLib(nextVaultLib);\r\n        IMigratableVault(_vaultProxy).setAccessor(nextVaultAccessor);\r\n\r\n        // Update the FundDeployer that migrated the VaultProxy\r\n        vaultProxyToFundDeployer[_vaultProxy] = nextFundDeployer;\r\n\r\n        // Remove the migration request\r\n        delete vaultProxyToMigrationRequest[_vaultProxy];\r\n\r\n        __invokeMigrationOutHook(\r\n            IMigrationHookHandler.MigrationOutHook.PostMigrate,\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n\r\n        emit MigrationExecuted(\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            nextVaultAccessor,\r\n            nextVaultLib,\r\n            executableTimestamp\r\n        );\r\n    }\r\n\r\n    /// @notice Sets a new migration timelock\r\n    /// @param _nextTimelock The number of seconds for the new timelock\r\n    function setMigrationTimelock(uint256 _nextTimelock) external override onlyOwner {\r\n        uint256 prevTimelock = migrationTimelock;\r\n        require(\r\n            _nextTimelock != prevTimelock,\r\n            \"setMigrationTimelock: _nextTimelock is the current timelock\"\r\n        );\r\n\r\n        migrationTimelock = _nextTimelock;\r\n\r\n        emit MigrationTimelockSet(prevTimelock, _nextTimelock);\r\n    }\r\n\r\n    /// @notice Signals a migration by creating a migration request\r\n    /// @param _vaultProxy The VaultProxy contract for which to signal migration\r\n    /// @param _nextVaultAccessor The account that will be the next `accessor` on the VaultProxy\r\n    /// @param _nextVaultLib The next VaultLib library contract address to set on the VaultProxy\r\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\r\n    function signalMigration(\r\n        address _vaultProxy,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib,\r\n        bool _bypassFailure\r\n    ) external override onlyCurrentFundDeployer {\r\n        require(\r\n            __isContract(_nextVaultAccessor),\r\n            \"signalMigration: Non-contract _nextVaultAccessor\"\r\n        );\r\n\r\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\r\n        require(prevFundDeployer != address(0), \"signalMigration: _vaultProxy does not exist\");\r\n\r\n        address nextFundDeployer = msg.sender;\r\n        require(\r\n            nextFundDeployer != prevFundDeployer,\r\n            \"signalMigration: Can only migrate to a new FundDeployer\"\r\n        );\r\n\r\n        __invokeMigrationOutHook(\r\n            IMigrationHookHandler.MigrationOutHook.PreSignal,\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            _nextVaultAccessor,\r\n            _nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n\r\n        uint256 executableTimestamp = block.timestamp + migrationTimelock;\r\n        vaultProxyToMigrationRequest[_vaultProxy] = MigrationRequest({\r\n            nextFundDeployer: nextFundDeployer,\r\n            nextVaultAccessor: _nextVaultAccessor,\r\n            nextVaultLib: _nextVaultLib,\r\n            executableTimestamp: executableTimestamp\r\n        });\r\n\r\n        __invokeMigrationOutHook(\r\n            IMigrationHookHandler.MigrationOutHook.PostSignal,\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            _nextVaultAccessor,\r\n            _nextVaultLib,\r\n            _bypassFailure\r\n        );\r\n\r\n        emit MigrationSignaled(\r\n            _vaultProxy,\r\n            prevFundDeployer,\r\n            nextFundDeployer,\r\n            _nextVaultAccessor,\r\n            _nextVaultLib,\r\n            executableTimestamp\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to invoke a MigrationInCancelHook on the next FundDeployer being \"migrated in\" to,\r\n    /// which can optionally be implemented on the FundDeployer\r\n    function __invokeMigrationInCancelHook(\r\n        address _vaultProxy,\r\n        address _prevFundDeployer,\r\n        address _nextFundDeployer,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib,\r\n        bool _bypassFailure\r\n    ) private {\r\n        (bool success, bytes memory returnData) = _nextFundDeployer.call(\r\n            abi.encodeWithSelector(\r\n                IMigrationHookHandler.invokeMigrationInCancelHook.selector,\r\n                _vaultProxy,\r\n                _prevFundDeployer,\r\n                _nextVaultAccessor,\r\n                _nextVaultLib\r\n            )\r\n        );\r\n        if (!success) {\r\n            require(\r\n                _bypassFailure,\r\n                string(abi.encodePacked(\"MigrationOutCancelHook: \", returnData))\r\n            );\r\n\r\n            emit MigrationInCancelHookFailed(\r\n                returnData,\r\n                _vaultProxy,\r\n                _prevFundDeployer,\r\n                _nextFundDeployer,\r\n                _nextVaultAccessor,\r\n                _nextVaultLib\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to invoke a IMigrationHookHandler.MigrationOutHook on the previous FundDeployer being \"migrated out\" of,\r\n    /// which can optionally be implemented on the FundDeployer\r\n    function __invokeMigrationOutHook(\r\n        IMigrationHookHandler.MigrationOutHook _hook,\r\n        address _vaultProxy,\r\n        address _prevFundDeployer,\r\n        address _nextFundDeployer,\r\n        address _nextVaultAccessor,\r\n        address _nextVaultLib,\r\n        bool _bypassFailure\r\n    ) private {\r\n        (bool success, bytes memory returnData) = _prevFundDeployer.call(\r\n            abi.encodeWithSelector(\r\n                IMigrationHookHandler.invokeMigrationOutHook.selector,\r\n                _hook,\r\n                _vaultProxy,\r\n                _nextFundDeployer,\r\n                _nextVaultAccessor,\r\n                _nextVaultLib\r\n            )\r\n        );\r\n        if (!success) {\r\n            require(\r\n                _bypassFailure,\r\n                string(abi.encodePacked(__migrationOutHookFailureReasonPrefix(_hook), returnData))\r\n            );\r\n\r\n            emit MigrationOutHookFailed(\r\n                returnData,\r\n                _hook,\r\n                _vaultProxy,\r\n                _prevFundDeployer,\r\n                _nextFundDeployer,\r\n                _nextVaultAccessor,\r\n                _nextVaultLib\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to return a revert reason string prefix for a given MigrationOutHook\r\n    function __migrationOutHookFailureReasonPrefix(IMigrationHookHandler.MigrationOutHook _hook)\r\n        private\r\n        pure\r\n        returns (string memory failureReasonPrefix_)\r\n    {\r\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreSignal) {\r\n            return \"MigrationOutHook.PreSignal: \";\r\n        }\r\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostSignal) {\r\n            return \"MigrationOutHook.PostSignal: \";\r\n        }\r\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreMigrate) {\r\n            return \"MigrationOutHook.PreMigrate: \";\r\n        }\r\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostMigrate) {\r\n            return \"MigrationOutHook.PostMigrate: \";\r\n        }\r\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostCancel) {\r\n            return \"MigrationOutHook.PostCancel: \";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    // Provides several potentially helpful getters that are not strictly necessary\r\n\r\n    /// @notice Gets the current FundDeployer that is allowed to deploy and migrate funds\r\n    /// @return currentFundDeployer_ The current FundDeployer contract address\r\n    function getCurrentFundDeployer()\r\n        external\r\n        view\r\n        override\r\n        returns (address currentFundDeployer_)\r\n    {\r\n        return currentFundDeployer;\r\n    }\r\n\r\n    /// @notice Gets the FundDeployer with which a given VaultProxy is associated\r\n    /// @param _vaultProxy The VaultProxy instance\r\n    /// @return fundDeployer_ The FundDeployer contract address\r\n    function getFundDeployerForVaultProxy(address _vaultProxy)\r\n        external\r\n        view\r\n        override\r\n        returns (address fundDeployer_)\r\n    {\r\n        return vaultProxyToFundDeployer[_vaultProxy];\r\n    }\r\n\r\n    /// @notice Gets the details of a pending migration request for a given VaultProxy\r\n    /// @param _vaultProxy The VaultProxy instance\r\n    /// @return nextFundDeployer_ The FundDeployer contract address from which the migration\r\n    /// request was made\r\n    /// @return nextVaultAccessor_ The account that will be the next `accessor` on the VaultProxy\r\n    /// @return nextVaultLib_ The next VaultLib library contract address to set on the VaultProxy\r\n    /// @return executableTimestamp_ The timestamp at which the migration request can be executed\r\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            address nextFundDeployer_,\r\n            address nextVaultAccessor_,\r\n            address nextVaultLib_,\r\n            uint256 executableTimestamp_\r\n        )\r\n    {\r\n        MigrationRequest memory r = vaultProxyToMigrationRequest[_vaultProxy];\r\n        if (r.executableTimestamp > 0) {\r\n            return (\r\n                r.nextFundDeployer,\r\n                r.nextVaultAccessor,\r\n                r.nextVaultLib,\r\n                r.executableTimestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the amount of time that must pass between signaling and executing a migration\r\n    /// @return migrationTimelock_ The timelock value (in seconds)\r\n    function getMigrationTimelock() external view override returns (uint256 migrationTimelock_) {\r\n        return migrationTimelock;\r\n    }\r\n\r\n    /// @notice Gets the account that is nominated to be the next owner of this contract\r\n    /// @return nominatedOwner_ The account that is nominated to be the owner\r\n    function getNominatedOwner() external view override returns (address nominatedOwner_) {\r\n        return nominatedOwner;\r\n    }\r\n\r\n    /// @notice Gets the owner of this contract\r\n    /// @return owner_ The account that is the owner\r\n    function getOwner() external view override returns (address owner_) {\r\n        return owner;\r\n    }\r\n\r\n    /// @notice Gets the shares token `symbol` value for use in VaultProxy instances\r\n    /// @return sharesTokenSymbol_ The `symbol` value\r\n    function getSharesTokenSymbol()\r\n        external\r\n        view\r\n        override\r\n        returns (string memory sharesTokenSymbol_)\r\n    {\r\n        return sharesTokenSymbol;\r\n    }\r\n\r\n    /// @notice Gets the time remaining until the migration request of a given VaultProxy can be executed\r\n    /// @param _vaultProxy The VaultProxy instance\r\n    /// @return secondsRemaining_ The number of seconds remaining on the timelock\r\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 secondsRemaining_)\r\n    {\r\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\r\n            .executableTimestamp;\r\n        if (executableTimestamp == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (block.timestamp >= executableTimestamp) {\r\n            return 0;\r\n        }\r\n\r\n        return executableTimestamp - block.timestamp;\r\n    }\r\n\r\n    /// @notice Checks whether a migration request that is executable exists for a given VaultProxy\r\n    /// @param _vaultProxy The VaultProxy instance\r\n    /// @return hasExecutableRequest_ True if a migration request exists and is executable\r\n    function hasExecutableMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        override\r\n        returns (bool hasExecutableRequest_)\r\n    {\r\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\r\n            .executableTimestamp;\r\n\r\n        return executableTimestamp > 0 && block.timestamp >= executableTimestamp;\r\n    }\r\n\r\n    /// @notice Checks whether a migration request exists for a given VaultProxy\r\n    /// @param _vaultProxy The VaultProxy instance\r\n    /// @return hasMigrationRequest_ True if a migration request exists\r\n    function hasMigrationRequest(address _vaultProxy)\r\n        external\r\n        view\r\n        override\r\n        returns (bool hasMigrationRequest_)\r\n    {\r\n        return vaultProxyToMigrationRequest[_vaultProxy].executableTimestamp > 0;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockVaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../persistent/vault/VaultLibBaseCore.sol\";\r\n\r\n/// @title MockVaultLib Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mock VaultLib implementation that only extends VaultLibBaseCore\r\ncontract MockVaultLib is VaultLibBaseCore {\r\n    function getAccessor() external view returns (address) {\r\n        return accessor;\r\n    }\r\n\r\n    function getCreator() external view returns (address) {\r\n        return creator;\r\n    }\r\n\r\n    function getMigrator() external view returns (address) {\r\n        return migrator;\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/AdapterWhitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/PreCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title AdapterWhitelist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that only allows a configurable whitelist of adapters for use by a fund\r\ncontract AdapterWhitelist is PreCallOnIntegrationValidatePolicyBase, AddressListPolicyMixin {\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        __addToList(_comptrollerProxy, abi.decode(_encodedSettings, (address[])));\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ADAPTER_WHITELIST\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _adapter The adapter with which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address _adapter)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        return isInList(_comptrollerProxy, _adapter);\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (address adapter, ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, adapter);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/utils/PreCallOnIntegrationValidatePolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/PolicyBase.sol\";\r\n\r\n/// @title CallOnIntegrationPreValidatePolicyMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract for policies that only implement the PreCallOnIntegration policy hook\r\nabstract contract PreCallOnIntegrationValidatePolicyBase is PolicyBase {\r\n    /// @notice Gets the implemented PolicyHooks for a policy\r\n    /// @return implementedHooks_ The implemented PolicyHooks\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\r\n    {\r\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\r\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PreCallOnIntegration;\r\n\r\n        return implementedHooks_;\r\n    }\r\n\r\n    /// @notice Helper to decode rule arguments\r\n    function __decodeRuleArgs(bytes memory _encodedRuleArgs)\r\n        internal\r\n        pure\r\n        returns (address adapter_, bytes4 selector_)\r\n    {\r\n        return abi.decode(_encodedRuleArgs, (address, bytes4));\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/GuaranteedRedemption.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"./utils/PreCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title GuaranteedRedemption Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that guarantees that shares will either be continuously redeemable or\r\n/// redeemable within a predictable daily window by preventing trading during a configurable daily period\r\ncontract GuaranteedRedemption is PreCallOnIntegrationValidatePolicyBase, FundDeployerOwnerMixin {\r\n    using SafeMath for uint256;\r\n\r\n    event AdapterAdded(address adapter);\r\n\r\n    event AdapterRemoved(address adapter);\r\n\r\n    event FundSettingsSet(\r\n        address indexed comptrollerProxy,\r\n        uint256 startTimestamp,\r\n        uint256 duration\r\n    );\r\n\r\n    event RedemptionWindowBufferSet(uint256 prevBuffer, uint256 nextBuffer);\r\n\r\n    struct RedemptionWindow {\r\n        uint256 startTimestamp;\r\n        uint256 duration;\r\n    }\r\n\r\n    uint256 private constant ONE_DAY = 24 * 60 * 60;\r\n\r\n    mapping(address => bool) private adapterToCanBlockRedemption;\r\n    mapping(address => RedemptionWindow) private comptrollerProxyToRedemptionWindow;\r\n    uint256 private redemptionWindowBuffer;\r\n\r\n    constructor(\r\n        address _policyManager,\r\n        address _fundDeployer,\r\n        uint256 _redemptionWindowBuffer,\r\n        address[] memory _redemptionBlockingAdapters\r\n    ) public PolicyBase(_policyManager) FundDeployerOwnerMixin(_fundDeployer) {\r\n        redemptionWindowBuffer = _redemptionWindowBuffer;\r\n\r\n        __addRedemptionBlockingAdapters(_redemptionBlockingAdapters);\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        (uint256 startTimestamp, uint256 duration) = abi.decode(\r\n            _encodedSettings,\r\n            (uint256, uint256)\r\n        );\r\n\r\n        if (startTimestamp == 0) {\r\n            require(duration == 0, \"addFundSettings: duration must be 0 if startTimestamp is 0\");\r\n            return;\r\n        }\r\n\r\n        // Use 23 hours instead of 1 day to allow up to 1 hr of redemptionWindowBuffer\r\n        require(\r\n            duration > 0 && duration <= 23 hours,\r\n            \"addFundSettings: duration must be between 1 second and 23 hours\"\r\n        );\r\n\r\n        comptrollerProxyToRedemptionWindow[_comptrollerProxy].startTimestamp = startTimestamp;\r\n        comptrollerProxyToRedemptionWindow[_comptrollerProxy].duration = duration;\r\n\r\n        emit FundSettingsSet(_comptrollerProxy, startTimestamp, duration);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"GUARANTEED_REDEMPTION\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _adapter The adapter for which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address _adapter)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        if (!adapterCanBlockRedemption(_adapter)) {\r\n            return true;\r\n        }\r\n\r\n\r\n            RedemptionWindow memory redemptionWindow\r\n         = comptrollerProxyToRedemptionWindow[_comptrollerProxy];\r\n\r\n        // If no RedemptionWindow is set, the fund can never use redemption-blocking adapters\r\n        if (redemptionWindow.startTimestamp == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 latestRedemptionWindowStart = calcLatestRedemptionWindowStart(\r\n            redemptionWindow.startTimestamp\r\n        );\r\n\r\n        // A fund can't trade during its redemption window, nor in the buffer beforehand.\r\n        // The lower bound is only relevant when the startTimestamp is in the future,\r\n        // so we check it last.\r\n        if (\r\n            block.timestamp >= latestRedemptionWindowStart.add(redemptionWindow.duration) ||\r\n            block.timestamp <= latestRedemptionWindowStart.sub(redemptionWindowBuffer)\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @notice Sets a new value for the redemptionWindowBuffer variable\r\n    /// @param _nextRedemptionWindowBuffer The number of seconds for the redemptionWindowBuffer\r\n    /// @dev The redemptionWindowBuffer is added to the beginning of the redemption window,\r\n    /// and should always be >= the longest potential block on redemption amongst all adapters.\r\n    /// (e.g., Synthetix blocks token transfers during a timelock after trading synths)\r\n    function setRedemptionWindowBuffer(uint256 _nextRedemptionWindowBuffer)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        uint256 prevRedemptionWindowBuffer = redemptionWindowBuffer;\r\n        require(\r\n            _nextRedemptionWindowBuffer != prevRedemptionWindowBuffer,\r\n            \"setRedemptionWindowBuffer: Value already set\"\r\n        );\r\n\r\n        redemptionWindowBuffer = _nextRedemptionWindowBuffer;\r\n\r\n        emit RedemptionWindowBufferSet(prevRedemptionWindowBuffer, _nextRedemptionWindowBuffer);\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (address adapter, ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, adapter);\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Calculates the start of the most recent redemption window\r\n    /// @param _startTimestamp The initial startTimestamp for the redemption window\r\n    /// @return latestRedemptionWindowStart_ The starting timestamp of the most recent redemption window\r\n    function calcLatestRedemptionWindowStart(uint256 _startTimestamp)\r\n        public\r\n        view\r\n        returns (uint256 latestRedemptionWindowStart_)\r\n    {\r\n        if (block.timestamp <= _startTimestamp) {\r\n            return _startTimestamp;\r\n        }\r\n\r\n        uint256 timeSinceStartTimestamp = block.timestamp.sub(_startTimestamp);\r\n        uint256 timeSincePeriodStart = timeSinceStartTimestamp.mod(ONE_DAY);\r\n\r\n        return block.timestamp.sub(timeSincePeriodStart);\r\n    }\r\n\r\n    ///////////////////////////////////////////\r\n    // REDEMPTION-BLOCKING ADAPTERS REGISTRY //\r\n    ///////////////////////////////////////////\r\n\r\n    /// @notice Add adapters which can block shares redemption\r\n    /// @param _adapters The addresses of adapters to be added\r\n    function addRedemptionBlockingAdapters(address[] calldata _adapters)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(\r\n            _adapters.length > 0,\r\n            \"__addRedemptionBlockingAdapters: _adapters cannot be empty\"\r\n        );\r\n\r\n        __addRedemptionBlockingAdapters(_adapters);\r\n    }\r\n\r\n    /// @notice Remove adapters which can block shares redemption\r\n    /// @param _adapters The addresses of adapters to be removed\r\n    function removeRedemptionBlockingAdapters(address[] calldata _adapters)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(\r\n            _adapters.length > 0,\r\n            \"removeRedemptionBlockingAdapters: _adapters cannot be empty\"\r\n        );\r\n\r\n        for (uint256 i; i < _adapters.length; i++) {\r\n            require(\r\n                adapterCanBlockRedemption(_adapters[i]),\r\n                \"removeRedemptionBlockingAdapters: adapter is not added\"\r\n            );\r\n\r\n            adapterToCanBlockRedemption[_adapters[i]] = false;\r\n\r\n            emit AdapterRemoved(_adapters[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to mark adapters that can block shares redemption\r\n    function __addRedemptionBlockingAdapters(address[] memory _adapters) private {\r\n        for (uint256 i; i < _adapters.length; i++) {\r\n            require(\r\n                _adapters[i] != address(0),\r\n                \"__addRedemptionBlockingAdapters: adapter cannot be empty\"\r\n            );\r\n            require(\r\n                !adapterCanBlockRedemption(_adapters[i]),\r\n                \"__addRedemptionBlockingAdapters: adapter already added\"\r\n            );\r\n\r\n            adapterToCanBlockRedemption[_adapters[i]] = true;\r\n\r\n            emit AdapterAdded(_adapters[i]);\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `redemptionWindowBuffer` variable\r\n    /// @return redemptionWindowBuffer_ The `redemptionWindowBuffer` variable value\r\n    function getRedemptionWindowBuffer() external view returns (uint256 redemptionWindowBuffer_) {\r\n        return redemptionWindowBuffer;\r\n    }\r\n\r\n    /// @notice Gets the RedemptionWindow settings for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return redemptionWindow_ The RedemptionWindow settings\r\n    function getRedemptionWindowForFund(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (RedemptionWindow memory redemptionWindow_)\r\n    {\r\n        return comptrollerProxyToRedemptionWindow[_comptrollerProxy];\r\n    }\r\n\r\n    /// @notice Checks whether an adapter can block shares redemption\r\n    /// @param _adapter The address of the adapter to check\r\n    /// @return canBlockRedemption_ True if the adapter can block shares redemption\r\n    function adapterCanBlockRedemption(address _adapter)\r\n        public\r\n        view\r\n        returns (bool canBlockRedemption_)\r\n    {\r\n        return adapterToCanBlockRedemption[_adapter];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/call-on-integration/AdapterBlacklist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/PreCallOnIntegrationValidatePolicyBase.sol\";\r\n\r\n/// @title AdapterBlacklist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that disallows a configurable blacklist of adapters from use by a fund\r\ncontract AdapterBlacklist is PreCallOnIntegrationValidatePolicyBase, AddressListPolicyMixin {\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Add the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        __addToList(_comptrollerProxy, abi.decode(_encodedSettings, (address[])));\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ADAPTER_BLACKLIST\";\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _adapter The adapter with which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address _adapter)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        return !isInList(_comptrollerProxy, _adapter);\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (address adapter, ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, adapter);\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/buy-shares/InvestorWhitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/PreBuySharesValidatePolicyBase.sol\";\r\n\r\n/// @title InvestorWhitelist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that only allows a configurable whitelist of investors to buy shares in a fund\r\ncontract InvestorWhitelist is PreBuySharesValidatePolicyBase, AddressListPolicyMixin {\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Adds the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        __updateList(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"INVESTOR_WHITELIST\";\r\n    }\r\n\r\n    /// @notice Updates the policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function updateFundSettings(\r\n        address _comptrollerProxy,\r\n        address,\r\n        bytes calldata _encodedSettings\r\n    ) external override onlyPolicyManager {\r\n        __updateList(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _investor The investor for which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address _investor)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        return isInList(_comptrollerProxy, _investor);\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (address buyer, , , ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, buyer);\r\n    }\r\n\r\n    /// @dev Helper to update the investor whitelist by adding and/or removing addresses\r\n    function __updateList(address _comptrollerProxy, bytes memory _settingsData) private {\r\n        (address[] memory itemsToAdd, address[] memory itemsToRemove) = abi.decode(\r\n            _settingsData,\r\n            (address[], address[])\r\n        );\r\n\r\n        // If an address is in both add and remove arrays, they will not be in the final list.\r\n        // We do not check for uniqueness between the two arrays for efficiency.\r\n        if (itemsToAdd.length > 0) {\r\n            __addToList(_comptrollerProxy, itemsToAdd);\r\n        }\r\n        if (itemsToRemove.length > 0) {\r\n            __removeFromList(_comptrollerProxy, itemsToRemove);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/buy-shares/utils/PreBuySharesValidatePolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/PolicyBase.sol\";\r\n\r\n/// @title BuySharesPolicyMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract for policies that only implement the PreBuyShares policy hook\r\nabstract contract PreBuySharesValidatePolicyBase is PolicyBase {\r\n    /// @notice Gets the implemented PolicyHooks for a policy\r\n    /// @return implementedHooks_ The implemented PolicyHooks\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\r\n    {\r\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\r\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PreBuyShares;\r\n\r\n        return implementedHooks_;\r\n    }\r\n\r\n    /// @notice Helper to decode rule arguments\r\n    function __decodeRuleArgs(bytes memory _encodedArgs)\r\n        internal\r\n        pure\r\n        returns (\r\n            address buyer_,\r\n            uint256 investmentAmount_,\r\n            uint256 minSharesQuantity_,\r\n            uint256 gav_\r\n        )\r\n    {\r\n        return abi.decode(_encodedArgs, (address, uint256, uint256, uint256));\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/buy-shares/MinMaxInvestment.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./utils/PreBuySharesValidatePolicyBase.sol\";\r\n\r\n/// @title MinMaxInvestment Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that restricts the amount of the fund's denomination asset that a user can\r\n/// send in a single call to buy shares in a fund\r\ncontract MinMaxInvestment is PreBuySharesValidatePolicyBase {\r\n    event FundSettingsSet(\r\n        address indexed comptrollerProxy,\r\n        uint256 minInvestmentAmount,\r\n        uint256 maxInvestmentAmount\r\n    );\r\n\r\n    struct FundSettings {\r\n        uint256 minInvestmentAmount;\r\n        uint256 maxInvestmentAmount;\r\n    }\r\n\r\n    mapping(address => FundSettings) private comptrollerProxyToFundSettings;\r\n\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Adds the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        __setFundSettings(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"MIN_MAX_INVESTMENT\";\r\n    }\r\n\r\n    /// @notice Updates the policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function updateFundSettings(\r\n        address _comptrollerProxy,\r\n        address,\r\n        bytes calldata _encodedSettings\r\n    ) external override onlyPolicyManager {\r\n        __setFundSettings(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _investmentAmount The investment amount for which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, uint256 _investmentAmount)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        uint256 minInvestmentAmount = comptrollerProxyToFundSettings[_comptrollerProxy]\r\n            .minInvestmentAmount;\r\n        uint256 maxInvestmentAmount = comptrollerProxyToFundSettings[_comptrollerProxy]\r\n            .maxInvestmentAmount;\r\n\r\n        // Both minInvestmentAmount and maxInvestmentAmount can be 0 in order to close the fund\r\n        // temporarily\r\n        if (minInvestmentAmount == 0) {\r\n            return _investmentAmount <= maxInvestmentAmount;\r\n        } else if (maxInvestmentAmount == 0) {\r\n            return _investmentAmount >= minInvestmentAmount;\r\n        }\r\n        return\r\n            _investmentAmount >= minInvestmentAmount && _investmentAmount <= maxInvestmentAmount;\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (, uint256 investmentAmount, , ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, investmentAmount);\r\n    }\r\n\r\n    /// @dev Helper to set the policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function __setFundSettings(address _comptrollerProxy, bytes memory _encodedSettings) private {\r\n        (uint256 minInvestmentAmount, uint256 maxInvestmentAmount) = abi.decode(\r\n            _encodedSettings,\r\n            (uint256, uint256)\r\n        );\r\n\r\n        require(\r\n            maxInvestmentAmount == 0 || minInvestmentAmount < maxInvestmentAmount,\r\n            \"__setFundSettings: minInvestmentAmount must be less than maxInvestmentAmount\"\r\n        );\r\n\r\n        comptrollerProxyToFundSettings[_comptrollerProxy]\r\n            .minInvestmentAmount = minInvestmentAmount;\r\n        comptrollerProxyToFundSettings[_comptrollerProxy]\r\n            .maxInvestmentAmount = maxInvestmentAmount;\r\n\r\n        emit FundSettingsSet(_comptrollerProxy, minInvestmentAmount, maxInvestmentAmount);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the min and max investment amount for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @return fundSettings_ The fund settings\r\n    function getFundSettings(address _comptrollerProxy)\r\n        external\r\n        view\r\n        returns (FundSettings memory fundSettings_)\r\n    {\r\n        return comptrollerProxyToFundSettings[_comptrollerProxy];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/IntegrationManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"../../core/fund/vault/IVault.sol\";\r\nimport \"../../infrastructure/price-feeds/derivatives/IDerivativePriceFeed.sol\";\r\nimport \"../../infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol\";\r\nimport \"../../utils/AddressArrayLib.sol\";\r\nimport \"../policy-manager/IPolicyManager.sol\";\r\nimport \"../utils/ExtensionBase.sol\";\r\nimport \"../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../utils/PermissionedVaultActionMixin.sol\";\r\nimport \"./integrations/IIntegrationAdapter.sol\";\r\nimport \"./IIntegrationManager.sol\";\r\n\r\n/// @title IntegrationManager\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Extension to handle DeFi integration actions for funds\r\ncontract IntegrationManager is\r\n    IIntegrationManager,\r\n    ExtensionBase,\r\n    FundDeployerOwnerMixin,\r\n    PermissionedVaultActionMixin\r\n{\r\n    using AddressArrayLib for address[];\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using SafeMath for uint256;\r\n\r\n    event AdapterDeregistered(address indexed adapter, string indexed identifier);\r\n\r\n    event AdapterRegistered(address indexed adapter, string indexed identifier);\r\n\r\n    event AuthUserAddedForFund(address indexed comptrollerProxy, address indexed account);\r\n\r\n    event AuthUserRemovedForFund(address indexed comptrollerProxy, address indexed account);\r\n\r\n    event CallOnIntegrationExecutedForFund(\r\n        address indexed comptrollerProxy,\r\n        address vaultProxy,\r\n        address caller,\r\n        address indexed adapter,\r\n        bytes4 indexed selector,\r\n        bytes integrationData,\r\n        address[] incomingAssets,\r\n        uint256[] incomingAssetAmounts,\r\n        address[] outgoingAssets,\r\n        uint256[] outgoingAssetAmounts\r\n    );\r\n\r\n    address private immutable DERIVATIVE_PRICE_FEED;\r\n    address private immutable POLICY_MANAGER;\r\n    address private immutable PRIMITIVE_PRICE_FEED;\r\n\r\n    EnumerableSet.AddressSet private registeredAdapters;\r\n\r\n    mapping(address => mapping(address => bool)) private comptrollerProxyToAcctToIsAuthUser;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address _policyManager,\r\n        address _derivativePriceFeed,\r\n        address _primitivePriceFeed\r\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\r\n        DERIVATIVE_PRICE_FEED = _derivativePriceFeed;\r\n        POLICY_MANAGER = _policyManager;\r\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\r\n    }\r\n\r\n    /////////////\r\n    // GENERAL //\r\n    /////////////\r\n\r\n    /// @notice Activates the extension by storing the VaultProxy\r\n    function activateForFund(bool) external override {\r\n        __setValidatedVaultProxy(msg.sender);\r\n    }\r\n\r\n    /// @notice Authorizes a user to act on behalf of a fund via the IntegrationManager\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _who The user to authorize\r\n    function addAuthUserForFund(address _comptrollerProxy, address _who) external {\r\n        __validateSetAuthUser(_comptrollerProxy, _who, true);\r\n\r\n        comptrollerProxyToAcctToIsAuthUser[_comptrollerProxy][_who] = true;\r\n\r\n        emit AuthUserAddedForFund(_comptrollerProxy, _who);\r\n    }\r\n\r\n    /// @notice Deactivate the extension by destroying storage\r\n    function deactivateForFund() external override {\r\n        delete comptrollerProxyToVaultProxy[msg.sender];\r\n    }\r\n\r\n    /// @notice Removes an authorized user from the IntegrationManager for the given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _who The authorized user to remove\r\n    function removeAuthUserForFund(address _comptrollerProxy, address _who) external {\r\n        __validateSetAuthUser(_comptrollerProxy, _who, false);\r\n\r\n        comptrollerProxyToAcctToIsAuthUser[_comptrollerProxy][_who] = false;\r\n\r\n        emit AuthUserRemovedForFund(_comptrollerProxy, _who);\r\n    }\r\n\r\n    /// @notice Checks whether an account is an authorized IntegrationManager user for a given fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _who The account to check\r\n    /// @return isAuthUser_ True if the account is an authorized user or the fund owner\r\n    function isAuthUserForFund(address _comptrollerProxy, address _who)\r\n        public\r\n        view\r\n        returns (bool isAuthUser_)\r\n    {\r\n        return\r\n            comptrollerProxyToAcctToIsAuthUser[_comptrollerProxy][_who] ||\r\n            _who == IVault(comptrollerProxyToVaultProxy[_comptrollerProxy]).getOwner();\r\n    }\r\n\r\n    /// @dev Helper to validate calls to update comptrollerProxyToAcctToIsAuthUser\r\n    function __validateSetAuthUser(\r\n        address _comptrollerProxy,\r\n        address _who,\r\n        bool _nextIsAuthUser\r\n    ) private view {\r\n        require(\r\n            comptrollerProxyToVaultProxy[_comptrollerProxy] != address(0),\r\n            \"__validateSetAuthUser: Fund has not been activated\"\r\n        );\r\n\r\n        address fundOwner = IVault(comptrollerProxyToVaultProxy[_comptrollerProxy]).getOwner();\r\n        require(\r\n            msg.sender == fundOwner,\r\n            \"__validateSetAuthUser: Only the fund owner can call this function\"\r\n        );\r\n        require(_who != fundOwner, \"__validateSetAuthUser: Cannot set for the fund owner\");\r\n\r\n        if (_nextIsAuthUser) {\r\n            require(\r\n                !comptrollerProxyToAcctToIsAuthUser[_comptrollerProxy][_who],\r\n                \"__validateSetAuthUser: Account is already an authorized user\"\r\n            );\r\n        } else {\r\n            require(\r\n                comptrollerProxyToAcctToIsAuthUser[_comptrollerProxy][_who],\r\n                \"__validateSetAuthUser: Account is not an authorized user\"\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////\r\n    // CALL-ON-EXTENSION ACTIONS //\r\n    ///////////////////////////////\r\n\r\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\r\n    /// @param _caller The user who called for this action\r\n    /// @param _actionId An ID representing the desired action\r\n    /// @param _callArgs The encoded args for the action\r\n    function receiveCallFromComptroller(\r\n        address _caller,\r\n        uint256 _actionId,\r\n        bytes calldata _callArgs\r\n    ) external override {\r\n        // Since we validate and store the ComptrollerProxy-VaultProxy pairing during\r\n        // activateForFund(), this function does not require further validation of the\r\n        // sending ComptrollerProxy\r\n        address vaultProxy = comptrollerProxyToVaultProxy[msg.sender];\r\n        require(vaultProxy != address(0), \"receiveCallFromComptroller: Fund is not active\");\r\n        require(\r\n            isAuthUserForFund(msg.sender, _caller),\r\n            \"receiveCallFromComptroller: Not an authorized user\"\r\n        );\r\n\r\n        // Dispatch the action\r\n        if (_actionId == 0) {\r\n            __callOnIntegration(_caller, vaultProxy, _callArgs);\r\n        } else if (_actionId == 1) {\r\n            __addZeroBalanceTrackedAssets(vaultProxy, _callArgs);\r\n        } else if (_actionId == 2) {\r\n            __removeZeroBalanceTrackedAssets(vaultProxy, _callArgs);\r\n        } else {\r\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\r\n        }\r\n    }\r\n\r\n    /// @dev Adds assets with a zero balance as tracked assets of the fund\r\n    function __addZeroBalanceTrackedAssets(address _vaultProxy, bytes memory _callArgs) private {\r\n        address[] memory assets = abi.decode(_callArgs, (address[]));\r\n        for (uint256 i; i < assets.length; i++) {\r\n            require(\r\n                __isSupportedAsset(assets[i]),\r\n                \"__addZeroBalanceTrackedAssets: Unsupported asset\"\r\n            );\r\n            require(\r\n                ERC20(assets[i]).balanceOf(_vaultProxy) == 0,\r\n                \"__addZeroBalanceTrackedAssets: Balance is not zero\"\r\n            );\r\n\r\n            __addTrackedAsset(msg.sender, assets[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Removes assets with a zero balance from tracked assets of the fund\r\n    function __removeZeroBalanceTrackedAssets(address _vaultProxy, bytes memory _callArgs)\r\n        private\r\n    {\r\n        address[] memory assets = abi.decode(_callArgs, (address[]));\r\n        address denominationAsset = IComptroller(msg.sender).getDenominationAsset();\r\n        for (uint256 i; i < assets.length; i++) {\r\n            require(\r\n                assets[i] != denominationAsset,\r\n                \"__removeZeroBalanceTrackedAssets: Cannot remove denomination asset\"\r\n            );\r\n            require(\r\n                ERC20(assets[i]).balanceOf(_vaultProxy) == 0,\r\n                \"__removeZeroBalanceTrackedAssets: Balance is not zero\"\r\n            );\r\n\r\n            __removeTrackedAsset(msg.sender, assets[i]);\r\n        }\r\n    }\r\n\r\n    /////////////////////////\r\n    // CALL ON INTEGRATION //\r\n    /////////////////////////\r\n\r\n    /// @notice Universal method for calling third party contract functions through adapters\r\n    /// @param _caller The caller of this function via the ComptrollerProxy\r\n    /// @param _vaultProxy The VaultProxy of the fund\r\n    /// @param _callArgs The encoded args for this function\r\n    /// - _adapter Adapter of the integration on which to execute a call\r\n    /// - _selector Method selector of the adapter method to execute\r\n    /// - _integrationData Encoded arguments specific to the adapter\r\n    /// @dev msg.sender is the ComptrollerProxy.\r\n    /// Refer to specific adapter to see how to encode its arguments.\r\n    function __callOnIntegration(\r\n        address _caller,\r\n        address _vaultProxy,\r\n        bytes memory _callArgs\r\n    ) private {\r\n        (\r\n            address adapter,\r\n            bytes4 selector,\r\n            bytes memory integrationData\r\n        ) = __decodeCallOnIntegrationArgs(_callArgs);\r\n\r\n        __preCoIHook(adapter, selector);\r\n\r\n        /// Passing decoded _callArgs leads to stack-too-deep error\r\n        (\r\n            address[] memory incomingAssets,\r\n            uint256[] memory incomingAssetAmounts,\r\n            address[] memory outgoingAssets,\r\n            uint256[] memory outgoingAssetAmounts\r\n        ) = __callOnIntegrationInner(_vaultProxy, _callArgs);\r\n\r\n        __postCoIHook(\r\n            adapter,\r\n            selector,\r\n            incomingAssets,\r\n            incomingAssetAmounts,\r\n            outgoingAssets,\r\n            outgoingAssetAmounts\r\n        );\r\n\r\n        __emitCoIEvent(\r\n            _vaultProxy,\r\n            _caller,\r\n            adapter,\r\n            selector,\r\n            integrationData,\r\n            incomingAssets,\r\n            incomingAssetAmounts,\r\n            outgoingAssets,\r\n            outgoingAssetAmounts\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to execute the bulk of logic of callOnIntegration.\r\n    /// Avoids the stack-too-deep-error.\r\n    function __callOnIntegrationInner(address vaultProxy, bytes memory _callArgs)\r\n        private\r\n        returns (\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory incomingAssetAmounts_,\r\n            address[] memory outgoingAssets_,\r\n            uint256[] memory outgoingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            address[] memory expectedIncomingAssets,\r\n            uint256[] memory preCallIncomingAssetBalances,\r\n            uint256[] memory minIncomingAssetAmounts,\r\n            SpendAssetsHandleType spendAssetsHandleType,\r\n            address[] memory spendAssets,\r\n            uint256[] memory maxSpendAssetAmounts,\r\n            uint256[] memory preCallSpendAssetBalances\r\n        ) = __preProcessCoI(vaultProxy, _callArgs);\r\n\r\n        __executeCoI(\r\n            vaultProxy,\r\n            _callArgs,\r\n            abi.encode(\r\n                spendAssetsHandleType,\r\n                spendAssets,\r\n                maxSpendAssetAmounts,\r\n                expectedIncomingAssets\r\n            )\r\n        );\r\n\r\n        (\r\n            incomingAssets_,\r\n            incomingAssetAmounts_,\r\n            outgoingAssets_,\r\n            outgoingAssetAmounts_\r\n        ) = __postProcessCoI(\r\n            vaultProxy,\r\n            expectedIncomingAssets,\r\n            preCallIncomingAssetBalances,\r\n            minIncomingAssetAmounts,\r\n            spendAssetsHandleType,\r\n            spendAssets,\r\n            maxSpendAssetAmounts,\r\n            preCallSpendAssetBalances\r\n        );\r\n\r\n        return (incomingAssets_, incomingAssetAmounts_, outgoingAssets_, outgoingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper to decode CoI args\r\n    function __decodeCallOnIntegrationArgs(bytes memory _callArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            address adapter_,\r\n            bytes4 selector_,\r\n            bytes memory integrationData_\r\n        )\r\n    {\r\n        return abi.decode(_callArgs, (address, bytes4, bytes));\r\n    }\r\n\r\n    /// @dev Helper to emit the CallOnIntegrationExecuted event.\r\n    /// Avoids stack-too-deep error.\r\n    function __emitCoIEvent(\r\n        address _vaultProxy,\r\n        address _caller,\r\n        address _adapter,\r\n        bytes4 _selector,\r\n        bytes memory _integrationData,\r\n        address[] memory _incomingAssets,\r\n        uint256[] memory _incomingAssetAmounts,\r\n        address[] memory _outgoingAssets,\r\n        uint256[] memory _outgoingAssetAmounts\r\n    ) private {\r\n        emit CallOnIntegrationExecutedForFund(\r\n            msg.sender,\r\n            _vaultProxy,\r\n            _caller,\r\n            _adapter,\r\n            _selector,\r\n            _integrationData,\r\n            _incomingAssets,\r\n            _incomingAssetAmounts,\r\n            _outgoingAssets,\r\n            _outgoingAssetAmounts\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to execute a call to an integration\r\n    /// @dev Avoids stack-too-deep error\r\n    function __executeCoI(\r\n        address _vaultProxy,\r\n        bytes memory _callArgs,\r\n        bytes memory _encodedAssetTransferArgs\r\n    ) private {\r\n        (\r\n            address adapter,\r\n            bytes4 selector,\r\n            bytes memory integrationData\r\n        ) = __decodeCallOnIntegrationArgs(_callArgs);\r\n\r\n        (bool success, bytes memory returnData) = adapter.call(\r\n            abi.encodeWithSelector(\r\n                selector,\r\n                _vaultProxy,\r\n                integrationData,\r\n                _encodedAssetTransferArgs\r\n            )\r\n        );\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    /// @dev Helper to get the vault's balance of a particular asset\r\n    function __getVaultAssetBalance(address _vaultProxy, address _asset)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ERC20(_asset).balanceOf(_vaultProxy);\r\n    }\r\n\r\n    /// @dev Helper to check if an asset is supported\r\n    function __isSupportedAsset(address _asset) private view returns (bool isSupported_) {\r\n        return\r\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_asset) ||\r\n            IDerivativePriceFeed(DERIVATIVE_PRICE_FEED).isSupportedAsset(_asset);\r\n    }\r\n\r\n    /// @dev Helper for the actions to take on external contracts prior to executing CoI\r\n    function __preCoIHook(address _adapter, bytes4 _selector) private {\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            msg.sender,\r\n            IPolicyManager.PolicyHook.PreCallOnIntegration,\r\n            abi.encode(_adapter, _selector)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper for the internal actions to take prior to executing CoI\r\n    function __preProcessCoI(address _vaultProxy, bytes memory _callArgs)\r\n        private\r\n        returns (\r\n            address[] memory expectedIncomingAssets_,\r\n            uint256[] memory preCallIncomingAssetBalances_,\r\n            uint256[] memory minIncomingAssetAmounts_,\r\n            SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory maxSpendAssetAmounts_,\r\n            uint256[] memory preCallSpendAssetBalances_\r\n        )\r\n    {\r\n        (\r\n            address adapter,\r\n            bytes4 selector,\r\n            bytes memory integrationData\r\n        ) = __decodeCallOnIntegrationArgs(_callArgs);\r\n\r\n        require(adapterIsRegistered(adapter), \"callOnIntegration: Adapter is not registered\");\r\n\r\n        // Note that expected incoming and spend assets are allowed to overlap\r\n        // (e.g., a fee for the incomingAsset charged in a spend asset)\r\n        (\r\n            spendAssetsHandleType_,\r\n            spendAssets_,\r\n            maxSpendAssetAmounts_,\r\n            expectedIncomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        ) = IIntegrationAdapter(adapter).parseAssetsForMethod(selector, integrationData);\r\n        require(\r\n            spendAssets_.length == maxSpendAssetAmounts_.length,\r\n            \"__preProcessCoI: Spend assets arrays unequal\"\r\n        );\r\n        require(\r\n            expectedIncomingAssets_.length == minIncomingAssetAmounts_.length,\r\n            \"__preProcessCoI: Incoming assets arrays unequal\"\r\n        );\r\n        require(spendAssets_.isUniqueSet(), \"__preProcessCoI: Duplicate spend asset\");\r\n        require(\r\n            expectedIncomingAssets_.isUniqueSet(),\r\n            \"__preProcessCoI: Duplicate incoming asset\"\r\n        );\r\n\r\n        IVault vaultProxyContract = IVault(_vaultProxy);\r\n\r\n        preCallIncomingAssetBalances_ = new uint256[](expectedIncomingAssets_.length);\r\n        for (uint256 i = 0; i < expectedIncomingAssets_.length; i++) {\r\n            require(\r\n                expectedIncomingAssets_[i] != address(0),\r\n                \"__preProcessCoI: Empty incoming asset address\"\r\n            );\r\n            require(\r\n                minIncomingAssetAmounts_[i] > 0,\r\n                \"__preProcessCoI: minIncomingAssetAmount must be >0\"\r\n            );\r\n            require(\r\n                __isSupportedAsset(expectedIncomingAssets_[i]),\r\n                \"__preProcessCoI: Non-receivable incoming asset\"\r\n            );\r\n\r\n            // Get pre-call balance of each incoming asset.\r\n            // If the asset is not tracked by the fund, allow the balance to default to 0.\r\n            if (vaultProxyContract.isTrackedAsset(expectedIncomingAssets_[i])) {\r\n                preCallIncomingAssetBalances_[i] = ERC20(expectedIncomingAssets_[i]).balanceOf(\r\n                    _vaultProxy\r\n                );\r\n            }\r\n        }\r\n\r\n        // Get pre-call balances of spend assets and grant approvals to adapter\r\n        preCallSpendAssetBalances_ = new uint256[](spendAssets_.length);\r\n        for (uint256 i = 0; i < spendAssets_.length; i++) {\r\n            require(spendAssets_[i] != address(0), \"__preProcessCoI: Empty spend asset\");\r\n            require(maxSpendAssetAmounts_[i] > 0, \"__preProcessCoI: Empty max spend asset amount\");\r\n\r\n            // If spend asset is also an incoming asset, no need to record its balance\r\n            if (!expectedIncomingAssets_.contains(spendAssets_[i])) {\r\n                preCallSpendAssetBalances_[i] = ERC20(spendAssets_[i]).balanceOf(_vaultProxy);\r\n            }\r\n\r\n            // Grant spend assets access to the adapter.\r\n            // Note that spendAssets_ is already asserted to a unique set.\r\n            if (spendAssetsHandleType_ == SpendAssetsHandleType.Approve) {\r\n                // Use exact approve amount rather than increasing allowances,\r\n                // because all adapters finish their actions atomically.\r\n                __approveAssetSpender(\r\n                    msg.sender,\r\n                    spendAssets_[i],\r\n                    adapter,\r\n                    maxSpendAssetAmounts_[i]\r\n                );\r\n            } else if (spendAssetsHandleType_ == SpendAssetsHandleType.Transfer) {\r\n                __withdrawAssetTo(msg.sender, spendAssets_[i], adapter, maxSpendAssetAmounts_[i]);\r\n            } else if (spendAssetsHandleType_ == SpendAssetsHandleType.Remove) {\r\n                __removeTrackedAsset(msg.sender, spendAssets_[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Helper for the actions to take on external contracts after executing CoI\r\n    function __postCoIHook(\r\n        address _adapter,\r\n        bytes4 _selector,\r\n        address[] memory _incomingAssets,\r\n        uint256[] memory _incomingAssetAmounts,\r\n        address[] memory _outgoingAssets,\r\n        uint256[] memory _outgoingAssetAmounts\r\n    ) private {\r\n        IPolicyManager(POLICY_MANAGER).validatePolicies(\r\n            msg.sender,\r\n            IPolicyManager.PolicyHook.PostCallOnIntegration,\r\n            abi.encode(\r\n                _adapter,\r\n                _selector,\r\n                _incomingAssets,\r\n                _incomingAssetAmounts,\r\n                _outgoingAssets,\r\n                _outgoingAssetAmounts\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to reconcile and format incoming and outgoing assets after executing CoI\r\n    function __postProcessCoI(\r\n        address _vaultProxy,\r\n        address[] memory _expectedIncomingAssets,\r\n        uint256[] memory _preCallIncomingAssetBalances,\r\n        uint256[] memory _minIncomingAssetAmounts,\r\n        SpendAssetsHandleType _spendAssetsHandleType,\r\n        address[] memory _spendAssets,\r\n        uint256[] memory _maxSpendAssetAmounts,\r\n        uint256[] memory _preCallSpendAssetBalances\r\n    )\r\n        private\r\n        returns (\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory incomingAssetAmounts_,\r\n            address[] memory outgoingAssets_,\r\n            uint256[] memory outgoingAssetAmounts_\r\n        )\r\n    {\r\n        address[] memory increasedSpendAssets;\r\n        uint256[] memory increasedSpendAssetAmounts;\r\n        (\r\n            outgoingAssets_,\r\n            outgoingAssetAmounts_,\r\n            increasedSpendAssets,\r\n            increasedSpendAssetAmounts\r\n        ) = __reconcileCoISpendAssets(\r\n            _vaultProxy,\r\n            _spendAssetsHandleType,\r\n            _spendAssets,\r\n            _maxSpendAssetAmounts,\r\n            _preCallSpendAssetBalances\r\n        );\r\n\r\n        (incomingAssets_, incomingAssetAmounts_) = __reconcileCoIIncomingAssets(\r\n            _vaultProxy,\r\n            _expectedIncomingAssets,\r\n            _preCallIncomingAssetBalances,\r\n            _minIncomingAssetAmounts,\r\n            increasedSpendAssets,\r\n            increasedSpendAssetAmounts\r\n        );\r\n\r\n        return (incomingAssets_, incomingAssetAmounts_, outgoingAssets_, outgoingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper to process incoming asset balance changes.\r\n    /// See __reconcileCoISpendAssets() for explanation on \"increasedSpendAssets\".\r\n    function __reconcileCoIIncomingAssets(\r\n        address _vaultProxy,\r\n        address[] memory _expectedIncomingAssets,\r\n        uint256[] memory _preCallIncomingAssetBalances,\r\n        uint256[] memory _minIncomingAssetAmounts,\r\n        address[] memory _increasedSpendAssets,\r\n        uint256[] memory _increasedSpendAssetAmounts\r\n    ) private returns (address[] memory incomingAssets_, uint256[] memory incomingAssetAmounts_) {\r\n        // Incoming assets = expected incoming assets + spend assets with increased balances\r\n        uint256 incomingAssetsCount = _expectedIncomingAssets.length.add(\r\n            _increasedSpendAssets.length\r\n        );\r\n\r\n        // Calculate and validate incoming asset amounts\r\n        incomingAssets_ = new address[](incomingAssetsCount);\r\n        incomingAssetAmounts_ = new uint256[](incomingAssetsCount);\r\n        for (uint256 i = 0; i < _expectedIncomingAssets.length; i++) {\r\n            uint256 balanceDiff = __getVaultAssetBalance(_vaultProxy, _expectedIncomingAssets[i])\r\n                .sub(_preCallIncomingAssetBalances[i]);\r\n            require(\r\n                balanceDiff >= _minIncomingAssetAmounts[i],\r\n                \"__reconcileCoIAssets: Received incoming asset less than expected\"\r\n            );\r\n\r\n            // Even if the asset's previous balance was >0, it might not have been tracked\r\n            __addTrackedAsset(msg.sender, _expectedIncomingAssets[i]);\r\n\r\n            incomingAssets_[i] = _expectedIncomingAssets[i];\r\n            incomingAssetAmounts_[i] = balanceDiff;\r\n        }\r\n\r\n        // Append increaseSpendAssets to incomingAsset vars\r\n        if (_increasedSpendAssets.length > 0) {\r\n            uint256 incomingAssetIndex = _expectedIncomingAssets.length;\r\n            for (uint256 i = 0; i < _increasedSpendAssets.length; i++) {\r\n                incomingAssets_[incomingAssetIndex] = _increasedSpendAssets[i];\r\n                incomingAssetAmounts_[incomingAssetIndex] = _increasedSpendAssetAmounts[i];\r\n                incomingAssetIndex++;\r\n            }\r\n        }\r\n\r\n        return (incomingAssets_, incomingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper to process spend asset balance changes.\r\n    /// \"outgoingAssets\" are the spend assets with a decrease in balance.\r\n    /// \"increasedSpendAssets\" are the spend assets with an unexpected increase in balance.\r\n    /// For example, \"increasedSpendAssets\" can occur if an adapter has a pre-balance of\r\n    /// the spendAsset, which would be transferred to the fund at the end of the tx.\r\n    function __reconcileCoISpendAssets(\r\n        address _vaultProxy,\r\n        SpendAssetsHandleType _spendAssetsHandleType,\r\n        address[] memory _spendAssets,\r\n        uint256[] memory _maxSpendAssetAmounts,\r\n        uint256[] memory _preCallSpendAssetBalances\r\n    )\r\n        private\r\n        returns (\r\n            address[] memory outgoingAssets_,\r\n            uint256[] memory outgoingAssetAmounts_,\r\n            address[] memory increasedSpendAssets_,\r\n            uint256[] memory increasedSpendAssetAmounts_\r\n        )\r\n    {\r\n        // Determine spend asset balance changes\r\n        uint256[] memory postCallSpendAssetBalances = new uint256[](_spendAssets.length);\r\n        uint256 outgoingAssetsCount;\r\n        uint256 increasedSpendAssetsCount;\r\n        for (uint256 i = 0; i < _spendAssets.length; i++) {\r\n            // If spend asset's initial balance is 0, then it is an incoming asset\r\n            if (_preCallSpendAssetBalances[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            // Handle SpendAssetsHandleType.Remove separately\r\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\r\n                outgoingAssetsCount++;\r\n                continue;\r\n            }\r\n\r\n            // Determine if the asset is outgoing or incoming, and store the post-balance for later use\r\n            postCallSpendAssetBalances[i] = __getVaultAssetBalance(_vaultProxy, _spendAssets[i]);\r\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\r\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\r\n                outgoingAssetsCount++;\r\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\r\n                increasedSpendAssetsCount++;\r\n            }\r\n        }\r\n\r\n        // Format outgoingAssets and increasedSpendAssets (spend assets with unexpected increase in balance)\r\n        outgoingAssets_ = new address[](outgoingAssetsCount);\r\n        outgoingAssetAmounts_ = new uint256[](outgoingAssetsCount);\r\n        increasedSpendAssets_ = new address[](increasedSpendAssetsCount);\r\n        increasedSpendAssetAmounts_ = new uint256[](increasedSpendAssetsCount);\r\n        uint256 outgoingAssetsIndex;\r\n        uint256 increasedSpendAssetsIndex;\r\n        for (uint256 i = 0; i < _spendAssets.length; i++) {\r\n            // If spend asset's initial balance is 0, then it is an incoming asset.\r\n            if (_preCallSpendAssetBalances[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            // Handle SpendAssetsHandleType.Remove separately.\r\n            // No need to validate the max spend asset amount.\r\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\r\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\r\n                outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\r\n                outgoingAssetsIndex++;\r\n                continue;\r\n            }\r\n\r\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\r\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\r\n                if (postCallSpendAssetBalances[i] == 0) {\r\n                    __removeTrackedAsset(msg.sender, _spendAssets[i]);\r\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\r\n                } else {\r\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i].sub(\r\n                        postCallSpendAssetBalances[i]\r\n                    );\r\n                }\r\n                require(\r\n                    outgoingAssetAmounts_[outgoingAssetsIndex] <= _maxSpendAssetAmounts[i],\r\n                    \"__reconcileCoISpendAssets: Spent amount greater than expected\"\r\n                );\r\n\r\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\r\n                outgoingAssetsIndex++;\r\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\r\n                increasedSpendAssetAmounts_[increasedSpendAssetsIndex] = postCallSpendAssetBalances[i]\r\n                    .sub(_preCallSpendAssetBalances[i]);\r\n                increasedSpendAssets_[increasedSpendAssetsIndex] = _spendAssets[i];\r\n                increasedSpendAssetsIndex++;\r\n            }\r\n        }\r\n\r\n        return (\r\n            outgoingAssets_,\r\n            outgoingAssetAmounts_,\r\n            increasedSpendAssets_,\r\n            increasedSpendAssetAmounts_\r\n        );\r\n    }\r\n\r\n    ///////////////////////////\r\n    // INTEGRATIONS REGISTRY //\r\n    ///////////////////////////\r\n\r\n    /// @notice Remove integration adapters from the list of registered adapters\r\n    /// @param _adapters Addresses of adapters to be deregistered\r\n    function deregisterAdapters(address[] calldata _adapters) external onlyFundDeployerOwner {\r\n        require(_adapters.length > 0, \"deregisterAdapters: _adapters cannot be empty\");\r\n\r\n        for (uint256 i; i < _adapters.length; i++) {\r\n            require(\r\n                adapterIsRegistered(_adapters[i]),\r\n                \"deregisterAdapters: Adapter is not registered\"\r\n            );\r\n\r\n            registeredAdapters.remove(_adapters[i]);\r\n\r\n            emit AdapterDeregistered(_adapters[i], IIntegrationAdapter(_adapters[i]).identifier());\r\n        }\r\n    }\r\n\r\n    /// @notice Add integration adapters to the list of registered adapters\r\n    /// @param _adapters Addresses of adapters to be registered\r\n    function registerAdapters(address[] calldata _adapters) external onlyFundDeployerOwner {\r\n        require(_adapters.length > 0, \"registerAdapters: _adapters cannot be empty\");\r\n\r\n        for (uint256 i; i < _adapters.length; i++) {\r\n            require(_adapters[i] != address(0), \"registerAdapters: Adapter cannot be empty\");\r\n\r\n            require(\r\n                !adapterIsRegistered(_adapters[i]),\r\n                \"registerAdapters: Adapter already registered\"\r\n            );\r\n\r\n            registeredAdapters.add(_adapters[i]);\r\n\r\n            emit AdapterRegistered(_adapters[i], IIntegrationAdapter(_adapters[i]).identifier());\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Checks if an integration adapter is registered\r\n    /// @param _adapter The adapter to check\r\n    /// @return isRegistered_ True if the adapter is registered\r\n    function adapterIsRegistered(address _adapter) public view returns (bool isRegistered_) {\r\n        return registeredAdapters.contains(_adapter);\r\n    }\r\n\r\n    /// @notice Gets the `DERIVATIVE_PRICE_FEED` variable\r\n    /// @return derivativePriceFeed_ The `DERIVATIVE_PRICE_FEED` variable value\r\n    function getDerivativePriceFeed() external view returns (address derivativePriceFeed_) {\r\n        return DERIVATIVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets the `POLICY_MANAGER` variable\r\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\r\n    function getPolicyManager() external view returns (address policyManager_) {\r\n        return POLICY_MANAGER;\r\n    }\r\n\r\n    /// @notice Gets the `PRIMITIVE_PRICE_FEED` variable\r\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\r\n    function getPrimitivePriceFeed() external view returns (address primitivePriceFeed_) {\r\n        return PRIMITIVE_PRICE_FEED;\r\n    }\r\n\r\n    /// @notice Gets all registered integration adapters\r\n    /// @return registeredAdaptersArray_ A list of all registered integration adapters\r\n    function getRegisteredAdapters()\r\n        external\r\n        view\r\n        returns (address[] memory registeredAdaptersArray_)\r\n    {\r\n        registeredAdaptersArray_ = new address[](registeredAdapters.length());\r\n        for (uint256 i = 0; i < registeredAdaptersArray_.length; i++) {\r\n            registeredAdaptersArray_[i] = registeredAdapters.at(i);\r\n        }\r\n\r\n        return registeredAdaptersArray_;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/buy-shares/BuySharesCallerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/AddressListPolicyMixin.sol\";\r\nimport \"./utils/BuySharesSetupPolicyBase.sol\";\r\n\r\n/// @title BuySharesCallerWhitelist Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A policy that only allows a configurable whitelist of buyShares callers for a fund\r\ncontract BuySharesCallerWhitelist is BuySharesSetupPolicyBase, AddressListPolicyMixin {\r\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\r\n\r\n    /// @notice Adds the initial policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\r\n        external\r\n        override\r\n        onlyPolicyManager\r\n    {\r\n        __updateList(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Provides a constant string identifier for a policy\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"BUY_SHARES_CALLER_WHITELIST\";\r\n    }\r\n\r\n    /// @notice Updates the policy settings for a fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedSettings Encoded settings to apply to a fund\r\n    function updateFundSettings(\r\n        address _comptrollerProxy,\r\n        address,\r\n        bytes calldata _encodedSettings\r\n    ) external override onlyPolicyManager {\r\n        __updateList(_comptrollerProxy, _encodedSettings);\r\n    }\r\n\r\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _buySharesCaller The buyShares caller for which to check the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function passesRule(address _comptrollerProxy, address _buySharesCaller)\r\n        public\r\n        view\r\n        returns (bool isValid_)\r\n    {\r\n        return isInList(_comptrollerProxy, _buySharesCaller);\r\n    }\r\n\r\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\r\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\r\n    /// @param _encodedArgs Encoded args with which to validate the rule\r\n    /// @return isValid_ True if the rule passes\r\n    function validateRule(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IPolicyManager.PolicyHook,\r\n        bytes calldata _encodedArgs\r\n    ) external override returns (bool isValid_) {\r\n        (address caller, , ) = __decodeRuleArgs(_encodedArgs);\r\n\r\n        return passesRule(_comptrollerProxy, caller);\r\n    }\r\n\r\n    /// @dev Helper to update the whitelist by adding and/or removing addresses\r\n    function __updateList(address _comptrollerProxy, bytes memory _settingsData) private {\r\n        (address[] memory itemsToAdd, address[] memory itemsToRemove) = abi.decode(\r\n            _settingsData,\r\n            (address[], address[])\r\n        );\r\n\r\n        // If an address is in both add and remove arrays, they will not be in the final list.\r\n        // We do not check for uniqueness between the two arrays for efficiency.\r\n        if (itemsToAdd.length > 0) {\r\n            __addToList(_comptrollerProxy, itemsToAdd);\r\n        }\r\n        if (itemsToRemove.length > 0) {\r\n            __removeFromList(_comptrollerProxy, itemsToRemove);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/policy-manager/policies/buy-shares/utils/BuySharesSetupPolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../utils/PolicyBase.sol\";\r\n\r\n/// @title BuySharesSetupPolicyBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice A mixin contract for policies that only implement the BuySharesSetup policy hook\r\nabstract contract BuySharesSetupPolicyBase is PolicyBase {\r\n    /// @notice Gets the implemented PolicyHooks for a policy\r\n    /// @return implementedHooks_ The implemented PolicyHooks\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\r\n    {\r\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\r\n        implementedHooks_[0] = IPolicyManager.PolicyHook.BuySharesSetup;\r\n\r\n        return implementedHooks_;\r\n    }\r\n\r\n    /// @notice Helper to decode rule arguments\r\n    function __decodeRuleArgs(bytes memory _encodedArgs)\r\n        internal\r\n        pure\r\n        returns (\r\n            address caller_,\r\n            uint256[] memory investmentAmounts_,\r\n            uint256 gav_\r\n        )\r\n    {\r\n        return abi.decode(_encodedArgs, (address, uint256[], uint256));\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityAaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/actions/CurveAaveLiquidityActionsMixin.sol\";\r\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\r\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\r\nimport \"../utils/AdapterBase2.sol\";\r\n\r\n/// @title CurveLiquidityAaveAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for liquidity provision in Curve's aave pool (https://www.curve.fi/aave)\r\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\r\n/// or claimRewardsAndReinvest(). Rationale:\r\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\r\n/// to enforce policy management or emit an event\r\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\r\n/// This adapter will need to be re-deployed if UniswapV2 low liquidity becomes\r\n/// a concern for rewards tokens when using claimRewardsAndReinvest().\r\ncontract CurveLiquidityAaveAdapter is\r\n    AdapterBase2,\r\n    CurveGaugeV2RewardsHandlerBase,\r\n    CurveAaveLiquidityActionsMixin,\r\n    UniswapV2ActionsMixin\r\n{\r\n    address private immutable AAVE_DAI_TOKEN;\r\n    address private immutable AAVE_USDC_TOKEN;\r\n    address private immutable AAVE_USDT_TOKEN;\r\n\r\n    address private immutable DAI_TOKEN;\r\n    address private immutable USDC_TOKEN;\r\n    address private immutable USDT_TOKEN;\r\n\r\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\r\n    address private immutable LP_TOKEN;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _liquidityGaugeToken,\r\n        address _lpToken,\r\n        address _minter,\r\n        address _pool,\r\n        address _crvToken,\r\n        address _wethToken,\r\n        address[3] memory _aaveTokens, // [aDAI, aUSDC, aUSDT]\r\n        address[3] memory _underlyingTokens, // [DAI, USDC, USDT]\r\n        address _uniswapV2Router2\r\n    )\r\n        public\r\n        AdapterBase2(_integrationManager)\r\n        CurveAaveLiquidityActionsMixin(_pool, _aaveTokens, _underlyingTokens)\r\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\r\n        UniswapV2ActionsMixin(_uniswapV2Router2)\r\n    {\r\n        AAVE_DAI_TOKEN = _aaveTokens[0];\r\n        AAVE_USDC_TOKEN = _aaveTokens[1];\r\n        AAVE_USDT_TOKEN = _aaveTokens[2];\r\n\r\n        DAI_TOKEN = _underlyingTokens[0];\r\n        USDC_TOKEN = _underlyingTokens[1];\r\n        USDT_TOKEN = _underlyingTokens[2];\r\n\r\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\r\n        LP_TOKEN = _lpToken;\r\n        WETH_TOKEN = _wethToken;\r\n\r\n        // Max approve liquidity gauge to spend LP token\r\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"CURVE_LIQUIDITY_AAVE\";\r\n    }\r\n\r\n    /// @notice Approves assets from the vault to be used by this contract.\r\n    /// @dev No logic necessary. Exists only to grant adapter with necessary approvals from the vault,\r\n    /// which takes place in the IntegrationManager.\r\n    function approveAssets(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external {}\r\n\r\n    /// @notice Claims rewards from the Curve liquidity gauge as well as pool-specific rewards\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    function claimRewards(\r\n        address _vaultProxy,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\r\n    }\r\n\r\n    /// @notice Claims rewards and then compounds the accrued rewards back into the staked LP token\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndReinvest(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            bool useFullBalances,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount,\r\n            uint8 intermediaryUnderlyingAssetIndex\r\n        ) = __decodeClaimRewardsAndReinvestCallArgs(_encodedCallArgs);\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        address intermediaryUnderlyingAsset = getAssetByPoolIndex(\r\n            intermediaryUnderlyingAssetIndex,\r\n            true\r\n        );\r\n\r\n        // Swap all reward tokens to the designated pool underlying token via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            address(this),\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            intermediaryUnderlyingAsset,\r\n            WETH_TOKEN\r\n        );\r\n\r\n        // Lend all received underlying for staked LP tokens\r\n        uint256 intermediaryUnderlyingAssetBalance = ERC20(intermediaryUnderlyingAsset).balanceOf(\r\n            address(this)\r\n        );\r\n        if (intermediaryUnderlyingAssetBalance > 0) {\r\n            uint256[3] memory orderedUnderlyingAssetAmounts;\r\n            orderedUnderlyingAssetAmounts[intermediaryUnderlyingAssetIndex] = intermediaryUnderlyingAssetBalance;\r\n\r\n            __curveAaveLend(\r\n                orderedUnderlyingAssetAmounts,\r\n                minIncomingLiquidityGaugeTokenAmount,\r\n                true\r\n            );\r\n            __curveGaugeV2Stake(\r\n                LIQUIDITY_GAUGE_TOKEN,\r\n                LP_TOKEN,\r\n                ERC20(LP_TOKEN).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev Requires the adapter to be granted an allowance of each reward token by the vault.\r\n    /// For supported assets (e.g., CRV), this must be done via the `approveAssets()` function in this adapter.\r\n    /// For unsupported assets, this must be done via `ComptrollerProxy.vaultCallOnContract()`.\r\n    /// The `useFullBalances` option indicates whether to use only the newly claimed balances of\r\n    /// rewards tokens, or whether to use the full balances of these assets in the vault.\r\n    function claimRewardsAndSwap(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external onlyIntegrationManager {\r\n        (bool useFullBalances, address incomingAsset, ) = __decodeClaimRewardsAndSwapCallArgs(\r\n            _encodedCallArgs\r\n        );\r\n\r\n        (\r\n            address[] memory rewardsTokens,\r\n            uint256[] memory rewardsTokenAmountsToUse\r\n        ) = __curveGaugeV2ClaimRewardsAndPullBalances(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            _vaultProxy,\r\n            useFullBalances\r\n        );\r\n\r\n        // Swap all reward tokens to the designated incomingAsset via UniswapV2.\r\n        // Note that if a reward token takes a fee on transfer,\r\n        // we could not use these memory balances.\r\n        __uniswapV2SwapManyToOne(\r\n            _vaultProxy,\r\n            rewardsTokens,\r\n            rewardsTokenAmountsToUse,\r\n            incomingAsset,\r\n            WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    /// @notice Lends assets for LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256[3] memory orderedOutgoingAmounts,\r\n            uint256 minIncomingLPTokenAmount,\r\n            bool useUnderlyings\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveAaveLend(orderedOutgoingAmounts, minIncomingLPTokenAmount, useUnderlyings);\r\n    }\r\n\r\n    /// @notice Lends assets for LP tokens, then stakes the received LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lendAndStake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256[3] memory orderedOutgoingAmounts,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount,\r\n            bool useUnderlyings\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        __curveAaveLend(\r\n            orderedOutgoingAmounts,\r\n            minIncomingLiquidityGaugeTokenAmount,\r\n            useUnderlyings\r\n        );\r\n        __curveGaugeV2Stake(\r\n            LIQUIDITY_GAUGE_TOKEN,\r\n            LP_TOKEN,\r\n            ERC20(LP_TOKEN).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLPTokenAmount,\r\n            uint256[3] memory orderedMinIncomingAssetAmounts,\r\n            bool redeemSingleAsset,\r\n            bool useUnderlyings\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveAaveRedeem(\r\n            outgoingLPTokenAmount,\r\n            orderedMinIncomingAssetAmounts,\r\n            redeemSingleAsset,\r\n            useUnderlyings\r\n        );\r\n    }\r\n\r\n    /// @notice Stakes LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function stake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        uint256 outgoingLPTokenAmount = __decodeStakeCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Stake(LIQUIDITY_GAUGE_TOKEN, LP_TOKEN, outgoingLPTokenAmount);\r\n    }\r\n\r\n    /// @notice Unstakes LP tokens\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstake(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\r\n    }\r\n\r\n    /// @notice Unstakes LP tokens, then redeems them\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function unstakeAndRedeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256[3] memory orderedMinIncomingAssetAmounts,\r\n            bool redeemSingleAsset,\r\n            bool useUnderlyings\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\r\n        __curveAaveRedeem(\r\n            outgoingLiquidityGaugeTokenAmount,\r\n            orderedMinIncomingAssetAmounts,\r\n            redeemSingleAsset,\r\n            useUnderlyings\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // PARSE ASSETS FOR METHOD //\r\n    /////////////////////////////\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == APPROVE_ASSETS_SELECTOR) {\r\n            return __parseAssetsForApproveAssets(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_SELECTOR) {\r\n            return __parseAssetsForClaimRewards();\r\n        } else if (_selector == CLAIM_REWARDS_AND_REINVEST_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndReinvest(_encodedCallArgs);\r\n        } else if (_selector == CLAIM_REWARDS_AND_SWAP_SELECTOR) {\r\n            return __parseAssetsForClaimRewardsAndSwap(_encodedCallArgs);\r\n        } else if (_selector == LEND_SELECTOR) {\r\n            return __parseAssetsForLend(_encodedCallArgs);\r\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\r\n            return __parseAssetsForLendAndStake(_encodedCallArgs);\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            return __parseAssetsForRedeem(_encodedCallArgs);\r\n        } else if (_selector == STAKE_SELECTOR) {\r\n            return __parseAssetsForStake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_SELECTOR) {\r\n            return __parseAssetsForUnstake(_encodedCallArgs);\r\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\r\n            return __parseAssetsForUnstakeAndRedeem(_encodedCallArgs);\r\n        }\r\n\r\n        revert(\"parseAssetsForMethod: _selector invalid\");\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during approveAssets() calls\r\n    function __parseAssetsForApproveAssets(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (spendAssets_, spendAssetAmounts_) = __decodeApproveAssetsCallArgs(_encodedCallArgs);\r\n        require(\r\n            spendAssets_.length == spendAssetAmounts_.length,\r\n            \"__parseAssetsForApproveAssets: Unequal arrays\"\r\n        );\r\n\r\n        // Validate that only rewards tokens are given allowances\r\n        address[] memory rewardsTokens = __curveGaugeV2GetRewardsTokensWithCrv(\r\n            LIQUIDITY_GAUGE_TOKEN\r\n        );\r\n        for (uint256 i; i < spendAssets_.length; i++) {\r\n            // Allow revoking approval for any asset\r\n            if (spendAssetAmounts_[i] > 0) {\r\n                require(\r\n                    rewardsTokens.contains(spendAssets_[i]),\r\n                    \"__parseAssetsForApproveAssets: Invalid reward token\"\r\n                );\r\n            }\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Approve,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewards() calls.\r\n    /// No action required, all values empty.\r\n    function __parseAssetsForClaimRewards()\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            new address[](0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndReinvest() calls.\r\n    function __parseAssetsForClaimRewardsAndReinvest(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            ,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount,\r\n            uint8 intermediaryUnderlyingAssetIndex\r\n        ) = __decodeClaimRewardsAndReinvestCallArgs(_encodedCallArgs);\r\n        require(\r\n            intermediaryUnderlyingAssetIndex < 3,\r\n            \"__parseAssetsForClaimRewardsAndReinvest: Out-of-bounds intermediaryUnderlyingAssetIndex\"\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during claimRewardsAndSwap() calls.\r\n    function __parseAssetsForClaimRewardsAndSwap(bytes calldata _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            ,\r\n            address incomingAsset,\r\n            uint256 minIncomingAssetAmount\r\n        ) = __decodeClaimRewardsAndSwapCallArgs(_encodedCallArgs);\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = incomingAsset;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.None,\r\n            new address[](0),\r\n            new uint256[](0),\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lend() calls\r\n    function __parseAssetsForLend(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256[3] memory orderedOutgoingAssetAmounts,\r\n            uint256 minIncomingLpTokenAmount,\r\n            bool useUnderlyings\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            orderedOutgoingAssetAmounts,\r\n            useUnderlyings\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during lendAndStake() calls\r\n    function __parseAssetsForLendAndStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256[3] memory orderedOutgoingAssetAmounts,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount,\r\n            bool useUnderlyings\r\n        ) = __decodeLendCallArgs(_encodedCallArgs);\r\n\r\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\r\n            orderedOutgoingAssetAmounts,\r\n            useUnderlyings\r\n        );\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during redeem() calls\r\n    function __parseAssetsForRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLpTokenAmount,\r\n            uint256[3] memory orderedMinIncomingAssetAmounts,\r\n            bool receiveSingleAsset,\r\n            bool useUnderlyings\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            orderedMinIncomingAssetAmounts,\r\n            receiveSingleAsset,\r\n            useUnderlyings\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during stake() calls\r\n    function __parseAssetsForStake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LP_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstake() calls\r\n    function __parseAssetsForUnstake(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        incomingAssets_ = new address[](1);\r\n        incomingAssets_[0] = LP_TOKEN;\r\n\r\n        minIncomingAssetAmounts_ = new uint256[](1);\r\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\r\n    /// during unstakeAndRedeem() calls\r\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _encodedCallArgs)\r\n        private\r\n        view\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        (\r\n            uint256 outgoingLiquidityGaugeTokenAmount,\r\n            uint256[3] memory orderedMinIncomingAssetAmounts,\r\n            bool receiveSingleAsset,\r\n            bool useUnderlyings\r\n        ) = __decodeRedeemCallArgs(_encodedCallArgs);\r\n\r\n        spendAssets_ = new address[](1);\r\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\r\n\r\n        spendAssetAmounts_ = new uint256[](1);\r\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\r\n\r\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\r\n            orderedMinIncomingAssetAmounts,\r\n            receiveSingleAsset,\r\n            useUnderlyings\r\n        );\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\r\n    function __parseIncomingAssetsForRedemptionCalls(\r\n        uint256[3] memory _orderedMinIncomingAssetAmounts,\r\n        bool _receiveSingleAsset,\r\n        bool _useUnderlyings\r\n    )\r\n        private\r\n        view\r\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\r\n    {\r\n        if (_receiveSingleAsset) {\r\n            incomingAssets_ = new address[](1);\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n\r\n            for (uint256 i; i < _orderedMinIncomingAssetAmounts.length; i++) {\r\n                if (_orderedMinIncomingAssetAmounts[i] == 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Validate that only one min asset amount is set\r\n                for (uint256 j = i + 1; j < _orderedMinIncomingAssetAmounts.length; j++) {\r\n                    require(\r\n                        _orderedMinIncomingAssetAmounts[j] == 0,\r\n                        \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\r\n                    );\r\n                }\r\n\r\n                incomingAssets_[0] = getAssetByPoolIndex(i, _useUnderlyings);\r\n                minIncomingAssetAmounts_[0] = _orderedMinIncomingAssetAmounts[i];\r\n\r\n                break;\r\n            }\r\n            require(\r\n                incomingAssets_[0] != address(0),\r\n                \"__parseIncomingAssetsForRedemptionCalls: No min asset amount\"\r\n            );\r\n        } else {\r\n            incomingAssets_ = new address[](3);\r\n            minIncomingAssetAmounts_ = new uint256[](3);\r\n            for (uint256 i; i < incomingAssets_.length; i++) {\r\n                incomingAssets_[i] = getAssetByPoolIndex(i, _useUnderlyings);\r\n                minIncomingAssetAmounts_[i] = _orderedMinIncomingAssetAmounts[i];\r\n            }\r\n        }\r\n\r\n        return (incomingAssets_, minIncomingAssetAmounts_);\r\n    }\r\n\r\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\r\n    function __parseSpendAssetsForLendingCalls(\r\n        uint256[3] memory _orderedOutgoingAssetAmounts,\r\n        bool _useUnderlyings\r\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\r\n        uint256 spendAssetsCount;\r\n        for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {\r\n            if (_orderedOutgoingAssetAmounts[i] > 0) {\r\n                spendAssetsCount++;\r\n            }\r\n        }\r\n\r\n        spendAssets_ = new address[](spendAssetsCount);\r\n        spendAssetAmounts_ = new uint256[](spendAssetsCount);\r\n        uint256 spendAssetsIndex;\r\n        for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {\r\n            if (_orderedOutgoingAssetAmounts[i] > 0) {\r\n                spendAssets_[spendAssetsIndex] = getAssetByPoolIndex(i, _useUnderlyings);\r\n                spendAssetAmounts_[spendAssetsIndex] = _orderedOutgoingAssetAmounts[i];\r\n                spendAssetsIndex++;\r\n            }\r\n        }\r\n\r\n        return (spendAssets_, spendAssetAmounts_);\r\n    }\r\n\r\n    ///////////////////////\r\n    // ENCODED CALL ARGS //\r\n    ///////////////////////\r\n\r\n    /// @dev Helper to decode the encoded call arguments for approving asset allowances\r\n    function __decodeApproveAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address[] memory assets_, uint256[] memory amounts_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[], uint256[]));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and reinvesting\r\n    function __decodeClaimRewardsAndReinvestCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            bool useFullBalances_,\r\n            uint256 minIncomingLiquidityGaugeTokenAmount_,\r\n            uint8 intermediaryUnderlyingAssetIndex_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, uint256, uint8));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for claiming rewards and swapping\r\n    function __decodeClaimRewardsAndSwapCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            bool useFullBalances_,\r\n            address incomingAsset_,\r\n            uint256 minIncomingAssetAmount_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (bool, address, uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for lending\r\n    function __decodeLendCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256[3] memory orderedOutgoingAmounts_,\r\n            uint256 minIncomingAssetAmount_,\r\n            bool useUnderlyings_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256[3], uint256, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for redeeming.\r\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\r\n    /// the orderedMinIncomingAmounts_ must be >0 to indicate which asset is to be received.\r\n    function __decodeRedeemCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256 outgoingAssetAmount_,\r\n            uint256[3] memory orderedMinIncomingAmounts_,\r\n            bool receiveSingleAsset_,\r\n            bool useUnderlyings_\r\n        )\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256[3], bool, bool));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for staking\r\n    function __decodeStakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLPTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments for unstaking\r\n    function __decodeUnstakeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\r\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\r\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\r\n        return LIQUIDITY_GAUGE_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `LP_TOKEN` variable\r\n    /// @return lpToken_ The `LP_TOKEN` variable value\r\n    function getLpToken() external view returns (address lpToken_) {\r\n        return LP_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets an asset by its pool index and whether or not to use the underlying\r\n    /// instead of the aToken\r\n    function getAssetByPoolIndex(uint256 _index, bool _useUnderlying)\r\n        public\r\n        view\r\n        returns (address asset_)\r\n    {\r\n        if (_index == 0) {\r\n            if (_useUnderlying) {\r\n                return DAI_TOKEN;\r\n            }\r\n            return AAVE_DAI_TOKEN;\r\n        } else if (_index == 1) {\r\n            if (_useUnderlying) {\r\n                return USDC_TOKEN;\r\n            }\r\n            return AAVE_USDC_TOKEN;\r\n        } else if (_index == 2) {\r\n            if (_useUnderlying) {\r\n                return USDT_TOKEN;\r\n            }\r\n            return AAVE_USDT_TOKEN;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveAaveLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../../../../../interfaces/ICurveStableSwapAave.sol\";\r\n\r\n/// @title CurveAaveLiquidityActionsMixin Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Mixin contract for interacting with the Curve Aave pool's liquidity functions\r\nabstract contract CurveAaveLiquidityActionsMixin {\r\n    using SafeERC20 for ERC20;\r\n\r\n    address private immutable CURVE_AAVE_LIQUIDITY_POOL;\r\n\r\n    constructor(\r\n        address _pool,\r\n        address[3] memory _aaveTokensToApprove,\r\n        address[3] memory _underlyingTokensToApprove\r\n    ) public {\r\n        CURVE_AAVE_LIQUIDITY_POOL = _pool;\r\n\r\n        // Pre-approve pool to use max of each aToken and underlying,\r\n        // as specified by the inheriting contract.\r\n        // Use address(0) to skip a particular ordered asset.\r\n        for (uint256 i; i < 3; i++) {\r\n            if (_aaveTokensToApprove[i] != address(0)) {\r\n                ERC20(_aaveTokensToApprove[i]).safeApprove(_pool, type(uint256).max);\r\n            }\r\n            if (_underlyingTokensToApprove[i] != address(0)) {\r\n                ERC20(_underlyingTokensToApprove[i]).safeApprove(_pool, type(uint256).max);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to add liquidity to the pool.\r\n    /// _orderedOutgoingAssetAmounts = [aDAI, aUSDC, aUSDT].\r\n    function __curveAaveLend(\r\n        uint256[3] memory _orderedOutgoingAssetAmounts,\r\n        uint256 _minIncomingLPTokenAmount,\r\n        bool _useUnderlyings\r\n    ) internal {\r\n        ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).add_liquidity(\r\n            _orderedOutgoingAssetAmounts,\r\n            _minIncomingLPTokenAmount,\r\n            _useUnderlyings\r\n        );\r\n    }\r\n\r\n    /// @dev Helper to remove liquidity from the pool.\r\n    /// if using _redeemSingleAsset, must pre-validate that one - and only one - asset\r\n    /// has a non-zero _orderedMinIncomingAssetAmounts value.\r\n    /// _orderedOutgoingAssetAmounts = [aDAI, aUSDC, aUSDT].\r\n    function __curveAaveRedeem(\r\n        uint256 _outgoingLPTokenAmount,\r\n        uint256[3] memory _orderedMinIncomingAssetAmounts,\r\n        bool _redeemSingleAsset,\r\n        bool _useUnderlyings\r\n    ) internal {\r\n        if (_redeemSingleAsset) {\r\n            // Assume that one - and only one - asset has a non-zero min incoming asset amount\r\n            for (uint256 i; i < _orderedMinIncomingAssetAmounts.length; i++) {\r\n                if (_orderedMinIncomingAssetAmounts[i] > 0) {\r\n                    ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).remove_liquidity_one_coin(\r\n                        _outgoingLPTokenAmount,\r\n                        int128(i),\r\n                        _orderedMinIncomingAssetAmounts[i],\r\n                        _useUnderlyings\r\n                    );\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).remove_liquidity(\r\n                _outgoingLPTokenAmount,\r\n                _orderedMinIncomingAssetAmounts,\r\n                _useUnderlyings\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `CURVE_AAVE_LIQUIDITY_POOL` variable\r\n    /// @return pool_ The `CURVE_AAVE_LIQUIDITY_POOL` variable value\r\n    function getCurveAaveLiquidityPool() public view returns (address pool_) {\r\n        return CURVE_AAVE_LIQUIDITY_POOL;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/ICurveStableSwapAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title ICurveStableSwapAave interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface ICurveStableSwapAave {\r\n    function add_liquidity(\r\n        uint256[3] calldata,\r\n        uint256,\r\n        bool\r\n    ) external returns (uint256);\r\n\r\n    function remove_liquidity(\r\n        uint256,\r\n        uint256[3] calldata,\r\n        bool\r\n    ) external returns (uint256[3] memory);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256,\r\n        int128,\r\n        uint256,\r\n        bool\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/mocks/integratees/compound/MockCTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\r\nimport \"../../prices/CentralizedRateProvider.sol\";\r\nimport \"../../utils/SwapperBase.sol\";\r\n\r\ncontract MockCTokenBase is ERC20, SwapperBase, Ownable {\r\n    address internal immutable TOKEN;\r\n    address internal immutable CENTRALIZED_RATE_PROVIDER;\r\n\r\n    uint256 internal rate;\r\n\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _token,\r\n        address _centralizedRateProvider,\r\n        uint256 _initialRate\r\n    ) public ERC20(_name, _symbol) {\r\n        _setupDecimals(_decimals);\r\n        TOKEN = _token;\r\n        CENTRALIZED_RATE_PROVIDER = _centralizedRateProvider;\r\n        rate = _initialRate;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public virtual override returns (bool) {\r\n        _allowances[msg.sender][_spender] = _amount;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Overriden `allowance` function, give the integratee infinite approval by default\r\n    function allowance(address _owner, address _spender) public view override returns (uint256) {\r\n        if (_spender == address(this) || _owner == _spender) {\r\n            return 2**256 - 1;\r\n        } else {\r\n            return _allowances[_owner][_spender];\r\n        }\r\n    }\r\n\r\n    /// @dev Necessary as this contract doesn't directly inherit from MockToken\r\n    function mintFor(address _who, uint256 _amount) external onlyOwner {\r\n        _mint(_who, _amount);\r\n    }\r\n\r\n    /// @dev Necessary to allow updates on persistent deployments (e.g Kovan)\r\n    function setRate(uint256 _rate) public onlyOwner {\r\n        rate = _rate;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(_sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Calculates the cTokenAmount given a tokenAmount\r\n    /// Makes use of a inverse rate with the CentralizedRateProvider as a derivative can't be used as quoteAsset\r\n    function __calcCTokenAmount(uint256 _tokenAmount) internal returns (uint256 cTokenAmount_) {\r\n        uint256 tokenDecimals = ERC20(TOKEN).decimals();\r\n        uint256 cTokenDecimals = decimals();\r\n\r\n        // Result in Token Decimals\r\n        uint256 tokenPerCTokenUnit = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(address(this), 10**uint256(cTokenDecimals), TOKEN);\r\n\r\n        // Result in cToken decimals\r\n        uint256 inverseRate = uint256(10**tokenDecimals).mul(10**uint256(cTokenDecimals)).div(\r\n            tokenPerCTokenUnit\r\n        );\r\n\r\n        // Amount in token decimals, result in cToken decimals\r\n        cTokenAmount_ = _tokenAmount.mul(inverseRate).div(10**tokenDecimals);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @dev Part of ICERC20 token interface\r\n    function underlying() public view returns (address) {\r\n        return TOKEN;\r\n    }\r\n\r\n    /// @dev Part of ICERC20 token interface.\r\n    /// Called from CompoundPriceFeed, returns the actual Rate cToken/Token\r\n    function exchangeRateStored() public view returns (uint256) {\r\n        return rate;\r\n    }\r\n\r\n    function getCentralizedRateProvider() public view returns (address) {\r\n        return CENTRALIZED_RATE_PROVIDER;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/compound/MockCTokenIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./MockCTokenBase.sol\";\r\n\r\ncontract MockCTokenIntegratee is MockCTokenBase {\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _token,\r\n        address _centralizedRateProvider,\r\n        uint256 _initialRate\r\n    )\r\n        public\r\n        MockCTokenBase(_name, _symbol, _decimals, _token, _centralizedRateProvider, _initialRate)\r\n    {}\r\n\r\n    function mint(uint256 _amount) external returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER).calcLiveAssetValue(\r\n            TOKEN,\r\n            _amount,\r\n            address(this)\r\n        );\r\n\r\n        __swapAssets(msg.sender, TOKEN, _amount, address(this), destAmount);\r\n        return _amount;\r\n    }\r\n\r\n    function redeem(uint256 _amount) external returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER).calcLiveAssetValue(\r\n            address(this),\r\n            _amount,\r\n            TOKEN\r\n        );\r\n        __swapAssets(msg.sender, address(this), _amount, TOKEN, destAmount);\r\n        return _amount;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/compound/MockCEtherIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./MockCTokenBase.sol\";\r\n\r\ncontract MockCEtherIntegratee is MockCTokenBase {\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _weth,\r\n        address _centralizedRateProvider,\r\n        uint256 _initialRate\r\n    )\r\n        public\r\n        MockCTokenBase(_name, _symbol, _decimals, _weth, _centralizedRateProvider, _initialRate)\r\n    {}\r\n\r\n    function mint() external payable {\r\n        uint256 amount = msg.value;\r\n        uint256 destAmount = __calcCTokenAmount(amount);\r\n        __swapAssets(msg.sender, ETH_ADDRESS, amount, address(this), destAmount);\r\n    }\r\n\r\n    function redeem(uint256 _amount) external returns (uint256) {\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER).calcLiveAssetValue(\r\n            address(this),\r\n            _amount,\r\n            TOKEN\r\n        );\r\n        __swapAssets(msg.sender, address(this), _amount, ETH_ADDRESS, destAmount);\r\n        return _amount;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/utils/SimpleMockIntegrateeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./MockIntegrateeBase.sol\";\r\n\r\nabstract contract SimpleMockIntegrateeBase is MockIntegrateeBase {\r\n    constructor(\r\n        address[] memory _defaultRateAssets,\r\n        address[] memory _specialAssets,\r\n        uint8[] memory _specialAssetDecimals,\r\n        uint256 _ratePrecision\r\n    )\r\n        public\r\n        MockIntegrateeBase(\r\n            _defaultRateAssets,\r\n            _specialAssets,\r\n            _specialAssetDecimals,\r\n            _ratePrecision\r\n        )\r\n    {}\r\n\r\n    function __getRateAndSwapAssets(\r\n        address payable _trader,\r\n        address _srcToken,\r\n        uint256 _srcAmount,\r\n        address _destToken\r\n    ) internal returns (uint256 destAmount_) {\r\n        uint256 actualRate = __getRate(_srcToken, _destToken);\r\n        __swapAssets(_trader, _srcToken, _srcAmount, _destToken, actualRate);\r\n        return actualRate;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/MockUniswapV2Integratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../prices/CentralizedRateProvider.sol\";\r\nimport \"./utils/SimpleMockIntegrateeBase.sol\";\r\n\r\n/// @dev Mocks the integration with `UniswapV2Router02` <https://uniswap.org/docs/v2/smart-contracts/router02/>\r\n/// Additionally mocks the integration with `UniswapV2Factory` <https://uniswap.org/docs/v2/smart-contracts/factory/>\r\ncontract MockUniswapV2Integratee is SwapperBase, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping(address => mapping(address => address)) private assetToAssetToPair;\r\n\r\n    address private immutable CENTRALIZED_RATE_PROVIDER;\r\n    uint256 private constant PRECISION = 18;\r\n\r\n    // Set in %, defines the MAX deviation per block from the mean rate\r\n    uint256 private blockNumberDeviation;\r\n\r\n    constructor(\r\n        address[] memory _listOfToken0,\r\n        address[] memory _listOfToken1,\r\n        address[] memory _listOfPair,\r\n        address _centralizedRateProvider,\r\n        uint256 _blockNumberDeviation\r\n    ) public {\r\n        addPair(_listOfToken0, _listOfToken1, _listOfPair);\r\n        CENTRALIZED_RATE_PROVIDER = _centralizedRateProvider;\r\n        blockNumberDeviation = _blockNumberDeviation;\r\n    }\r\n\r\n    /// @dev Adds the maximum possible value from {_amountADesired _amountBDesired}\r\n    /// Makes use of the value interpreter to perform those calculations\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        __addLiquidity(_tokenA, _tokenB, _amountADesired, _amountBDesired);\r\n    }\r\n\r\n    /// @dev Removes the specified amount of liquidity\r\n    /// Returns 50% of the incoming liquidity value on each token.\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) public returns (uint256, uint256) {\r\n        __removeLiquidity(_tokenA, _tokenB, _liquidity);\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256,\r\n        address[] calldata path,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256[] memory) {\r\n        uint256 amountOut = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomized(path[0], amountIn, path[1], blockNumberDeviation);\r\n\r\n        __swapAssets(msg.sender, path[0], amountIn, path[path.length - 1], amountOut);\r\n    }\r\n\r\n    /// @dev We don't calculate any intermediate values here because they aren't actually used\r\n    /// Returns the randomized by sender value of the edge path assets\r\n    function getAmountsOut(uint256 _amountIn, address[] calldata _path)\r\n        external\r\n        returns (uint256[] memory amounts_)\r\n    {\r\n        require(_path.length >= 2, \"getAmountsOut: path must be >= 2\");\r\n\r\n        address assetIn = _path[0];\r\n        address assetOut = _path[_path.length - 1];\r\n\r\n        uint256 amountOut = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomizedBySender(assetIn, _amountIn, assetOut);\r\n\r\n        amounts_ = new uint256[](_path.length);\r\n        amounts_[0] = _amountIn;\r\n        amounts_[_path.length - 1] = amountOut;\r\n\r\n        return amounts_;\r\n    }\r\n\r\n    function addPair(\r\n        address[] memory _listOfToken0,\r\n        address[] memory _listOfToken1,\r\n        address[] memory _listOfPair\r\n    ) public onlyOwner {\r\n        require(\r\n            _listOfPair.length == _listOfToken0.length,\r\n            \"constructor: _listOfPair and _listOfToken0 have an unequal length\"\r\n        );\r\n        require(\r\n            _listOfPair.length == _listOfToken1.length,\r\n            \"constructor: _listOfPair and _listOfToken1 have an unequal length\"\r\n        );\r\n        for (uint256 i; i < _listOfPair.length; i++) {\r\n            address token0 = _listOfToken0[i];\r\n            address token1 = _listOfToken1[i];\r\n            address pair = _listOfPair[i];\r\n            assetToAssetToPair[token0][token1] = pair;\r\n            assetToAssetToPair[token1][token0] = pair;\r\n        }\r\n    }\r\n\r\n    function setBlockNumberDeviation(uint256 _deviationPct) external onlyOwner {\r\n        blockNumberDeviation = _deviationPct;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// Avoids stack-too-deep error.\r\n    function __addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired\r\n    ) private {\r\n        address pair = getPair(_tokenA, _tokenB);\r\n\r\n        uint256 amountA;\r\n        uint256 amountB;\r\n\r\n        uint256 amountBFromA = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(_tokenA, _amountADesired, _tokenB);\r\n        uint256 amountAFromB = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(_tokenB, _amountBDesired, _tokenA);\r\n\r\n        if (amountBFromA >= _amountBDesired) {\r\n            amountA = amountAFromB;\r\n            amountB = _amountBDesired;\r\n        } else {\r\n            amountA = _amountADesired;\r\n            amountB = amountBFromA;\r\n        }\r\n\r\n        uint256 tokenPerLPToken = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(pair, 10**uint256(PRECISION), _tokenA);\r\n\r\n        // Calculate the inverse rate to know the amount of LPToken to return from a unit of token\r\n        uint256 inverseRate = uint256(10**PRECISION).mul(10**PRECISION).div(tokenPerLPToken);\r\n\r\n        // Total liquidity can be calculated as 2x liquidity from amount A\r\n        uint256 totalLiquidity = uint256(2).mul(\r\n            amountA.mul(inverseRate).div(uint256(10**PRECISION))\r\n        );\r\n\r\n        require(\r\n            ERC20(pair).balanceOf(address(this)) >= totalLiquidity,\r\n            \"__addLiquidity: Integratee doesn't have enough pair balance to cover the expected amount\"\r\n        );\r\n\r\n        address[] memory assetsToIntegratee = new address[](2);\r\n        uint256[] memory assetsToIntegrateeAmounts = new uint256[](2);\r\n        address[] memory assetsFromIntegratee = new address[](1);\r\n        uint256[] memory assetsFromIntegrateeAmounts = new uint256[](1);\r\n\r\n        assetsToIntegratee[0] = _tokenA;\r\n        assetsToIntegrateeAmounts[0] = amountA;\r\n        assetsToIntegratee[1] = _tokenB;\r\n        assetsToIntegrateeAmounts[1] = amountB;\r\n        assetsFromIntegratee[0] = pair;\r\n        assetsFromIntegrateeAmounts[0] = totalLiquidity;\r\n\r\n        __swap(\r\n            msg.sender,\r\n            assetsToIntegratee,\r\n            assetsToIntegrateeAmounts,\r\n            assetsFromIntegratee,\r\n            assetsFromIntegrateeAmounts\r\n        );\r\n    }\r\n\r\n    /// Avoids stack-too-deep error.\r\n    function __removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity\r\n    ) private {\r\n        address pair = assetToAssetToPair[_tokenA][_tokenB];\r\n        require(pair != address(0), \"__removeLiquidity: this pair doesn't exist\");\r\n\r\n        uint256 amountA = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(pair, _liquidity, _tokenA)\r\n            .div(uint256(2));\r\n\r\n        uint256 amountB = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValue(pair, _liquidity, _tokenB)\r\n            .div(uint256(2));\r\n\r\n        address[] memory assetsToIntegratee = new address[](1);\r\n        uint256[] memory assetsToIntegrateeAmounts = new uint256[](1);\r\n        address[] memory assetsFromIntegratee = new address[](2);\r\n        uint256[] memory assetsFromIntegrateeAmounts = new uint256[](2);\r\n\r\n        assetsToIntegratee[0] = pair;\r\n        assetsToIntegrateeAmounts[0] = _liquidity;\r\n        assetsFromIntegratee[0] = _tokenA;\r\n        assetsFromIntegrateeAmounts[0] = amountA;\r\n        assetsFromIntegratee[1] = _tokenB;\r\n        assetsFromIntegrateeAmounts[1] = amountB;\r\n\r\n        require(\r\n            ERC20(_tokenA).balanceOf(address(this)) >= amountA,\r\n            \"__removeLiquidity: Integratee doesn't have enough tokenA balance to cover the expected amount\"\r\n        );\r\n        require(\r\n            ERC20(_tokenB).balanceOf(address(this)) >= amountA,\r\n            \"__removeLiquidity: Integratee doesn't have enough tokenB balance to cover the expected amount\"\r\n        );\r\n\r\n        __swap(\r\n            msg.sender,\r\n            assetsToIntegratee,\r\n            assetsToIntegrateeAmounts,\r\n            assetsFromIntegratee,\r\n            assetsFromIntegrateeAmounts\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @dev By default set to address(0). It is read by UniswapV2PoolTokenValueCalculator: __calcPoolTokenValue\r\n    function feeTo() external pure returns (address) {\r\n        return address(0);\r\n    }\r\n\r\n    function getCentralizedRateProvider() public view returns (address) {\r\n        return CENTRALIZED_RATE_PROVIDER;\r\n    }\r\n\r\n    function getBlockNumberDeviation() public view returns (uint256) {\r\n        return blockNumberDeviation;\r\n    }\r\n\r\n    function getPrecision() public pure returns (uint256) {\r\n        return PRECISION;\r\n    }\r\n\r\n    function getPair(address _token0, address _token1) public view returns (address) {\r\n        return assetToAssetToPair[_token0][_token1];\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/MockGenericIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../utils/SwapperBase.sol\";\r\n\r\ncontract MockGenericIntegratee is SwapperBase {\r\n    function swap(\r\n        address[] calldata _assetsToIntegratee,\r\n        uint256[] calldata _assetsToIntegrateeAmounts,\r\n        address[] calldata _assetsFromIntegratee,\r\n        uint256[] calldata _assetsFromIntegrateeAmounts\r\n    ) external payable {\r\n        __swap(\r\n            msg.sender,\r\n            _assetsToIntegratee,\r\n            _assetsToIntegrateeAmounts,\r\n            _assetsFromIntegratee,\r\n            _assetsFromIntegrateeAmounts\r\n        );\r\n    }\r\n\r\n    function swapOnBehalf(\r\n        address payable _trader,\r\n        address[] calldata _assetsToIntegratee,\r\n        uint256[] calldata _assetsToIntegrateeAmounts,\r\n        address[] calldata _assetsFromIntegratee,\r\n        uint256[] calldata _assetsFromIntegrateeAmounts\r\n    ) external payable {\r\n        __swap(\r\n            _trader,\r\n            _assetsToIntegratee,\r\n            _assetsToIntegrateeAmounts,\r\n            _assetsFromIntegratee,\r\n            _assetsFromIntegrateeAmounts\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/AlphaHomoraV1Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../interfaces/IAlphaHomoraV1Bank.sol\";\r\nimport \"../../../../interfaces/IWETH.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title AlphaHomoraV1Adapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter for Alpha Homora v1 <https://alphafinance.io/>\r\ncontract AlphaHomoraV1Adapter is AdapterBase {\r\n    address private immutable IBETH_TOKEN;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(\r\n        address _integrationManager,\r\n        address _ibethToken,\r\n        address _wethToken\r\n    ) public AdapterBase(_integrationManager) {\r\n        IBETH_TOKEN = _ibethToken;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @dev Needed to receive ETH during redemption\r\n    receive() external payable {}\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ An identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ALPHA_HOMORA_V1\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == LEND_SELECTOR) {\r\n            (uint256 wethAmount, uint256 minIbethAmount) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = WETH_TOKEN;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = wethAmount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = IBETH_TOKEN;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minIbethAmount;\r\n        } else if (_selector == REDEEM_SELECTOR) {\r\n            (uint256 ibethAmount, uint256 minWethAmount) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n            spendAssets_ = new address[](1);\r\n            spendAssets_[0] = IBETH_TOKEN;\r\n            spendAssetAmounts_ = new uint256[](1);\r\n            spendAssetAmounts_[0] = ibethAmount;\r\n\r\n            incomingAssets_ = new address[](1);\r\n            incomingAssets_[0] = WETH_TOKEN;\r\n            minIncomingAssetAmounts_ = new uint256[](1);\r\n            minIncomingAssetAmounts_[0] = minWethAmount;\r\n        } else {\r\n            revert(\"parseAssetsForMethod: _selector invalid\");\r\n        }\r\n\r\n        return (\r\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Lends WETH for ibETH\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function lend(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (uint256 wethAmount, ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        IWETH(payable(WETH_TOKEN)).withdraw(wethAmount);\r\n\r\n        IAlphaHomoraV1Bank(IBETH_TOKEN).deposit{value: payable(address(this)).balance}();\r\n    }\r\n\r\n    /// @notice Redeems ibETH for WETH\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\r\n    function redeem(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata _encodedAssetTransferArgs\r\n    )\r\n        external\r\n        onlyIntegrationManager\r\n        fundAssetsTransferHandler(_vaultProxy, _encodedAssetTransferArgs)\r\n    {\r\n        (uint256 ibethAmount, ) = __decodeCallArgs(_encodedCallArgs);\r\n\r\n        IAlphaHomoraV1Bank(IBETH_TOKEN).withdraw(ibethAmount);\r\n\r\n        IWETH(payable(WETH_TOKEN)).deposit{value: payable(address(this)).balance}();\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the encoded call arguments\r\n    function __decodeCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (uint256 outgoingAmount_, uint256 minIncomingAmount_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (uint256, uint256));\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `IBETH_TOKEN` variable\r\n    /// @return ibethToken_ The `IBETH_TOKEN` variable value\r\n    function getIbethToken() external view returns (address ibethToken_) {\r\n        return IBETH_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/interfaces/IAlphaHomoraV1Bank.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title IAlphaHomoraV1Bank interface\r\n/// @author Enzyme Council <security@enzyme.finance>\r\ninterface IAlphaHomoraV1Bank {\r\n    function deposit() external payable;\r\n\r\n    function totalETH() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/AlphaHomoraV1PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../../../../interfaces/IAlphaHomoraV1Bank.sol\";\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title AlphaHomoraV1PriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price source oracle for Alpha Homora v1 ibETH\r\ncontract AlphaHomoraV1PriceFeed is IDerivativePriceFeed {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable IBETH_TOKEN;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    constructor(address _ibethToken, address _wethToken) public {\r\n        IBETH_TOKEN = _ibethToken;\r\n        WETH_TOKEN = _wethToken;\r\n    }\r\n\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    /// @param _derivative The derivative to convert\r\n    /// @param _derivativeAmount The amount of the derivative to convert\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        require(isSupportedAsset(_derivative), \"calcUnderlyingValues: Only ibETH is supported\");\r\n\r\n        underlyings_ = new address[](1);\r\n        underlyings_[0] = WETH_TOKEN;\r\n        underlyingAmounts_ = new uint256[](1);\r\n\r\n        IAlphaHomoraV1Bank alphaHomoraBankContract = IAlphaHomoraV1Bank(IBETH_TOKEN);\r\n        underlyingAmounts_[0] = _derivativeAmount.mul(alphaHomoraBankContract.totalETH()).div(\r\n            alphaHomoraBankContract.totalSupply()\r\n        );\r\n\r\n        return (underlyings_, underlyingAmounts_);\r\n    }\r\n\r\n    /// @notice Checks if an asset is supported by the price feed\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is supported\r\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\r\n        return _asset == IBETH_TOKEN;\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `IBETH_TOKEN` variable\r\n    /// @return ibethToken_ The `IBETH_TOKEN` variable value\r\n    function getIbethToken() external view returns (address ibethToken_) {\r\n        return IBETH_TOKEN;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/EntranceRateFeeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"./FeeBase.sol\";\r\n\r\n/// @title EntranceRateFeeBase Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Calculates a fee based on a rate to be charged to an investor upon entering a fund\r\nabstract contract EntranceRateFeeBase is FeeBase {\r\n    using SafeMath for uint256;\r\n\r\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate);\r\n\r\n    event Settled(address indexed comptrollerProxy, address indexed payer, uint256 sharesQuantity);\r\n\r\n    uint256 private constant RATE_DIVISOR = 10**18;\r\n    IFeeManager.SettlementType private immutable SETTLEMENT_TYPE;\r\n\r\n    mapping(address => uint256) private comptrollerProxyToRate;\r\n\r\n    constructor(address _feeManager, IFeeManager.SettlementType _settlementType)\r\n        public\r\n        FeeBase(_feeManager)\r\n    {\r\n        require(\r\n            _settlementType == IFeeManager.SettlementType.Burn ||\r\n                _settlementType == IFeeManager.SettlementType.Direct,\r\n            \"constructor: Invalid _settlementType\"\r\n        );\r\n        SETTLEMENT_TYPE = _settlementType;\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS\r\n\r\n    /// @notice Add the fee settings for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _settingsData Encoded settings to apply to the policy for a fund\r\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\r\n        external\r\n        override\r\n        onlyFeeManager\r\n    {\r\n        uint256 rate = abi.decode(_settingsData, (uint256));\r\n        require(rate > 0, \"addFundSettings: Fee rate must be >0\");\r\n\r\n        comptrollerProxyToRate[_comptrollerProxy] = rate;\r\n\r\n        emit FundSettingsAdded(_comptrollerProxy, rate);\r\n    }\r\n\r\n    /// @notice Gets the hooks that are implemented by the fee\r\n    /// @return implementedHooksForSettle_ The hooks during which settle() is implemented\r\n    /// @return implementedHooksForUpdate_ The hooks during which update() is implemented\r\n    /// @return usesGavOnSettle_ True if GAV is used during the settle() implementation\r\n    /// @return usesGavOnUpdate_ True if GAV is used during the update() implementation\r\n    /// @dev Used only during fee registration\r\n    function implementedHooks()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\r\n            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\r\n            bool usesGavOnSettle_,\r\n            bool usesGavOnUpdate_\r\n        )\r\n    {\r\n        implementedHooksForSettle_ = new IFeeManager.FeeHook[](1);\r\n        implementedHooksForSettle_[0] = IFeeManager.FeeHook.PostBuyShares;\r\n\r\n        return (implementedHooksForSettle_, new IFeeManager.FeeHook[](0), false, false);\r\n    }\r\n\r\n    /// @notice Settles the fee\r\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\r\n    /// @param _settlementData Encoded args to use in calculating the settlement\r\n    /// @return settlementType_ The type of settlement\r\n    /// @return payer_ The payer of shares due\r\n    /// @return sharesDue_ The amount of shares due\r\n    function settle(\r\n        address _comptrollerProxy,\r\n        address,\r\n        IFeeManager.FeeHook,\r\n        bytes calldata _settlementData,\r\n        uint256\r\n    )\r\n        external\r\n        override\r\n        onlyFeeManager\r\n        returns (\r\n            IFeeManager.SettlementType settlementType_,\r\n            address payer_,\r\n            uint256 sharesDue_\r\n        )\r\n    {\r\n        uint256 sharesBought;\r\n        (payer_, , sharesBought) = __decodePostBuySharesSettlementData(_settlementData);\r\n\r\n        uint256 rate = comptrollerProxyToRate[_comptrollerProxy];\r\n        sharesDue_ = sharesBought.mul(rate).div(RATE_DIVISOR.add(rate));\r\n\r\n        if (sharesDue_ == 0) {\r\n            return (IFeeManager.SettlementType.None, address(0), 0);\r\n        }\r\n\r\n        emit Settled(_comptrollerProxy, payer_, sharesDue_);\r\n\r\n        return (SETTLEMENT_TYPE, payer_, sharesDue_);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `rate` variable for a fund\r\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\r\n    /// @return rate_ The `rate` variable value\r\n    function getRateForFund(address _comptrollerProxy) external view returns (uint256 rate_) {\r\n        return comptrollerProxyToRate[_comptrollerProxy];\r\n    }\r\n\r\n    /// @notice Gets the `SETTLEMENT_TYPE` variable\r\n    /// @return settlementType_ The `SETTLEMENT_TYPE` variable value\r\n    function getSettlementType()\r\n        external\r\n        view\r\n        returns (IFeeManager.SettlementType settlementType_)\r\n    {\r\n        return SETTLEMENT_TYPE;\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/EntranceRateDirectFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./utils/EntranceRateFeeBase.sol\";\r\n\r\n/// @title EntranceRateDirectFee Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice An EntranceRateFee that transfers the fee shares to the fund manager\r\ncontract EntranceRateDirectFee is EntranceRateFeeBase {\r\n    constructor(address _feeManager)\r\n        public\r\n        EntranceRateFeeBase(_feeManager, IFeeManager.SettlementType.Direct)\r\n    {}\r\n\r\n    /// @notice Provides a constant string identifier for a fee\r\n    /// @return identifier_ The identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ENTRANCE_RATE_DIRECT\";\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/fee-manager/fees/EntranceRateBurnFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./utils/EntranceRateFeeBase.sol\";\r\n\r\n/// @title EntranceRateBurnFee Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice An EntranceRateFee that burns the fee shares\r\ncontract EntranceRateBurnFee is EntranceRateFeeBase {\r\n    constructor(address _feeManager)\r\n        public\r\n        EntranceRateFeeBase(_feeManager, IFeeManager.SettlementType.Burn)\r\n    {}\r\n\r\n    /// @notice Provides a constant string identifier for a fee\r\n    /// @return identifier_ The identifier string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"ENTRANCE_RATE_BURN\";\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/integratees/MockSynthetixIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./../../release/interfaces/ISynthetixExchangeRates.sol\";\r\nimport \"../prices/CentralizedRateProvider.sol\";\r\nimport \"../tokens/MockSynthetixToken.sol\";\r\n\r\n/// @dev Synthetix Integratee. Mocks functionalities from the folllowing synthetix contracts\r\n/// Synthetix, SynthetixAddressResolver, SynthetixDelegateApprovals\r\n/// Link to contracts: <https://github.com/Synthetixio/synthetix/tree/develop/contracts>\r\ncontract MockSynthetixIntegratee is Ownable, MockToken {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => mapping(address => bool)) private authorizerToDelegateToApproval;\r\n    mapping(bytes32 => address) private currencyKeyToSynth;\r\n\r\n    address private immutable CENTRALIZED_RATE_PROVIDER;\r\n    address private immutable EXCHANGE_RATES;\r\n    uint256 private immutable FEE;\r\n\r\n    uint256 private constant UNIT_FEE = 1000;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _centralizedRateProvider,\r\n        address _exchangeRates,\r\n        uint256 _fee\r\n    ) public MockToken(_name, _symbol, _decimals) {\r\n        CENTRALIZED_RATE_PROVIDER = _centralizedRateProvider;\r\n        EXCHANGE_RATES = address(_exchangeRates);\r\n        FEE = _fee;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address _exchangeForAddress,\r\n        bytes32 _srcCurrencyKey,\r\n        uint256 _srcAmount,\r\n        bytes32 _destinationCurrencyKey,\r\n        address,\r\n        bytes32\r\n    ) external returns (uint256 amountReceived_) {\r\n        require(\r\n            canExchangeFor(_exchangeForAddress, msg.sender),\r\n            \"exchangeOnBehalfWithTracking: Not approved to act on behalf\"\r\n        );\r\n\r\n        amountReceived_ = __calculateAndSwap(\r\n            _exchangeForAddress,\r\n            _srcAmount,\r\n            _srcCurrencyKey,\r\n            _destinationCurrencyKey\r\n        );\r\n\r\n        return amountReceived_;\r\n    }\r\n\r\n    function getAmountsForExchange(\r\n        uint256 _srcAmount,\r\n        bytes32 _srcCurrencyKey,\r\n        bytes32 _destCurrencyKey\r\n    )\r\n        public\r\n        returns (\r\n            uint256 amountReceived_,\r\n            uint256 fee_,\r\n            uint256 exchangeFeeRate_\r\n        )\r\n    {\r\n        address srcToken = currencyKeyToSynth[_srcCurrencyKey];\r\n        address destToken = currencyKeyToSynth[_destCurrencyKey];\r\n\r\n        require(\r\n            currencyKeyToSynth[_srcCurrencyKey] != address(0) &&\r\n                currencyKeyToSynth[_destCurrencyKey] != address(0),\r\n            \"getAmountsForExchange: Currency key doesn't have an associated synth\"\r\n        );\r\n\r\n        uint256 destAmount = CentralizedRateProvider(CENTRALIZED_RATE_PROVIDER)\r\n            .calcLiveAssetValueRandomizedBySender(srcToken, _srcAmount, destToken);\r\n\r\n        exchangeFeeRate_ = FEE;\r\n        amountReceived_ = destAmount.mul(UNIT_FEE.sub(exchangeFeeRate_)).div(UNIT_FEE);\r\n        fee_ = destAmount.sub(amountReceived_);\r\n\r\n        return (amountReceived_, fee_, exchangeFeeRate_);\r\n    }\r\n\r\n    function setSynthFromCurrencyKeys(bytes32[] calldata _currencyKeys, address[] calldata _synths)\r\n        external\r\n    {\r\n        require(\r\n            _currencyKeys.length == _synths.length,\r\n            \"setSynthFromCurrencyKey: Unequal _currencyKeys and _synths lengths\"\r\n        );\r\n        for (uint256 i = 0; i < _currencyKeys.length; i++) {\r\n            currencyKeyToSynth[_currencyKeys[i]] = _synths[i];\r\n        }\r\n    }\r\n\r\n    function approveExchangeOnBehalf(address _delegate) external {\r\n        authorizerToDelegateToApproval[msg.sender][_delegate] = true;\r\n    }\r\n\r\n    function __calculateAndSwap(\r\n        address _exchangeForAddress,\r\n        uint256 _srcAmount,\r\n        bytes32 _srcCurrencyKey,\r\n        bytes32 _destCurrencyKey\r\n    ) private returns (uint256 amountReceived_) {\r\n        MockSynthetixToken srcSynth = MockSynthetixToken(currencyKeyToSynth[_srcCurrencyKey]);\r\n        MockSynthetixToken destSynth = MockSynthetixToken(currencyKeyToSynth[_destCurrencyKey]);\r\n\r\n        require(address(srcSynth) != address(0), \"__calculateAndSwap: Source synth is not listed\");\r\n        require(\r\n            address(destSynth) != address(0),\r\n            \"__calculateAndSwap: Destination synth is not listed\"\r\n        );\r\n        require(\r\n            !srcSynth.isLocked(_exchangeForAddress),\r\n            \"__calculateAndSwap: Cannot settle during waiting period\"\r\n        );\r\n\r\n        (amountReceived_, , ) = getAmountsForExchange(\r\n            _srcAmount,\r\n            _srcCurrencyKey,\r\n            _destCurrencyKey\r\n        );\r\n\r\n        srcSynth.burnFrom(_exchangeForAddress, _srcAmount);\r\n        destSynth.mintFor(_exchangeForAddress, amountReceived_);\r\n        destSynth.lock(_exchangeForAddress);\r\n\r\n        return amountReceived_;\r\n    }\r\n\r\n    function requireAndGetAddress(bytes32 _name, string calldata)\r\n        external\r\n        view\r\n        returns (address resolvedAddress_)\r\n    {\r\n        if (_name == \"ExchangeRates\") {\r\n            return EXCHANGE_RATES;\r\n        }\r\n        return address(this);\r\n    }\r\n\r\n    function settle(address, bytes32)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {}\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    function canExchangeFor(address _authorizer, address _delegate)\r\n        public\r\n        view\r\n        returns (bool canExchange_)\r\n    {\r\n        return authorizerToDelegateToApproval[_authorizer][_delegate];\r\n    }\r\n\r\n    function getExchangeRates() public view returns (address exchangeRates_) {\r\n        return EXCHANGE_RATES;\r\n    }\r\n\r\n    function getFee() public view returns (uint256 fee_) {\r\n        return FEE;\r\n    }\r\n\r\n    function getSynthFromCurrencyKey(bytes32 _currencyKey) public view returns (address synth_) {\r\n        return currencyKeyToSynth[_currencyKey];\r\n    }\r\n\r\n    function getUnitFee() public pure returns (uint256 fee_) {\r\n        return UNIT_FEE;\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/AggregatedDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../extensions/utils/FundDeployerOwnerMixin.sol\";\r\nimport \"./IAggregatedDerivativePriceFeed.sol\";\r\n\r\n/// @title AggregatedDerivativePriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Aggregates multiple derivative price feeds (e.g., Compound, Chai) and dispatches\r\n/// rate requests to the appropriate feed\r\ncontract AggregatedDerivativePriceFeed is IAggregatedDerivativePriceFeed, FundDeployerOwnerMixin {\r\n    event DerivativeAdded(address indexed derivative, address priceFeed);\r\n\r\n    event DerivativeRemoved(address indexed derivative);\r\n\r\n    event DerivativeUpdated(\r\n        address indexed derivative,\r\n        address prevPriceFeed,\r\n        address nextPriceFeed\r\n    );\r\n\r\n    mapping(address => address) private derivativeToPriceFeed;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address[] memory _derivatives,\r\n        address[] memory _priceFeeds\r\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\r\n        if (_derivatives.length > 0) {\r\n            __addDerivatives(_derivatives, _priceFeeds);\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the rates for 1 unit of the derivative to its underlying assets\r\n    /// @param _derivative The derivative for which to get the rates\r\n    /// @return underlyings_ The underlying assets for the _derivative\r\n    /// @return underlyingAmounts_ The rates for the _derivative to the underlyings_\r\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\r\n        external\r\n        override\r\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\r\n    {\r\n        address derivativePriceFeed = derivativeToPriceFeed[_derivative];\r\n        require(\r\n            derivativePriceFeed != address(0),\r\n            \"calcUnderlyingValues: _derivative is not supported\"\r\n        );\r\n\r\n        return\r\n            IDerivativePriceFeed(derivativePriceFeed).calcUnderlyingValues(\r\n                _derivative,\r\n                _derivativeAmount\r\n            );\r\n    }\r\n\r\n    /// @notice Checks whether an asset is a supported derivative\r\n    /// @param _asset The asset to check\r\n    /// @return isSupported_ True if the asset is a supported derivative\r\n    /// @dev This should be as low-cost and simple as possible\r\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\r\n        return derivativeToPriceFeed[_asset] != address(0);\r\n    }\r\n\r\n    //////////////////////////\r\n    // DERIVATIVES REGISTRY //\r\n    //////////////////////////\r\n\r\n    /// @notice Adds a list of derivatives with the given price feed values\r\n    /// @param _derivatives The derivatives to add\r\n    /// @param _priceFeeds The ordered price feeds corresponding to the list of _derivatives\r\n    function addDerivatives(address[] calldata _derivatives, address[] calldata _priceFeeds)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(_derivatives.length > 0, \"addDerivatives: _derivatives cannot be empty\");\r\n\r\n        __addDerivatives(_derivatives, _priceFeeds);\r\n    }\r\n\r\n    /// @notice Removes a list of derivatives\r\n    /// @param _derivatives The derivatives to remove\r\n    function removeDerivatives(address[] calldata _derivatives) external onlyFundDeployerOwner {\r\n        require(_derivatives.length > 0, \"removeDerivatives: _derivatives cannot be empty\");\r\n\r\n        for (uint256 i = 0; i < _derivatives.length; i++) {\r\n            require(\r\n                derivativeToPriceFeed[_derivatives[i]] != address(0),\r\n                \"removeDerivatives: Derivative not yet added\"\r\n            );\r\n\r\n            delete derivativeToPriceFeed[_derivatives[i]];\r\n\r\n            emit DerivativeRemoved(_derivatives[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Updates a list of derivatives with the given price feed values\r\n    /// @param _derivatives The derivatives to update\r\n    /// @param _priceFeeds The ordered price feeds corresponding to the list of _derivatives\r\n    function updateDerivatives(address[] calldata _derivatives, address[] calldata _priceFeeds)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        require(_derivatives.length > 0, \"updateDerivatives: _derivatives cannot be empty\");\r\n        require(\r\n            _derivatives.length == _priceFeeds.length,\r\n            \"updateDerivatives: Unequal _derivatives and _priceFeeds array lengths\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _derivatives.length; i++) {\r\n            address prevPriceFeed = derivativeToPriceFeed[_derivatives[i]];\r\n\r\n            require(prevPriceFeed != address(0), \"updateDerivatives: Derivative not yet added\");\r\n            require(_priceFeeds[i] != prevPriceFeed, \"updateDerivatives: Value already set\");\r\n\r\n            __validateDerivativePriceFeed(_derivatives[i], _priceFeeds[i]);\r\n\r\n            derivativeToPriceFeed[_derivatives[i]] = _priceFeeds[i];\r\n\r\n            emit DerivativeUpdated(_derivatives[i], prevPriceFeed, _priceFeeds[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to add derivative-feed pairs\r\n    function __addDerivatives(address[] memory _derivatives, address[] memory _priceFeeds)\r\n        private\r\n    {\r\n        require(\r\n            _derivatives.length == _priceFeeds.length,\r\n            \"__addDerivatives: Unequal _derivatives and _priceFeeds array lengths\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _derivatives.length; i++) {\r\n            require(\r\n                derivativeToPriceFeed[_derivatives[i]] == address(0),\r\n                \"__addDerivatives: Already added\"\r\n            );\r\n\r\n            __validateDerivativePriceFeed(_derivatives[i], _priceFeeds[i]);\r\n\r\n            derivativeToPriceFeed[_derivatives[i]] = _priceFeeds[i];\r\n\r\n            emit DerivativeAdded(_derivatives[i], _priceFeeds[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to validate a derivative price feed\r\n    function __validateDerivativePriceFeed(address _derivative, address _priceFeed) private view {\r\n        require(_derivative != address(0), \"__validateDerivativePriceFeed: Empty _derivative\");\r\n        require(_priceFeed != address(0), \"__validateDerivativePriceFeed: Empty _priceFeed\");\r\n        require(\r\n            IDerivativePriceFeed(_priceFeed).isSupportedAsset(_derivative),\r\n            \"__validateDerivativePriceFeed: Unsupported derivative\"\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the registered price feed for a given derivative\r\n    /// @return priceFeed_ The price feed contract address\r\n    function getPriceFeedForDerivative(address _derivative)\r\n        external\r\n        view\r\n        override\r\n        returns (address priceFeed_)\r\n    {\r\n        return derivativeToPriceFeed[_derivative];\r\n    }\r\n}\r\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/TrackedAssetsAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../../../infrastructure/value-interpreter/ValueInterpreter.sol\";\r\nimport \"../../../utils/FundDeployerOwnerMixin.sol\";\r\nimport \"../utils/AdapterBase.sol\";\r\n\r\n/// @title TrackedAssetsAdapter Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Adapter to add tracked assets to a fund (useful e.g. to handle token airdrops)\r\ncontract TrackedAssetsAdapter is AdapterBase, FundDeployerOwnerMixin {\r\n    event DustToleranceInWethSet(uint256 nextDustToleranceInWeth);\r\n\r\n    address private immutable VALUE_INTERPRETER;\r\n    address private immutable WETH_TOKEN;\r\n\r\n    uint256 private dustToleranceInWeth;\r\n\r\n    constructor(\r\n        address _fundDeployer,\r\n        address _integrationManager,\r\n        address _valueInterpreter,\r\n        address _wethToken\r\n    ) public AdapterBase(_integrationManager) FundDeployerOwnerMixin(_fundDeployer) {\r\n        VALUE_INTERPRETER = _valueInterpreter;\r\n        WETH_TOKEN = _wethToken;\r\n\r\n        dustToleranceInWeth = 0.01 ether;\r\n    }\r\n\r\n    /// @notice Add multiple assets to the Vault's list of tracked assets\r\n    /// @dev No need to perform any validation or implement any logic\r\n    function addTrackedAssets(\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external view {}\r\n\r\n    /// @notice Provides a constant string identifier for an adapter\r\n    /// @return identifier_ The identifer string\r\n    function identifier() external pure override returns (string memory identifier_) {\r\n        return \"TRACKED_ASSETS\";\r\n    }\r\n\r\n    /// @notice Parses the expected assets to receive from a call on integration\r\n    /// @param _selector The function selector for the callOnIntegration\r\n    /// @param _encodedCallArgs The encoded parameters for the callOnIntegration\r\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\r\n    /// the adapter access to spend assets (`None` by default)\r\n    /// @return spendAssets_ The assets to spend in the call\r\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\r\n    /// @return incomingAssets_ The assets to receive in the call\r\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\r\n    function parseAssetsForMethod(bytes4 _selector, bytes calldata _encodedCallArgs)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\r\n            address[] memory spendAssets_,\r\n            uint256[] memory spendAssetAmounts_,\r\n            address[] memory incomingAssets_,\r\n            uint256[] memory minIncomingAssetAmounts_\r\n        )\r\n    {\r\n        if (_selector == ADD_TRACKED_ASSETS_SELECTOR) {\r\n            incomingAssets_ = __decodeAddTrackedAssetsCallArgs(_encodedCallArgs);\r\n\r\n            minIncomingAssetAmounts_ = new uint256[](incomingAssets_.length);\r\n            for (uint256 i; i < minIncomingAssetAmounts_.length; i++) {\r\n                minIncomingAssetAmounts_[i] = 1;\r\n            }\r\n        } else if (_selector == REMOVE_TRACKED_ASSETS_SELECTOR) {\r\n            spendAssets_ = __decodeRemoveTrackedAssetsCallArgs(_encodedCallArgs);\r\n            spendAssetAmounts_ = new uint256[](spendAssets_.length);\r\n            for (uint256 i; i < spendAssetAmounts_.length; i++) {\r\n                spendAssetAmounts_[i] = 1;\r\n            }\r\n\r\n            spendAssetsHandleType_ = IIntegrationManager.SpendAssetsHandleType.Remove;\r\n        } else {\r\n            revert(\"parseAssetsForMethod: _selector invalid\");\r\n        }\r\n\r\n        return (\r\n            spendAssetsHandleType_,\r\n            spendAssets_,\r\n            spendAssetAmounts_,\r\n            incomingAssets_,\r\n            minIncomingAssetAmounts_\r\n        );\r\n    }\r\n\r\n    /// @notice Removes multiple assets from the Vault's list of tracked assets\r\n    /// @param _vaultProxy The VaultProxy of the calling fund\r\n    /// @param _encodedCallArgs Encoded order parameters\r\n    /// @dev No need to validate caller\r\n    function removeTrackedAssets(\r\n        address _vaultProxy,\r\n        bytes calldata _encodedCallArgs,\r\n        bytes calldata\r\n    ) external {\r\n        address[] memory spendAssets = __decodeRemoveTrackedAssetsCallArgs(_encodedCallArgs);\r\n        uint256 dustToleranceInWethCopy = dustToleranceInWeth;\r\n        for (uint256 i; i < spendAssets.length; i++) {\r\n            (uint256 valueInWeth, bool isValid) = ValueInterpreter(VALUE_INTERPRETER)\r\n                .calcCanonicalAssetValue(\r\n                spendAssets[i],\r\n                ERC20(spendAssets[i]).balanceOf(_vaultProxy),\r\n                WETH_TOKEN\r\n            );\r\n            require(isValid, \"removeTrackedAssets: Invalid GAV\");\r\n            require(\r\n                valueInWeth <= dustToleranceInWethCopy,\r\n                \"removeTrackedAssets: Exceeds dust threshold\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Helper to decode the encoded call arguments to addTrackedAssets()\r\n    function __decodeAddTrackedAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address[] memory incomingAssets_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[]));\r\n    }\r\n\r\n    /// @dev Helper to decode the encoded call arguments to removeTrackedAssets()\r\n    function __decodeRemoveTrackedAssetsCallArgs(bytes memory _encodedCallArgs)\r\n        private\r\n        pure\r\n        returns (address[] memory spendAssets_)\r\n    {\r\n        return abi.decode(_encodedCallArgs, (address[]));\r\n    }\r\n\r\n    ////////////////////\r\n    // DUST TOLERANCE //\r\n    ////////////////////\r\n\r\n    /// @notice Sets the dustToleranceInWeth variable value\r\n    /// @param _nextDustToleranceInWeth The next dustToleranceInWeth value\r\n    function setDustToleranceInWeth(uint256 _nextDustToleranceInWeth)\r\n        external\r\n        onlyFundDeployerOwner\r\n    {\r\n        dustToleranceInWeth = _nextDustToleranceInWeth;\r\n\r\n        emit DustToleranceInWethSet(_nextDustToleranceInWeth);\r\n    }\r\n\r\n    ///////////////////\r\n    // STATE GETTERS //\r\n    ///////////////////\r\n\r\n    /// @notice Gets the `dustToleranceInWeth` variable value\r\n    /// @return dustToleranceInWeth_ The `dustToleranceInWeth` variable value\r\n    function getDustToleranceInWeth() external view returns (uint256 dustToleranceInWeth_) {\r\n        return dustToleranceInWeth;\r\n    }\r\n\r\n    /// @notice Gets the `VALUE_INTERPRETER` variable value\r\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\r\n    function getValueInterpreter() external view returns (address valueInterpreter_) {\r\n        return VALUE_INTERPRETER;\r\n    }\r\n\r\n    /// @notice Gets the `WETH_TOKEN` variable\r\n    /// @return wethToken_ The `WETH_TOKEN` variable value\r\n    function getWethToken() external view returns (address wethToken_) {\r\n        return WETH_TOKEN;\r\n    }\r\n}\r\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/RevertingPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    This file is part of the Enzyme Protocol.\r\n\r\n    (c) Enzyme Council <council@enzyme.finance>\r\n\r\n    For the full license information, please view the LICENSE\r\n    file that was distributed with this source code.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../IDerivativePriceFeed.sol\";\r\n\r\n/// @title RevertingPriceFeed Contract\r\n/// @author Enzyme Council <security@enzyme.finance>\r\n/// @notice Price feed that always reverts on value conversion\r\n/// @dev Used purely for extraordinary circumstances where we want to prevent value calculations,\r\n/// while allowing an asset to continue to be in the asset universe\r\ncontract RevertingPriceFeed is IDerivativePriceFeed {\r\n    /// @notice Converts a given amount of a derivative to its underlying asset values\r\n    function calcUnderlyingValues(address, uint256)\r\n        external\r\n        override\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        revert(\"calcUnderlyingValues: RevertingPriceFeed\");\r\n    }\r\n\r\n    /// @notice Checks whether an asset is a supported primitive of the price feed\r\n    /// @return isSupported_ True if the asset is a supported primitive\r\n    function isSupportedAsset(address) public view override returns (bool isSupported_) {\r\n        return true;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}